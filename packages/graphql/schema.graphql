scalar AccessToken

type Account {
  address: EvmAddress!

  """
  The owner of the account - note if the Account is not a lens account this will return the
  address of the account itself.
  """
  owner: EvmAddress!

  """
  The account created at. Note if they are using a standard EOA this will be genesis block
  timestamp
  """
  createdAt: DateTime!

  """The score of the account."""
  score: Int!

  """The metadata of the account."""
  metadata: AccountMetadata

  """The username linked to the account."""
  username(request: AccountUsernameRequest): Username

  """The operations for the account."""
  operations: LoggedInAccountOperations

  """Get the rules for the account."""
  rules(request: RuleInput): FollowRulesConfig!
}

union AccountAvailable = AccountManaged | AccountOwned

type AccountBlocked {
  account: Account!
  blockedAt: DateTime!
}

input AccountBlockedNotificationAttributes {
  graph: EvmAddress
  app: EvmAddress
}

input AccountCreatedNotificationAttributes {
  graph: EvmAddress
  app: EvmAddress
}

type AccountFeedsStats {
  """The total number of posts."""
  posts: Int!

  """The total number of comments."""
  comments: Int!

  """The total number of reposts."""
  reposts: Int!

  """The total number of quotes."""
  quotes: Int!

  """The total number of times the account has reacted."""
  reacted: Int!

  """The total number of reactions."""
  reactions: Int!

  """The total number of collects."""
  collects: Int!
}

input AccountFeedsStatsFilter {
  """The feeds to filter by."""
  feeds: [FeedOneOf!]
}

input AccountFeedsStatsRequest {
  """The account to get stats for."""
  account: EvmAddress!

  """An optional filter to apply to the result."""
  filter: AccountFeedsStatsFilter
}

input AccountFollowedNotificationAttributes {
  follower: EvmAddress
  followedAccount: EvmAddress
  graph: EvmAddress
  app: EvmAddress
}

type AccountGraphsFollowStats {
  """The total number of followers."""
  followers: Int!

  """The total number of following."""
  following: Int!
}

input AccountGraphsStatsFilter {
  """The graphs to filter by."""
  graphs: [GraphOneOf!]
}

input AccountGraphsStatsRequest {
  """The account to get stats for."""
  account: EvmAddress!

  """An optional filter to apply to the result."""
  filter: AccountGraphsStatsFilter
}

type AccountManaged {
  """The account you are managing."""
  account: Account!

  """The permissions you have on the account."""
  permissions: AccountManagerPermissions!

  """The date the account management was added."""
  addedAt: DateTime!
}

type AccountManager {
  """The address of the account manager."""
  manager: EvmAddress!

  """Whether the account manager is a Lens manager."""
  isLensManager: Boolean!

  """The permissions the account manager has."""
  permissions: AccountManagerPermissions!

  """The date the account manager was added."""
  addedAt: DateTime!
}

input AccountManagerAddedNotificationAttributes {
  managedAccount: EvmAddress
  manager: EvmAddress
}

input AccountManagerChallengeRequest {
  """
  The App you intend to authenticate with.
  
  It MUST be a valid App address.
  Note: On the testnet, it will default to `0x90C8C68D0ABFB40D4FCD72316A65E42161520BC3`, the
  playground app. This is to make it easier if you forget to set it. This may change in the
  future.
  """
  app: EvmAddress! = "0xe5439696f4057aF073c0FB2dc6e5e755392922e1"

  """The address of the Lens Account."""
  account: EvmAddress!

  """The address of the Account Manager."""
  manager: EvmAddress!
}

type AccountManagerPermissions {
  """Whether the account can execute transactions."""
  canExecuteTransactions: Boolean!

  """Whether the account can transfer tokens."""
  canTransferTokens: Boolean!

  """Whether the account can transfer native tokens."""
  canTransferNative: Boolean!

  """Whether the account can set the metadata URI."""
  canSetMetadataUri: Boolean!
}

input AccountManagerPermissionsInput {
  """Whether the account can execute transactions."""
  canExecuteTransactions: Boolean!

  """Whether the account can transfer tokens."""
  canTransferTokens: Boolean!

  """Whether the account can transfer native tokens."""
  canTransferNative: Boolean!

  """Whether the account can set the metadata URI."""
  canSetMetadataUri: Boolean!
}

input AccountManagerRemovedNotificationAttributes {
  managedAccount: EvmAddress
  manager: EvmAddress
}

input AccountManagerUpdatedNotificationAttributes {
  managedAccount: EvmAddress
  manager: EvmAddress
}

input AccountManagersRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type AccountMention {
  """The account that was mentioned."""
  account: EvmAddress!

  """The namespace that was used in a mention."""
  namespace: EvmAddress!

  """
  The replacement information.
  Use to replace mentions in the post content.
  """
  replace: MentionReplace!
}

input AccountMentionedNotificationAttributes {
  author: EvmAddress
  feed: EvmAddress
  mentionedAccount: EvmAddress
  mentionedUsername: UsernameValue
  app: EvmAddress
}

type AccountMetadata {
  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """The Account bio as markdown."""
  bio: String

  """The Account cover picture."""
  coverPicture: URI

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """The Account display name."""
  name: String

  """The Account picture."""
  picture: URI
}

type AccountOwned {
  """The account you own."""
  account: Account!

  """The date the account was created."""
  addedAt: DateTime!
}

input AccountOwnerChallengeRequest {
  """
  The App you intend to authenticate with.
  
  It MUST be a valid App address.
  Note: On the testnet, it will default to `0x90C8C68D0ABFB40D4FCD72316A65E42161520BC3`, the
  playground app. This is to make it easier if you forget to set it. This may change in the
  future.
  """
  app: EvmAddress! = "0xe5439696f4057aF073c0FB2dc6e5e755392922e1"

  """The address of the Lens Account."""
  account: EvmAddress!

  """The address of the Account Owner."""
  owner: EvmAddress!
}

input AccountOwnershipTransferredNotificationAttributes {
  account: EvmAddress
}

type AccountPostReaction {
  account: Account!
  reactions: [PostReaction!]!
}

enum AccountReportReason {
  IMPERSONATION
  REPETITIVE_SPAM
  OTHER
}

input AccountReportedNotificationAttributes {
  reportedAccount: EvmAddress
  reporter: EvmAddress
  app: EvmAddress
}

input AccountRequest {
  """The account address."""
  address: EvmAddress

  """The username."""
  username: UsernameInput

  """The legacy profile ID."""
  legacyProfileId: LegacyProfileId

  """The transaction hash you created the account with."""
  txHash: TxHash
}

type AccountStats {
  """The stats for the feeds."""
  feedStats: AccountFeedsStats!

  """The stats for the graphs."""
  graphFollowStats: AccountGraphsFollowStats!
}

input AccountStatsRequest {
  """The account to get stats for."""
  account: EvmAddress!

  """The feeds to get stats for."""
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]

  """The graphs to get stats for."""
  forGraphs: [EvmAddress!]! = ["0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"]
}

input AccountUnblockedNotificationAttributes {
  graph: EvmAddress
  app: EvmAddress
}

input AccountUnfollowedNotificationAttributes {
  unfollower: EvmAddress
  unfollowedAccount: EvmAddress
  graph: EvmAddress
  app: EvmAddress
}

input AccountUsernameAssignedNotificationAttributes {
  namespace: EvmAddress
  account: EvmAddress
}

input AccountUsernameCreatedNotificationAttributes {
  namespace: EvmAddress
  account: EvmAddress
}

input AccountUsernameRequest {
  """The namespace to get account assigned username"""
  namespace: EvmAddress! = "0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"
}

input AccountUsernameUnassignedNotificationAttributes {
  namespace: EvmAddress
  previousAccount: EvmAddress
}

input AccountsAvailableRequest {
  """The account to get managed by."""
  managedBy: EvmAddress!

  """Whether to include owned accounts. Defaults to true."""
  includeOwned: Boolean! = true

  """The visibility of hidden accounts."""
  hiddenFilter: ManagedAccountsVisibility! = ALL

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input AccountsBlockedRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input AccountsBulkRequest {
  """The addresses to get."""
  addresses: [EvmAddress!]

  """The usernames to get."""
  usernames: [UsernameInput!]

  """The legacy profile IDs to get."""
  legacyProfileIds: [LegacyProfileId!]
}

input AccountsFilter {
  """The optional filter to narrow accounts by search query."""
  searchBy: UsernameSearchInput
}

enum AccountsOrderBy {
  ALPHABETICAL
  ACCOUNT_SCORE
  BEST_MATCH
}

input AccountsRequest {
  filter: AccountsFilter

  """The order by."""
  orderBy: AccountsOrderBy! = ACCOUNT_SCORE

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input ActionFilter {
  address: EvmAddress
  actionType: PostActionType
  category: PostActionCategoryType
}

union ActionInfo = KnownAction | UnknownAction

type ActionInputInfo {
  name: String!
  type: String!
}

input AddAccountManagerRequest {
  """The address to add as a manager."""
  address: EvmAddress!

  """The permissions to give the account manager."""
  permissions: AccountManagerPermissionsInput!
}

union AddAccountManagerResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input AddAdminsRequest {
  """
  The graph/app/sponsor/feed/username/group address which manages these admins
  """
  address: EvmAddress!

  """The addresses to add as admins"""
  admins: [EvmAddress!]!
}

union AddAdminsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input AddAppAuthorizationEndpointRequest {
  """The app."""
  app: EvmAddress!

  """The app authorization endpoint."""
  endpoint: URL!
}

input AddAppFeedsRequest {
  """The app to update"""
  app: EvmAddress!

  """The app feeds (max 10 per request)"""
  feeds: [EvmAddress!]!
}

union AddAppFeedsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input AddAppGroupsRequest {
  """The app to update"""
  app: EvmAddress!

  """The app groups (max 10 per request)"""
  groups: [EvmAddress!]!
}

union AddAppGroupsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input AddAppSignersRequest {
  """The app to update"""
  app: EvmAddress!

  """The app signers (max 10 per request)"""
  signers: [EvmAddress!]!
}

union AddAppSignersResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type AddReactionFailure {
  reason: String!
}

input AddReactionRequest {
  """The reaction to add."""
  reaction: PostReactionType!

  """The post to react to."""
  post: PostId!
}

type AddReactionResponse {
  success: Boolean!
}

union AddReactionResult = AddReactionResponse | AddReactionFailure

type Admin {
  account: Account!
  addedAt: DateTime!
}

input AdminsForFilterRequest {
  """The optional filter to narrow admins query"""
  searchBy: UsernameSearchInput
}

enum AdminsForOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
}

input AdminsForRequest {
  """The graph/app/sponsor/feed/username/group address"""
  address: EvmAddress!
  filter: AdminsForFilterRequest

  """The order by."""
  orderBy: AdminsForOrderBy! = LATEST_FIRST
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type Amount {
  asset: Asset!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!
}

input AmountInput {
  """
  The token address. To represent the native token, use the
  0x000000000000000000000000000000000000800a.
  """
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!
}

"""AnyMedia"""
union AnyMedia = MediaAudio | MediaImage | MediaVideo

union AnyPost = Post | Repost

type App {
  address: EvmAddress!
  graphAddress: EvmAddress
  sponsorshipAddress: EvmAddress
  defaultFeedAddress: EvmAddress
  namespaceAddress: EvmAddress
  treasuryAddress: EvmAddress
  verificationEnabled: Boolean!
  createdAt: DateTime!
  metadata: AppMetadata
  owner: EvmAddress!
}

type AppFeed {
  feed: EvmAddress!
  timestamp: DateTime!
}

input AppFeedsRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The app address"""
  app: EvmAddress!
}

input AppGroupsRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The app address"""
  app: EvmAddress!
}

type AppMetadata {
  """
  An optional short and detailed description of the app, explaining its features and purpose.
  """
  description: String

  """The Developer of the app."""
  developer: String!

  """The Logo icon for the app."""
  logo: URI

  """The name of the app."""
  name: String!

  """The tagline of the app."""
  tagline: String

  """The platforms supported by the app."""
  platforms: [AppPlatform!]!

  """The privacy policy for the app."""
  privacyPolicy: URI

  """The terms of service for the app."""
  termsOfService: URI

  """The url of the app."""
  url: URI!
}

enum AppPlatform {
  WEB
  IOS
  ANDROID
}

input AppRequest {
  """The app"""
  app: EvmAddress

  """The transaction hash you created the app with."""
  txHash: TxHash
}

input AppServerApiKeyRequest {
  """The app address."""
  app: EvmAddress!
}

type AppSigner {
  signer: EvmAddress!
  timestamp: DateTime!
}

input AppSignersFilterRequest {
  """
  The optional filter to narrow signers.
  Uses fuzzy search on signer address
  """
  searchQuery: String
}

enum AppSignersOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
}

input AppSignersRequest {
  """The app address"""
  app: EvmAddress!
  filter: AppSignersFilterRequest

  """The order by."""
  orderBy: AppSignersOrderBy! = LATEST_FIRST

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type AppUser {
  account: Account!
  lastActiveOn: DateTime!
  firstLoginOn: DateTime!
}

input AppUsersFilterRequest {
  """The optional filter to narrow app users query"""
  searchBy: UsernameSearchInput
}

enum AppUsersOrderBy {
  ALPHABETICAL
  ACCOUNT_SCORE
  BEST_MATCH
}

input AppUsersRequest {
  """The App to get users for."""
  app: EvmAddress!
  filter: AppUsersFilterRequest

  """The order by."""
  orderBy: AppUsersOrderBy! = ACCOUNT_SCORE

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type ApprovalGroupRule {
  rule: EvmAddress!
}

input AppsFilter {
  """The optional filter to get apps managed by address"""
  managedBy: ManagedBy

  """
  The optional filter to narrow apps by search query.
  Uses fuzzy search on app name
  """
  searchQuery: String
}

enum AppsOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
  ALPHABETICAL
}

input AppsRequest {
  """The optional apps filter"""
  filter: AppsFilter

  """The order by."""
  orderBy: AppsOrderBy! = LATEST_FIRST

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type AppsResult {
  items: [App!]!
  pageInfo: PaginatedResultInfo!
}

type ArticleMetadata {
  """Any attachment you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  content: String!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional article title."""
  title: String
}

union Asset = Erc20

type AssignUsernameResponse {
  hash: TxHash!
}

input AssignUsernameToAccountRequest {
  username: UsernameInput!
}

union AssignUsernameToAccountResult = AssignUsernameResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type AudioMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  audio: MediaAudio!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional audio title."""
  title: String
  content: String!
}

type AuthenticatedSession {
  authenticationId: UUID!
  app: EvmAddress!
  browser: String
  device: String
  os: String
  origin: URL
  signer: EvmAddress!
  createdAt: DateTime!
  updatedAt: DateTime!
  expiresAt: DateTime!
}

input AuthenticatedSessionsRequest {
  """
  You can optionally filter the authentications by the app that created them.
  """
  app: EvmAddress
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type AuthenticationChallenge {
  id: UUID!
  text: String!
}

union AuthenticationResult = AuthenticationTokens | WrongSignerError | ExpiredChallengeError | ForbiddenError

type AuthenticationTokens {
  """
  The Access Token to use as a Bearer token in authenticated Lens API requests.
  """
  accessToken: AccessToken!

  """
  The Refresh Token to use to obtain a new tokens triplet without re-authenticating.
  """
  refreshToken: RefreshToken!
  idToken: IdToken!
}

scalar BigDecimal

scalar BigInt

type BlockError {
  error: BlockErrorType!
}

enum BlockErrorType {
  UNKNOWN
  ALREADY_BLOCKED
  UNAUTHORIZED
}

input BlockRequest {
  """The account to block."""
  account: EvmAddress!
}

type BlockResponse {
  hash: TxHash!
}

union BlockResult = BlockResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | BlockError

scalar BlockchainData

input BookmarkPostRequest {
  post: PostId!
}

type BooleanValue {
  optimistic: Boolean!
  onChain: Boolean!
}

input BuilderChallengeRequest {
  """The builder's address. Most typically the EOA of their wallet."""
  address: EvmAddress!
}

input CanFollowRequest {
  graph: EvmAddress!
}

input CanUnfollowRequest {
  graph: EvmAddress!
}

scalar ChainId

"""
The request to generate a new authentication challenge.

The optional fields are used to specify the role you are authenticating as.
You can only specify one role at a time.
"""
input ChallengeRequest {
  """Use this to authenticate as a Builder."""
  builder: BuilderChallengeRequest

  """Use this to authenticate as an Account Manager."""
  accountManager: AccountManagerChallengeRequest

  """Use this to authenticate as an Account Owner."""
  accountOwner: AccountOwnerChallengeRequest

  """Use this to authenticate as an Onboarding User."""
  onboardingUser: OnboardingUserChallengeRequest
}

type CharsetUsernameNamespaceRule {
  rule: EvmAddress!
  allowNumeric: Boolean!
  allowLatinLowercase: Boolean!
  allowLatinUppercase: Boolean!
  customAllowedCharset: [String!]
  customDisallowedCharset: [String!]
  cannotStartWith: String
}

type CheckingInMetadata {
  """The optional address of the location."""
  address: PhysicalAddress

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """Where you're checking in from (free form text)."""
  location: String!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """The optional geographic position of the location."""
  position: GeoUri

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: String!
}

input CollectActionInput {
  simpleCollectAction: SimpleCollectActionInput
}

type CommentNotification {
  id: GeneratedNotificationId!
  comment: Post!
}

enum ContentWarning {
  NSFW
  SENSITIVE
  SPOILER
}

type CreateAccountResponse {
  hash: TxHash!
}

input CreateAccountWithUsernameRequest {
  """The account metadata uri"""
  metadataUri: URI!

  """The username you wish to mint with the account"""
  username: UsernameInput!

  """Any account managers you wish to add to the account"""
  accountManager: [EvmAddress!]
}

union CreateAccountWithUsernameResult = CreateAccountResponse | InvalidUsername | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input CreateAppRequest {
  """The app metadata uri"""
  metadataUri: URI

  """List of admins who can manage this app"""
  admins: [EvmAddress!]

  """The app graph defaults to use the global graph"""
  graph: EvmAddress! = "0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"

  """The app feeds defaults to use the global feed"""
  feeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]

  """The default feed defaults to use the global feed"""
  defaultFeed: EvmAddress! = "0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"

  """The app username leave empty to use the lens username"""
  namespace: EvmAddress! = "0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"

  """The app groups leave empty if none"""
  groups: [EvmAddress!]

  """
  Whether the App Verification workflow is enabled.
  This gives control to approve or reject transactions involving
  social interactions (e.g., post, follow, comment, etc.) using the app.
  """
  verification: Boolean! = false

  """The app signers leave empty if none"""
  signers: [EvmAddress!]

  """The app paymaster leave empty if none"""
  paymaster: EvmAddress

  """The app treasury leave empty if none"""
  treasury: EvmAddress
}

type CreateAppResponse {
  hash: TxHash!
}

union CreateAppResult = CreateAppResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateFeedRequest {
  """The feed metadata uri"""
  metadataUri: URI

  """List of admins who can manage this feed"""
  admins: [EvmAddress!]
}

type CreateFeedResponse {
  hash: TxHash!
}

union CreateFeedResult = CreateFeedResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateFollowRequest {
  """The account to follow."""
  account: EvmAddress!

  """
  The graph to follow the account on. If not provided, the global graph is used.
  """
  graph: EvmAddress! = "0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"

  """
  The data required by any follow rules associated with the account being followed.
  """
  followRule: FollowRulesInput

  """
  The data required by the graph rules associated with the specified graph.
  """
  graphRule: GraphRulesInput
}

input CreateGraphRequest {
  """The graph metadata uri"""
  metadataUri: URI

  """List of admins who can manage this graph"""
  admins: [EvmAddress!]
}

type CreateGraphResponse {
  hash: TxHash!
}

union CreateGraphResult = CreateGraphResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateGroupRequest {
  """The group metadata uri"""
  metadataUri: URI

  """List of admins who can manage this group"""
  admins: [EvmAddress!]
}

type CreateGroupResponse {
  hash: TxHash!
}

union CreateGroupResult = CreateGroupResponse | SelfFundedTransactionRequest | TransactionWillFail

type CreateNamespaceResponse {
  hash: TxHash!
}

input CreatePostRequest {
  """The feed to post to. If not provided, the global feed is used."""
  feed: EvmAddress! = "0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"

  """The URI of the post metadata."""
  contentUri: URI!

  """The post to quote, if any."""
  quoteOf: ReferencingPostInput

  """The post to comment on, if any."""
  commentOn: ReferencingPostInput

  """The actions to attach to the post."""
  actions: [PostActionInput!]
}

input CreateRepostRequest {
  """The feed to repost to. If not provided, the global feed is used."""
  feed: EvmAddress! = "0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"

  """The post to reference."""
  post: PostId!
}

input CreateSnsSubscriptionRequest {
  """
  The webhook URL to send notifications to. It must be an HTTP or HTTPS URL that is
  accessible by the Lens API and is owned by you as it will be used to confirm the
  subscription.
  """
  webhook: String!

  """
  The topics to subscribe to. You can subscribe to multiple topics at once. This cannot be
  changed once the subscription is created.
  """
  topics: [SnsTopicInput!]!

  """The app to optionally assign this subscription to."""
  app: EvmAddress
}

input CreateSponsorshipRequest {
  """The sponsorship metadata URI"""
  metadataUri: URI

  """List of admins who can manage this sponsorship."""
  admins: [EvmAddress!]

  """List of sponsorship signers."""
  signers: [SponsorshipSignerInput!]

  """
  Indicates whether the Lens API is authorized as the sponsorship signer
  to sponsor end-user social operations (e.g., posts, comments, follows)
  performed through the Lens API for apps associated with this sponsorship.
  """
  allowLensAccess: Boolean!

  """The sponsorship usage allowances with the corresponding limits."""
  rateLimit: SponsorshipRateLimits

  """The list of addresses excluded from the sponsorship rate limits."""
  exclusionList: [SponsorshipRateLimitsExempt!]
}

type CreateSponsorshipResponse {
  hash: TxHash!
}

union CreateSponsorshipResult = CreateSponsorshipResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateUnfollowRequest {
  """The account to unfollow."""
  account: EvmAddress!

  """
  The graph where the account is followed and should be unfollowed.
  If not provided, the global graph is used.
  """
  graph: EvmAddress! = "0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"

  """
  The data required by the graph rules associated with the specified graph.
  """
  graphRule: GraphRulesInput
}

input CreateUsernameNamespaceRequest {
  """The feed metadata uri"""
  metadataUri: URI

  """List of admins who can manage this feed"""
  admins: [EvmAddress!]

  """
  The namespace for example for lens this would be lens, and it means that the usernames will
  be like lens/username
  """
  namespace: String!

  """
  The symbol for the namespace as usernames minted under the namespace are NFTs
  """
  symbol: String!
}

union CreateUsernameNamespaceResult = CreateNamespaceResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateUsernameRequest {
  username: UsernameInput!

  """If you want to auto assign the username to the account default is true"""
  autoAssign: Boolean! = true
}

type CreateUsernameResponse {
  hash: TxHash!
}

union CreateUsernameResult = CreateUsernameResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar Cursor

scalar DateTime

input DebugPostMetadataRequest {
  rawUri: URI
  json: String
  source: EntityType!
}

type DebugPostMetadataResult {
  valid: Boolean!
  reason: String
}

input DeletePostRequest {
  """The post to delete."""
  post: PostId!

  """If needed, the feed rule data required to accomplish the deletion."""
  feedRules: FeedRulesInput
}

type DeletePostResponse {
  hash: TxHash!
}

union DeletePostResult = DeletePostResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input DeleteSnsSubscriptionRequest {
  id: UUID!
}

input EditPostRequest {
  post: PostId!
  contentUri: URI!
}

type Eip1559TransactionRequest {
  """The transaction type: 2 for EIP-1559 transactions."""
  type: Int!

  """The target of the transaction."""
  to: EvmAddress!

  """The sender of the transaction."""
  from: EvmAddress!

  """The nonce of the transaction, used to prevent replay attacks."""
  nonce: Int!

  """The maximum amount of gas to allow this transaction to consume."""
  gasLimit: Int!

  """The maximum priority fee to pay per gas."""
  maxPriorityFeePerGas: BigInt!

  """
  The maximum total fee to pay per gas. The actual
  value used is protocol enforced to be the block's base fee.
  """
  maxFeePerGas: BigInt!

  """The transaction data."""
  data: BlockchainData!

  """The transaction value (in wei)."""
  value: BigInt!

  """The chain ID for the network this transaction is valid on."""
  chainId: Int!
}

"""Contains EIP-712 transaction metadata."""
type Eip712Meta {
  """
  The maximum amount of gas the user is willing to pay for a single byte of pubdata.
  """
  gasPerPubdata: BigInt!

  """
  An array of bytes containing the bytecode of the contract being deployed and any related
  contracts it can deploy.
  """
  factoryDeps: [BlockchainData!]!

  """
  Custom signature used for cases where the signer's account is not an EOA.
  """
  customSignature: BlockchainData

  """Parameters for configuring the custom paymaster for the transaction."""
  paymasterParams: PaymasterParams
}

type Eip712TransactionRequest {
  """The transaction type: 113 for EIP-712 transactions."""
  type: Int!

  """The target of the transaction."""
  to: EvmAddress!

  """The sender of the transaction."""
  from: EvmAddress!

  """The nonce of the transaction, used to prevent replay attacks."""
  nonce: Int!

  """The maximum amount of gas to allow this transaction to consume."""
  gasLimit: Int!

  """The maximum priority fee to pay per gas."""
  maxPriorityFeePerGas: BigInt!

  """
  The maximum total fee to pay per gas. The actual
  value used is protocol enforced to be the block's base fee.
  """
  maxFeePerGas: BigInt!

  """The transaction data."""
  data: BlockchainData!

  """The transaction value (in wei)."""
  value: BigInt!

  """The chain ID for the network this transaction is valid on."""
  chainId: Int!

  """The custom data for EIP-712 transaction metadata."""
  customData: Eip712Meta!
}

type EmbedMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning

  """The embed URL."""
  embed: URI!
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: String!
}

union EnableSignlessResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input EntityId @oneOf {
  account: EvmAddress
  graph: EvmAddress
  feed: EvmAddress
  usernameNamespace: EvmAddress
  group: EvmAddress
  post: PostId
  app: EvmAddress
  sponsorship: EvmAddress
}

enum EntityType {
  ACCOUNT
  GRAPH
  FEED
  USERNAME_NAMESPACE
  GROUP
  POST
  APP
  SPONSORSHIP
}

type Erc20 {
  name: String!
  symbol: String!
  decimals: Int!
  contract: NetworkAddress!
}

type EventMetadata {
  """The address of the event."""
  address: PhysicalAddress

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning

  """The event end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  endsAt: DateTime!
  id: MetadataId!

  """The links you want to include with it."""
  links: [URI!]!
  locale: Locale!

  """The location of the event."""
  location: EventMetadataLensLocation!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """The geographic position of the event."""
  position: GeoUri
  schedulingAdjustments: EventMetadataLensSchedulingAdjustments

  """The event start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: DateTime!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The title of the event."""
  title: String
  content: String!
}

type EventMetadataLensLocation {
  physical: String
  virtual: URI
}

type EventMetadataLensSchedulingAdjustments {
  """
  Indicates a reference timezone for the event start and end times. If physical event, you
  could use the timezone of the event location. If virtual event, the timezone of the event
  organizer.
  """
  timezoneId: EventMetadataLensSchedulingAdjustmentsTimezoneId!
  timezoneOffset: Float!
}

enum EventMetadataLensSchedulingAdjustmentsTimezoneId {
  AFRICA_ABIDJAN
  AFRICA_ACCRA
  AFRICA_ADDIS_ABABA
  AFRICA_ALGIERS
  AFRICA_ASMERA
  AFRICA_BAMAKO
  AFRICA_BANGUI
  AFRICA_BANJUL
  AFRICA_BISSAU
  AFRICA_BLANTYRE
  AFRICA_BRAZZAVILLE
  AFRICA_BUJUMBURA
  AFRICA_CAIRO
  AFRICA_CASABLANCA
  AFRICA_CEUTA
  AFRICA_CONAKRY
  AFRICA_DAKAR
  AFRICA_DAR_ES_SALAAM
  AFRICA_DJIBOUTI
  AFRICA_DOUALA
  AFRICA_EL_AAIUN
  AFRICA_FREETOWN
  AFRICA_GABORONE
  AFRICA_HARARE
  AFRICA_JOHANNESBURG
  AFRICA_JUBA
  AFRICA_KAMPALA
  AFRICA_KHARTOUM
  AFRICA_KIGALI
  AFRICA_KINSHASA
  AFRICA_LAGOS
  AFRICA_LIBREVILLE
  AFRICA_LOME
  AFRICA_LUANDA
  AFRICA_LUBUMBASHI
  AFRICA_LUSAKA
  AFRICA_MALABO
  AFRICA_MAPUTO
  AFRICA_MASERU
  AFRICA_MBABANE
  AFRICA_MOGADISHU
  AFRICA_MONROVIA
  AFRICA_NAIROBI
  AFRICA_NDJAMENA
  AFRICA_NIAMEY
  AFRICA_NOUAKCHOTT
  AFRICA_OUAGADOUGOU
  AFRICA_PORTO_NOVO
  AFRICA_SAO_TOME
  AFRICA_TRIPOLI
  AFRICA_TUNIS
  AFRICA_WINDHOEK
  AMERICA_ADAK
  AMERICA_ANCHORAGE
  AMERICA_ANGUILLA
  AMERICA_ANTIGUA
  AMERICA_ARAGUAINA
  AMERICA_ARGENTINA_LA_RIOJA
  AMERICA_ARGENTINA_RIO_GALLEGOS
  AMERICA_ARGENTINA_SALTA
  AMERICA_ARGENTINA_SAN_JUAN
  AMERICA_ARGENTINA_SAN_LUIS
  AMERICA_ARGENTINA_TUCUMAN
  AMERICA_ARGENTINA_USHUAIA
  AMERICA_ARUBA
  AMERICA_ASUNCION
  AMERICA_BAHIA
  AMERICA_BAHIA_BANDERAS
  AMERICA_BARBADOS
  AMERICA_BELEM
  AMERICA_BELIZE
  AMERICA_BLANC_SABLON
  AMERICA_BOA_VISTA
  AMERICA_BOGOTA
  AMERICA_BOISE
  AMERICA_BUENOS_AIRES
  AMERICA_CAMBRIDGE_BAY
  AMERICA_CAMPO_GRANDE
  AMERICA_CANCUN
  AMERICA_CARACAS
  AMERICA_CATAMARCA
  AMERICA_CAYENNE
  AMERICA_CAYMAN
  AMERICA_CHICAGO
  AMERICA_CHIHUAHUA
  AMERICA_CIUDAD_JUAREZ
  AMERICA_CORAL_HARBOUR
  AMERICA_CORDOBA
  AMERICA_COSTA_RICA
  AMERICA_CRESTON
  AMERICA_CUIABA
  AMERICA_CURACAO
  AMERICA_DANMARKSHAVN
  AMERICA_DAWSON
  AMERICA_DAWSON_CREEK
  AMERICA_DENVER
  AMERICA_DETROIT
  AMERICA_DOMINICA
  AMERICA_EDMONTON
  AMERICA_EIRUNEPE
  AMERICA_EL_SALVADOR
  AMERICA_FORT_NELSON
  AMERICA_FORTALEZA
  AMERICA_GLACE_BAY
  AMERICA_GODTHAB
  AMERICA_GOOSE_BAY
  AMERICA_GRAND_TURK
  AMERICA_GRENADA
  AMERICA_GUADELOUPE
  AMERICA_GUATEMALA
  AMERICA_GUAYAQUIL
  AMERICA_GUYANA
  AMERICA_HALIFAX
  AMERICA_HAVANA
  AMERICA_HERMOSILLO
  AMERICA_INDIANA_KNOX
  AMERICA_INDIANA_MARENGO
  AMERICA_INDIANA_PETERSBURG
  AMERICA_INDIANA_TELL_CITY
  AMERICA_INDIANA_VEVAY
  AMERICA_INDIANA_VINCENNES
  AMERICA_INDIANA_WINAMAC
  AMERICA_INDIANAPOLIS
  AMERICA_INUVIK
  AMERICA_IQALUIT
  AMERICA_JAMAICA
  AMERICA_JUJUY
  AMERICA_JUNEAU
  AMERICA_KENTUCKY_MONTICELLO
  AMERICA_KRALENDIJK
  AMERICA_LA_PAZ
  AMERICA_LIMA
  AMERICA_LOS_ANGELES
  AMERICA_LOUISVILLE
  AMERICA_LOWER_PRINCES
  AMERICA_MACEIO
  AMERICA_MANAGUA
  AMERICA_MANAUS
  AMERICA_MARIGOT
  AMERICA_MARTINIQUE
  AMERICA_MATAMOROS
  AMERICA_MAZATLAN
  AMERICA_MENDOZA
  AMERICA_MENOMINEE
  AMERICA_MERIDA
  AMERICA_METLAKATLA
  AMERICA_MEXICO_CITY
  AMERICA_MIQUELON
  AMERICA_MONCTON
  AMERICA_MONTERREY
  AMERICA_MONTEVIDEO
  AMERICA_MONTSERRAT
  AMERICA_NASSAU
  AMERICA_NEW_YORK
  AMERICA_NIPIGON
  AMERICA_NOME
  AMERICA_NORONHA
  AMERICA_NORTH_DAKOTA_BEULAH
  AMERICA_NORTH_DAKOTA_CENTER
  AMERICA_NORTH_DAKOTA_NEW_SALEM
  AMERICA_OJINAGA
  AMERICA_PANAMA
  AMERICA_PANGNIRTUNG
  AMERICA_PARAMARIBO
  AMERICA_PHOENIX
  AMERICA_PORT_AU_PRINCE
  AMERICA_PORT_OF_SPAIN
  AMERICA_PORTO_VELHO
  AMERICA_PUERTO_RICO
  AMERICA_PUNTA_ARENAS
  AMERICA_RAINY_RIVER
  AMERICA_RANKIN_INLET
  AMERICA_RECIFE
  AMERICA_REGINA
  AMERICA_RESOLUTE
  AMERICA_RIO_BRANCO
  AMERICA_SANTA_ISABEL
  AMERICA_SANTAREM
  AMERICA_SANTIAGO
  AMERICA_SANTO_DOMINGO
  AMERICA_SAO_PAULO
  AMERICA_SCORESBYSUND
  AMERICA_SITKA
  AMERICA_ST_BARTHELEMY
  AMERICA_ST_JOHNS
  AMERICA_ST_KITTS
  AMERICA_ST_LUCIA
  AMERICA_ST_THOMAS
  AMERICA_ST_VINCENT
  AMERICA_SWIFT_CURRENT
  AMERICA_TEGUCIGALPA
  AMERICA_THULE
  AMERICA_THUNDER_BAY
  AMERICA_TIJUANA
  AMERICA_TORONTO
  AMERICA_TORTOLA
  AMERICA_VANCOUVER
  AMERICA_WHITEHORSE
  AMERICA_WINNIPEG
  AMERICA_YAKUTAT
  AMERICA_YELLOWKNIFE
  ANTARCTICA_CASEY
  ANTARCTICA_DAVIS
  ANTARCTICA_DUMONT_D_URVILLE
  ANTARCTICA_MACQUARIE
  ANTARCTICA_MAWSON
  ANTARCTICA_MC_MURDO
  ANTARCTICA_PALMER
  ANTARCTICA_ROTHERA
  ANTARCTICA_SYOWA
  ANTARCTICA_TROLL
  ANTARCTICA_VOSTOK
  ARCTIC_LONGYEARBYEN
  ASIA_ADEN
  ASIA_ALMATY
  ASIA_AMMAN
  ASIA_ANADYR
  ASIA_AQTAU
  ASIA_AQTOBE
  ASIA_ASHGABAT
  ASIA_ATYRAU
  ASIA_BAGHDAD
  ASIA_BAHRAIN
  ASIA_BAKU
  ASIA_BANGKOK
  ASIA_BARNAUL
  ASIA_BEIRUT
  ASIA_BISHKEK
  ASIA_BRUNEI
  ASIA_CALCUTTA
  ASIA_CHITA
  ASIA_CHOIBALSAN
  ASIA_COLOMBO
  ASIA_DAMASCUS
  ASIA_DHAKA
  ASIA_DILI
  ASIA_DUBAI
  ASIA_DUSHANBE
  ASIA_FAMAGUSTA
  ASIA_GAZA
  ASIA_HEBRON
  ASIA_HONG_KONG
  ASIA_HOVD
  ASIA_IRKUTSK
  ASIA_JAKARTA
  ASIA_JAYAPURA
  ASIA_JERUSALEM
  ASIA_KABUL
  ASIA_KAMCHATKA
  ASIA_KARACHI
  ASIA_KATMANDU
  ASIA_KHANDYGA
  ASIA_KRASNOYARSK
  ASIA_KUALA_LUMPUR
  ASIA_KUCHING
  ASIA_KUWAIT
  ASIA_MACAU
  ASIA_MAGADAN
  ASIA_MAKASSAR
  ASIA_MANILA
  ASIA_MUSCAT
  ASIA_NICOSIA
  ASIA_NOVOKUZNETSK
  ASIA_NOVOSIBIRSK
  ASIA_OMSK
  ASIA_ORAL
  ASIA_PHNOM_PENH
  ASIA_PONTIANAK
  ASIA_PYONGYANG
  ASIA_QATAR
  ASIA_QOSTANAY
  ASIA_QYZYLORDA
  ASIA_RANGOON
  ASIA_RIYADH
  ASIA_SAIGON
  ASIA_SAKHALIN
  ASIA_SAMARKAND
  ASIA_SEOUL
  ASIA_SHANGHAI
  ASIA_SINGAPORE
  ASIA_SREDNEKOLYMSK
  ASIA_TAIPEI
  ASIA_TASHKENT
  ASIA_TBILISI
  ASIA_TEHRAN
  ASIA_THIMPHU
  ASIA_TOKYO
  ASIA_TOMSK
  ASIA_ULAANBAATAR
  ASIA_URUMQI
  ASIA_UST_NERA
  ASIA_VIENTIANE
  ASIA_VLADIVOSTOK
  ASIA_YAKUTSK
  ASIA_YEKATERINBURG
  ASIA_YEREVAN
  ATLANTIC_AZORES
  ATLANTIC_BERMUDA
  ATLANTIC_CANARY
  ATLANTIC_CAPE_VERDE
  ATLANTIC_FAEROE
  ATLANTIC_MADEIRA
  ATLANTIC_REYKJAVIK
  ATLANTIC_SOUTH_GEORGIA
  ATLANTIC_ST_HELENA
  ATLANTIC_STANLEY
  AUSTRALIA_ADELAIDE
  AUSTRALIA_BRISBANE
  AUSTRALIA_BROKEN_HILL
  AUSTRALIA_CURRIE
  AUSTRALIA_DARWIN
  AUSTRALIA_EUCLA
  AUSTRALIA_HOBART
  AUSTRALIA_LINDEMAN
  AUSTRALIA_LORD_HOWE
  AUSTRALIA_MELBOURNE
  AUSTRALIA_PERTH
  AUSTRALIA_SYDNEY
  EUROPE_AMSTERDAM
  EUROPE_ANDORRA
  EUROPE_ASTRAKHAN
  EUROPE_ATHENS
  EUROPE_BELGRADE
  EUROPE_BERLIN
  EUROPE_BRATISLAVA
  EUROPE_BRUSSELS
  EUROPE_BUCHAREST
  EUROPE_BUDAPEST
  EUROPE_BUSINGEN
  EUROPE_CHISINAU
  EUROPE_COPENHAGEN
  EUROPE_DUBLIN
  EUROPE_GIBRALTAR
  EUROPE_GUERNSEY
  EUROPE_HELSINKI
  EUROPE_ISLE_OF_MAN
  EUROPE_ISTANBUL
  EUROPE_JERSEY
  EUROPE_KALININGRAD
  EUROPE_KIEV
  EUROPE_KIROV
  EUROPE_LISBON
  EUROPE_LJUBLJANA
  EUROPE_LONDON
  EUROPE_LUXEMBOURG
  EUROPE_MADRID
  EUROPE_MALTA
  EUROPE_MARIEHAMN
  EUROPE_MINSK
  EUROPE_MONACO
  EUROPE_MOSCOW
  EUROPE_OSLO
  EUROPE_PARIS
  EUROPE_PODGORICA
  EUROPE_PRAGUE
  EUROPE_RIGA
  EUROPE_ROME
  EUROPE_SAMARA
  EUROPE_SAN_MARINO
  EUROPE_SARAJEVO
  EUROPE_SARATOV
  EUROPE_SIMFEROPOL
  EUROPE_SKOPJE
  EUROPE_SOFIA
  EUROPE_STOCKHOLM
  EUROPE_TALLINN
  EUROPE_TIRANE
  EUROPE_ULYANOVSK
  EUROPE_UZHGOROD
  EUROPE_VADUZ
  EUROPE_VATICAN
  EUROPE_VIENNA
  EUROPE_VILNIUS
  EUROPE_VOLGOGRAD
  EUROPE_WARSAW
  EUROPE_ZAGREB
  EUROPE_ZAPOROZHYE
  EUROPE_ZURICH
  INDIAN_ANTANANARIVO
  INDIAN_CHAGOS
  INDIAN_CHRISTMAS
  INDIAN_COCOS
  INDIAN_COMORO
  INDIAN_KERGUELEN
  INDIAN_MAHE
  INDIAN_MALDIVES
  INDIAN_MAURITIUS
  INDIAN_MAYOTTE
  INDIAN_REUNION
  PACIFIC_APIA
  PACIFIC_AUCKLAND
  PACIFIC_BOUGAINVILLE
  PACIFIC_CHATHAM
  PACIFIC_EASTER
  PACIFIC_EFATE
  PACIFIC_ENDERBURY
  PACIFIC_FAKAOFO
  PACIFIC_FIJI
  PACIFIC_FUNAFUTI
  PACIFIC_GALAPAGOS
  PACIFIC_GAMBIER
  PACIFIC_GUADALCANAL
  PACIFIC_GUAM
  PACIFIC_HONOLULU
  PACIFIC_JOHNSTON
  PACIFIC_KIRITIMATI
  PACIFIC_KOSRAE
  PACIFIC_KWAJALEIN
  PACIFIC_MAJURO
  PACIFIC_MARQUESAS
  PACIFIC_MIDWAY
  PACIFIC_NAURU
  PACIFIC_NIUE
  PACIFIC_NORFOLK
  PACIFIC_NOUMEA
  PACIFIC_PAGO_PAGO
  PACIFIC_PALAU
  PACIFIC_PITCAIRN
  PACIFIC_PONAPE
  PACIFIC_PORT_MORESBY
  PACIFIC_RAROTONGA
  PACIFIC_SAIPAN
  PACIFIC_TAHITI
  PACIFIC_TARAWA
  PACIFIC_TONGATAPU
  PACIFIC_TRUK
  PACIFIC_WAKE
  PACIFIC_WALLIS
}

scalar EvmAddress

"""The challenge has expired or was not found."""
type ExpiredChallengeError {
  reason: String!
}

"""
The transaction has failed to be mined or indexed.

The reason for the failure is provided.
"""
type FailedTransactionStatus {
  reason: String!
  blockTimestamp: DateTime!
  summary: [SubOperationStatus!]!
}

input FeeFollowRuleInput {
  amount: AmountInput!
}

type Feed {
  address: EvmAddress!
  createdAt: DateTime!
  metadata: FeedMetadata
  owner: EvmAddress!
  operations: LoggedInFeedPostOperations
  rules(request: RuleInput): FeedRulesConfig!
}

type FeedMetadata {
  """Optional markdown formatted description of the Feed."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """The name of the Feed."""
  name: String!

  """The human-friendly title for the Feed."""
  title: String!
}

input FeedOneOf @oneOf {
  globalFeed: Boolean
  feed: EvmAddress
  app: EvmAddress
}

input FeedRequest {
  """The feed"""
  feed: EvmAddress

  """The transaction hash you created the feed with."""
  txHash: TxHash
}

union FeedRule = TokenGatedFeedRule | GroupGatedFeedRule | RestrictedSignersFeedRule | SimplePaymentFeedRule | UserBlockingRule | UnknownFeedRule

type FeedRulesConfig {
  required: [FeedRule!]!
  anyOf: [FeedRule!]!
}

input FeedRulesInput {
  unknownFeedRule: UnknownFeedRuleInput
}

input FeedsFilter {
  """The optional filter to get feeds managed by address"""
  managedBy: ManagedBy

  """
  The optional filter to narrow feeds by search query.
  Uses fuzzy search on feed name
  """
  searchQuery: String
}

enum FeedsOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
  ALPHABETICAL
}

input FeedsRequest {
  filter: FeedsFilter

  """The order by."""
  orderBy: FeedsOrderBy! = LATEST_FIRST

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

"""
The transaction has been mined and indexed correctly.

If the transaction involves any metadata, the metadata has been snapshotted and indexed.
"""
type FinishedTransactionStatus {
  blockTimestamp: DateTime!
  summary: [SubOperationStatus!]!
}

type FollowNotification {
  id: GeneratedNotificationId!
  followers: [NotificationAccountFollow!]!
}

input FollowPair {
  """The graph you are checking defaults to global graph."""
  graph: EvmAddress! = "0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"

  """The follower."""
  follower: EvmAddress!

  """The account being followed."""
  account: EvmAddress!
}

type FollowResponse {
  hash: TxHash!
}

union FollowResult = FollowResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

union FollowRule = TokenGatedFollowRule | SimplePaymentFollowRule | UnknownFollowRule

type FollowRulesConfig {
  required: [FollowRule!]!
  anyOf: [FollowRule!]!
}

input FollowRulesInput {
  feeFollowRule: FeeFollowRuleInput
  unknownFollowRule: UnknownFollowRuleInput
}

input FollowStatusRequest {
  pairs: [FollowPair!]!
}

type FollowStatusResult {
  graph: EvmAddress!
  follower: EvmAddress!
  account: EvmAddress!
  isFollowing: BooleanValue!
}

type Follower {
  """The account which is following"""
  follower: Account!

  """The graph the follower is following on"""
  graph: EvmAddress!

  """The timestamp when the follower was followed"""
  followedOn: DateTime!
}

type FollowerOnlyPostRule {
  rule: EvmAddress!
  graph: EvmAddress!
  repliesRestricted: Boolean!
  repostsRestricted: Boolean!
  quotesRestricted: Boolean!
}

input FollowersFilter {
  """
  The graphs to filter by.
  The result will come back if they follow on ANY of the supplied graphs
  """
  graphs: [GraphOneOf!]
}

enum FollowersOrderBy {
  DESC
  ASC
  ACCOUNT_SCORE
}

input FollowersRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account to get followers for."""
  account: EvmAddress!

  """An optional filter to apply to the result."""
  filter: FollowersFilter

  """The order by."""
  orderBy: FollowersOrderBy! = DESC
}

input FollowersYouKnowFilter {
  """
  The graphs to get followers you know for
  The result will come back if they follow on ANY of the supplied graphs
  """
  graphs: [GraphOneOf!]
}

enum FollowersYouKnowOrderBy {
  DESC
  ASC
}

input FollowersYouKnowRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account to check followers you know."""
  target: EvmAddress!

  """The account you are looking from."""
  observer: EvmAddress!

  """An optional filter to apply to the result."""
  filter: FollowersYouKnowFilter

  """The order by."""
  orderBy: FollowersYouKnowOrderBy! = DESC
}

type Following {
  """The account which is following"""
  following: Account!

  """The graph the account is following on"""
  graph: EvmAddress!

  """The timestamp when the following happened"""
  followedOn: DateTime!
}

input FollowingFilter {
  """
  The graphs to filter by.
  The result will come back if they are following on ANY of the supplied graphs
  """
  graphs: [GraphOneOf!]
}

enum FollowingOrderBy {
  DESC
  ASC
  ACCOUNT_SCORE
}

input FollowingRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account to get following for."""
  account: EvmAddress!

  """An optional filter to apply to the result."""
  filter: FollowingFilter

  """The order by."""
  orderBy: FollowingOrderBy! = DESC
}

enum ForYouSource {
  FOLLOWING
  CURATED
  POPULAR
}

type ForbiddenError {
  reason: String!
}

input GenerateNewAppServerApiKeyRequest {
  """The app to generate the new server side api key for"""
  app: EvmAddress!
}

scalar GeneratedNotificationId

scalar GeoUri

input GetSnsSubscriptionsRequest {
  """
  The app to get subscriptions for. If not provided, all subscriptions owned by the logged in
  account will be returned.
  """
  app: EvmAddress
}

type Graph {
  address: EvmAddress!
  createdAt: DateTime!
  metadata: GraphMetadata
  owner: EvmAddress!
  rules(request: RuleInput): GraphRulesConfig!
}

type GraphMetadata {
  """Optional markdown formatted description of the graph."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """The name of the graph."""
  name: String!

  """The human-friendly title for the graph."""
  title: String!
}

input GraphOneOf @oneOf {
  globalGraph: Boolean
  graph: EvmAddress
  app: EvmAddress
}

input GraphRequest {
  """The graph"""
  graph: EvmAddress

  """The transaction hash you created the graph with."""
  txHash: TxHash
}

union GraphRule = TokenGatedGraphRule | RestrictedSignerGraphRule | UserBlockingRule | UnknownGraphRule

type GraphRulesConfig {
  required: [GraphRule!]!
  anyOf: [GraphRule!]!
}

input GraphRulesInput {
  unknownGraphRule: UnknownGraphRuleInput
}

input GraphsFilter {
  """The optional filter to get graphs managed by address"""
  managedBy: ManagedBy

  """
  The optional filter to narrow graphs by search query.
  Uses fuzzy search on graph name
  """
  searchQuery: String
}

enum GraphsOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
  ALPHABETICAL
}

input GraphsRequest {
  filter: GraphsFilter

  """The order by."""
  orderBy: GraphsOrderBy! = LATEST_FIRST
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type Group {
  address: EvmAddress!
  timestamp: DateTime!
  metadata: GroupMetadata
  owner: EvmAddress!
  operations: LoggedInGroupOperations
  rules(request: RuleInput): GroupRulesConfig!
}

type GroupGatedFeedRule {
  rule: EvmAddress!
  group: Group!
}

type GroupMember {
  account: Account!
  lastActiveAt: DateTime!
  joinedAt: DateTime!
}

input GroupMembersFilter {
  """The optional filter to narrow members by search query."""
  searchBy: UsernameSearchInput
}

enum GroupMembersOrderBy {
  LAST_JOINED
  FIRST_JOINED
  LAST_ACTIVE
  ACCOUNT_SCORE
}

input GroupMembersRequest {
  """The group"""
  group: EvmAddress!
  filter: GroupMembersFilter

  """The order by."""
  orderBy: GroupMembersOrderBy! = ACCOUNT_SCORE

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type GroupMention {
  """The group that was mentioned"""
  group: EvmAddress!

  """
  The replacement information.
  Use to replace mentions in the post content.
  """
  replace: MentionReplace!
}

type GroupMetadata {
  """Optional markdown formatted description of the Community."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """Optional uri of the Community's icon."""
  icon: URI

  """The name of the Community."""
  name: String!

  """The Group cover picture."""
  coverPicture: URI
}

input GroupRequest {
  """The group"""
  group: EvmAddress

  """The transaction hash you created the group with."""
  txHash: TxHash
}

union GroupRule = TokenGatedGroupRule | SimplePaymentGroupRule | ApprovalGroupRule | UnknownGroupRule

type GroupRulesConfig {
  required: [GroupRule!]!
  anyOf: [GroupRule!]!
}

input GroupStatsRequest {
  """The group address to check its total members."""
  group: EvmAddress!
}

type GroupStatsResponse {
  totalMembers: Int!
}

input GroupsFilter {
  """The optional filter to get groups where account is a member"""
  member: EvmAddress

  """The optional filter to get groups managed by address"""
  managedBy: ManagedBy

  """
  The optional filter to narrow groups by search query.
  Uses fuzzy search on group name
  """
  searchQuery: String
}

enum GroupsOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
  ALPHABETICAL
}

input GroupsRequest {
  filter: GroupsFilter

  """The order by."""
  orderBy: GroupsOrderBy! = LATEST_FIRST

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input HasReactedRequest {
  type: PostReactionType
}

input HideManagedAccountRequest {
  """The account to hide."""
  account: EvmAddress!
}

input HideReplyRequest {
  post: PostId!
}

scalar IdToken

type ImageMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  image: MediaImage!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional image title."""
  title: String
  content: String!
}

enum IndexingStatus {
  FINISHED
  PENDING
  FAILED
}

type InvalidUsername {
  reason: String!
}

input IsFollowedByMeRequest {
  graph: EvmAddress!
}

input IsFollowingMeRequest {
  graph: EvmAddress!
}

"""A scalar that can represent any JSON value."""
scalar JSON

input JoinGroupRequest {
  """The group you want to join"""
  group: EvmAddress!
}

type JoinGroupResponse {
  hash: TxHash!
}

union JoinGroupResult = JoinGroupResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type KeyValue {
  key: String!
  value: String!
}

type KnownAction {
  name: String!
  contract: NetworkAddress!
  setupInput: [ActionInputInfo!]!
  actionInput: [ActionInputInfo!]!
  returnSetupInput: [ActionInputInfo!]!
}

input LastLoggedInAccountRequest {
  """The address to get the last logged in account for."""
  address: EvmAddress!

  """The app to get the last logged in account for."""
  app: EvmAddress
}

input LeaveGroupRequest {
  """The group you want to leave"""
  group: EvmAddress!
}

type LeaveGroupResponse {
  hash: TxHash!
}

union LeaveGroupResult = LeaveGroupResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar LegacyProfileId

scalar LegacyRefreshToken

type LengthUsernameNamespaceRule {
  rule: EvmAddress!
  minLength: Int!
  maxLength: Int!
}

type LinkMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """The sharing link url."""
  sharingLink: URI!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: String!
}

type LivestreamMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """
  The data cannot be changed so you can put in an API endpoint to know if it is still live or
  not for clients to be able to check.
  """
  checkLiveApi: URI

  """Specify a content warning."""
  contentWarning: ContentWarning

  """The optional stream end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)"""
  endsAt: DateTime
  id: MetadataId!

  """
  Some livestream platforms have the live url as a separate url. If not your case make sure
  `liveUrl` and `playbackUrl` are the same.
  """
  liveUrl: URI!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """
  Some livestream platforms have the playback url as a separate url. If not your case make
  sure `liveUrl` and `playbackUrl` are the same.
  """
  playbackUrl: URI!

  """The stream start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: DateTime!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The livestream title."""
  title: String
  content: String!
}

scalar Locale

type LoggedInAccountOperations {
  id: ID!

  """
  Check if the target account is followed by the authenticated account.
  
  If a graph is not specified it defaults to using the Global Graph
  """
  isFollowedByMe(request: IsFollowedByMeRequest): Boolean!

  """
  Check if the authenticated account is following the target account.
  
  If a graph is not specified it defaults to using the Global Graph
  """
  isFollowingMe(request: IsFollowingMeRequest): Boolean!

  """
  Check if the authenticated account can follow the target account.
  
  If a graph is not specified it defaults to using the Global Graph
  """
  canFollow(request: CanFollowRequest): OperationValidationOutcome!

  """
  Check if the authenticated account can unfollow the target account.
  
  If a graph is not specified it defaults to using the Global Graph
  """
  canUnfollow(request: CanUnfollowRequest): OperationValidationOutcome!
  isMutedByMe: Boolean!
  isBlockedByMe: Boolean!
  hasBlockedMe: Boolean!
  canBlock: Boolean!
  canUnblock: Boolean!
  hasReported: Boolean!
}

type LoggedInFeedPostOperations {
  canPost: OperationValidationOutcome!
}

type LoggedInGroupOperations {
  canJoin: OperationValidationOutcome!
  canLeave: OperationValidationOutcome!
  canAddMember: OperationValidationOutcome!
  canRemoveMember: OperationValidationOutcome!
  isMember: Boolean!
}

type LoggedInPostOperations {
  id: ID!
  isNotInterested: Boolean!
  hasBookmarked: Boolean!
  hasReported: Boolean!
  hasReacted(request: HasReactedRequest): Boolean!
  canComment: OperationValidationOutcome!
  canQuote: OperationValidationOutcome!
  canRepost: OperationValidationOutcome!
  hasCommented: BooleanValue!
  hasQuoted: BooleanValue!
  hasReposted: BooleanValue!
  canEdit: OperationValidationOutcome!
  canDelete: OperationValidationOutcome!
}

type LoggedInUsernameNamespaceOperations {
  canMint: OperationValidationOutcome!
}

type LoggedInUsernameOperations {
  canRemove: OperationValidationOutcome!
  canAssign: OperationValidationOutcome!
  canUnassign: OperationValidationOutcome!
}

enum MainContentFocus {
  ARTICLE
  AUDIO
  CHECKING_IN
  EMBED
  EVENT
  IMAGE
  LINK
  LIVESTREAM
  MINT
  SHORT_VIDEO
  SPACE
  STORY
  TEXT_ONLY
  THREE_D
  TRANSACTION
  VIDEO
}

enum ManagedAccountsVisibility {
  NONE_HIDDEN
  HIDDEN_ONLY
  ALL
}

input ManagedBy {
  """The address that is either the owner or an admin of the primitive."""
  address: EvmAddress!

  """
  Whether to include the owned primitives or just the ones the address is an admin of.
  """
  includeOwners: Boolean! = true
}

type MeResult {
  """The logged in account."""
  loggedInAs: AccountAvailable!

  """Whether the account is signless."""
  isSignless: Boolean!

  """Whether the account is sponsored."""
  isSponsored: Boolean!

  """The app the account is logged in to."""
  appLoggedIn: EvmAddress!

  """The sponsorship allowance for the account."""
  limit: SponsorshipAllowance!
}

"""MediaAudio"""
type MediaAudio {
  """The name of the artist."""
  artist: String

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  cover: URI

  """The credits for the audio."""
  credits: String

  """How long the the audio is in seconds."""
  duration: Int

  """The genre of the audio"""
  genre: String
  item: URI!

  """The type of audio."""
  kind: MediaAudioKind

  """The license for the audio."""
  license: MetadataLicenseType
  lyrics: URI

  """The record label for the audio."""
  recordLabel: String

  """The mime type of the audio file."""
  type: MediaAudioType!
}

enum MediaAudioKind {
  MUSIC
  PODCAST
  AUDIOBOOK
  VOICE_NOTE
  SOUND
  OTHER
}

"""The mime type of the audio file."""
enum MediaAudioType {
  AUDIO_WAV
  AUDIO_VND_WAVE
  AUDIO_MPEG
  AUDIO_OGG
  AUDIO_MP_4
  AUDIO_AAC
  AUDIO_WEBM
  AUDIO_FLAC
}

"""
MediaImage

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"altTag": {
"description": "The alt tag for accessibility",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"license": {
"description": "The license for the image",
"$ref": "#/$defs/MetadataLicenseType"
},
"type": {
"description": "The mime type of the image",
"type": "string",
"enum": [
"image/bmp",
"image/gif",
"image/heic",
"image/jpeg",
"image/png",
"image/svg+xml",
"image/tiff",
"image/webp",
"image/x-ms-bmp"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaImage {
  """The alt tag for accessibility"""
  altTag: String

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  item: URI!

  """The license for the image"""
  license: MetadataLicenseType

  """The mime type of the image"""
  type: MediaImageType!
}

"""
The mime type of the image

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the image",
"type": "string",
"enum": [
"image/bmp",
"image/gif",
"image/heic",
"image/jpeg",
"image/png",
"image/svg+xml",
"image/tiff",
"image/webp",
"image/x-ms-bmp"
]
}
```
</details>
"""
enum MediaImageType {
  BMP
  GIF
  HEIC
  JPEG
  PNG
  SVG_XML
  TIFF
  WEBP
  X_MS_BMP
}

input MediaSnapshotNotificationAttributes {
  source: EntityId
}

"""
MediaVideo

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"altTag": {
"description": "The alt tag for accessibility",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"cover": {
"$ref": "#/$defs/EncryptableUri"
},
"duration": {
"description": "How long the the video is in seconds",
"type": "integer",
"exclusiveMinimum": 0.0
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"license": {
"description": "The license for the video",
"$ref": "#/$defs/MetadataLicenseType"
},
"type": {
"description": "The mime type of the video",
"type": "string",
"enum": [
"model/gltf+json",
"model/gltf-binary",
"video/x-m4v",
"video/mov",
"video/mp4",
"video/mpeg",
"video/ogg",
"video/ogv",
"video/quicktime",
"video/webm"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaVideo {
  """The alt tag for accessibility"""
  altTag: String

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  cover: URI

  """How long the the video is in seconds"""
  duration: Int
  item: URI!

  """The license for the video"""
  license: MetadataLicenseType

  """The mime type of the video"""
  type: MediaVideoType!
}

"""
The mime type of the video

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the video",
"type": "string",
"enum": [
"model/gltf+json",
"model/gltf-binary",
"video/x-m4v",
"video/mov",
"video/mp4",
"video/mpeg",
"video/ogg",
"video/ogv",
"video/quicktime",
"video/webm"
]
}
```
</details>
"""
enum MediaVideoType {
  MODEL_GLTF_JSON
  MODEL_GLTF_BINARY
  VIDEO_XM_4V
  VIDEO_MOV
  VIDEO_MP_4
  VIDEO_MPEG
  VIDEO_OGG
  VIDEO_OGV
  VIDEO_QUICKTIME
  VIDEO_WEBM
}

type MentionNotification {
  id: GeneratedNotificationId!
  post: Post!
}

type MentionReplace {
  from: String!
  to: String!
}

type MetadataAttribute {
  type: MetadataAttributeType!
  key: String!
  value: String!
}

enum MetadataAttributeType {
  BOOLEAN
  DATE
  NUMBER
  STRING
  JSON
}

scalar MetadataId

enum MetadataLicenseType {
  CCO
  CC_BY
  CC_BY_ND
  CC_BY_NC
  TBNL_CD_PL_LEGAL
  TBNL_C_DT_PL_LEGAL
  TBNL_C_ND_PL_LEGAL
  TBNL_CD_NPL_LEGAL
  TBNL_C_DT_NPL_LEGAL
  TBNL_C_DTSA_PL_LEGAL
  TBNL_C_DTSA_NPL_LEGAL
  TBNL_C_ND_NPL_LEGAL
  TBNL_CD_PL_LEDGER
  TBNL_C_DT_PL_LEDGER
  TBNL_C_ND_PL_LEDGER
  TBNL_CD_NPL_LEDGER
  TBNL_C_DT_NPL_LEDGER
  TBNL_C_DTSA_PL_LEDGER
  TBNL_C_DTSA_NPL_LEDGER
  TBNL_C_ND_NPL_LEDGER
  TBNL_NC_D_PL_LEGAL
  TBNL_NC_DT_PL_LEGAL
  TBNL_NC_ND_PL_LEGAL
  TBNL_NC_D_NPL_LEGAL
  TBNL_NC_DT_NPL_LEGAL
  TBNL_NC_DTSA_PL_LEGAL
  TBNL_NC_DTSA_NPL_LEGAL
  TBNL_NC_ND_NPL_LEGAL
  TBNL_NC_D_PL_LEDGER
  TBNL_NC_DT_PL_LEDGER
  TBNL_NC_ND_PL_LEDGER
  TBNL_NC_D_NPL_LEDGER
  TBNL_NC_DT_NPL_LEDGER
  TBNL_NC_DTSA_PL_LEDGER
  TBNL_NC_DTSA_NPL_LEDGER
  TBNL_NC_ND_NPL_LEDGER
}

input MetadataSnapshotNotificationAttributes {
  source: EntityId
}

type MintMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """
  The mint item it can be a URL of the known provider like opensea https://opensea.io/assets/ethereum/0xfaa2471e93bd1cee3b0ab381c242ada8e1d1a759/299 or https://zora.co/collect/0x9d90669665607f08005cae4a7098143f554c59ef/39626. The Lens API has an allow list of providers and if the domain does not match it will mark it as failed metadata
  """
  mintLink: URI!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: String!
}

input MlaccountRecommendationsRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account to get recommendations for."""
  account: EvmAddress!

  """Shuffle the recommendations."""
  shuffle: Boolean! = false
}

input MlexplorePostsFilter {
  since: Int
}

input MlexplorePostsRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
  filter: MlexplorePostsFilter
}

input MlpostsForYouRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account to get for you for."""
  account: EvmAddress!

  """Shuffle the for you posts."""
  shuffle: Boolean! = false
}

type Mutation {
  """
  Create a new app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createApp(request: CreateAppRequest!): CreateAppResult!

  """
  Add an app authorization endpoint.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  addAppAuthorizationEndpoint(request: AddAppAuthorizationEndpointRequest!): Void!

  """
  Remove an app authorization endpoint.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  removeAppAuthorizationEndpoint(request: RemoveAppAuthorizationEndpointRequest!): Void!

  """
  Add feeds to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  addAppFeeds(request: AddAppFeedsRequest!): AddAppFeedsResult!

  """
  Add groups to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  addAppGroups(request: AddAppGroupsRequest!): AddAppGroupsResult!

  """
  Add signers to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  addAppSigners(request: AddAppSignersRequest!): AddAppSignersResult!

  """
  Remove feeds to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  removeAppFeeds(request: RemoveAppFeedsRequest!): RemoveAppFeedsResult!

  """
  Remove groups to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  removeAppGroups(request: RemoveAppGroupsRequest!): RemoveAppGroupsResult!

  """
  Remove signers to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  removeAppSigners(request: RemoveAppSignersRequest!): RemoveAppSignersResult!

  """
  Set graph for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppGraph(request: SetAppGraphRequest!): SetAppGraphResult!

  """
  Set default feed for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setDefaultAppFeed(request: SetDefaultAppFeedRequest!): SetDefaultAppFeedResult!

  """
  Set metadata for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppMetadata(request: SetAppMetadataRequest!): SetAppMetadataResult!

  """
  Set if the app verification is enabled
  App needs to have authorization endpoint enabled
  App needs to return `verification_endpoint` from the authorization endpoint
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppVerification(request: SetAppVerificationRequest!): SetAppVerificationResult!

  """
  Set sponsorship for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppSponsorship(request: SetAppSponsorshipRequest!): SetAppSponsorshipResult!

  """
  Set treasury for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppTreasury(request: SetAppTreasuryRequest!): SetAppTreasuryResult!

  """
  Set username namespace for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppUsernameNamespace(request: SetAppUsernameNamespaceRequest!): SetAppUsernameNamespaceResult!

  """
  Generate a new app server side api key
  
  You MUST be authenticated as a builder to use this mutation.
  """
  generateNewAppServerApiKey(request: GenerateNewAppServerApiKeyRequest!): ServerAPIKey!

  """
  Report an account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  reportAccount(request: ReportAccountRequest!): Void!

  """
  Hides an account from the manager list of managed accounts.
  
  You MUST be authenticated as Account Manager to use this mutation.
  """
  hideManagedAccount(request: HideManagedAccountRequest!): Void!

  """
  Undo the hiding of an account from the manager list of managed accounts.
  
  You MUST be authenticated as Account Manager to use this mutation.
  """
  unhideManagedAccount(request: UnhideManagedAccountRequest!): Void!

  """
  Set the metadata for the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  setAccountMetadata(request: SetAccountMetadataRequest!): SetAccountMetadataResult!

  """
  Block an account with the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  block(request: BlockRequest!): BlockResult!

  """
  Unblock an account with the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  unblock(request: UnblockRequest!): UnblockResult!

  """
  Recommend an account from the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  recommendAccount(request: RecommendAccount!): Void!

  """
  Undo recommended account from the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  undoRecommendedAccount(request: UndoRecommendedAccount!): Void!

  """
  Mute an account for the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  mute(request: MuteRequest!): Void!

  """
  Unmute an account for the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  unmute(request: MuteRequest!): Void!

  """
  Create an account with a given username.
  
  You MUST be authenticated as Onboarding User to use this mutation.
  """
  createAccountWithUsername(request: CreateAccountWithUsernameRequest!): CreateAccountWithUsernameResult!

  """
  Add an account manager to the authenticated account.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  addAccountManager(request: AddAccountManagerRequest!): AddAccountManagerResult!

  """
  Remove an account manager to the authenticated account.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  removeAccountManager(request: RemoveAccountManagerRequest!): RemoveAccountManagerResult!

  """
  Enables Signless experience for the authenticated account.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  enableSignless: EnableSignlessResult!

  """
  Remove Signless experience for the authenticated account.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  removeSignless: RemoveSignlessResult!

  """
  Update the Account Manager Permissions for a given Account Manager.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  updateAccountManager(request: UpdateAccountManagerRequest!): UpdateAccountManagerResult!

  """Authenticate the user with the signed authentication challenge."""
  authenticate(request: SignedAuthChallenge!): AuthenticationResult!

  """
  Generates a new authentication challenge for the specified address and app.
  
  Users must sign the challenge to authenticate.
  
  The issued challenge can be for authentication credentials for different roles:
  - AccountOwner: The `address` is a Lens Account, and the `signed_by` is the Account Owner.
  - AccountManager: The `address` is a Lens Account, and the `signed_by` is an Account Manager
  for it.
  - OnboardingUser: The `address` is an EOA that needs to create their Lens Account.
  - Builder: The `address` is the EOA of a Builder that needs to use configuration and
  management features.
  
  The HTTP Origin header MUST be present and match the app's domain.
  """
  challenge(request: ChallengeRequest!): AuthenticationChallenge!

  """
  Revoke an authentication.
  
  You MUST be authenticated to use this mutation.
  """
  revokeAuthentication(request: RevokeAuthenticationRequest!): Void!

  """
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  switchAccount(request: SwitchAccountRequest!): SwitchAccountResult!

  """Refreshes the authentication tokens."""
  refresh(request: RefreshRequest!): RefreshResult!

  """
  Issue new authentication tokens from a valid Lens API v2 refresh token.
  
  Use this to seamlessly transition your users from Lens API v2 to Lens API v3 without
  requiring them to re-authenticate.
  
  The HTTP Origin header MUST be present and match the app's domain.
  """
  legacyRolloverRefresh(request: RolloverRefreshRequest!): RefreshResult!

  """
  Create a new post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  post(request: CreatePostRequest!): PostResult!

  """
  Repost a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  repost(request: CreateRepostRequest!): PostResult!

  """
  Delete a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  deletePost(request: DeletePostRequest!): DeletePostResult!

  """
  Edit a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  editPost(request: EditPostRequest!): PostResult!

  """
  Bookmark a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  bookmarkPost(request: BookmarkPostRequest!): Void!

  """
  Undo bookmark.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  undoBookmarkPost(request: BookmarkPostRequest!): Void!
  hideReply(request: HideReplyRequest!): Void!
  unhideReply(request: UnhideReplyRequest!): Void!

  """
  React to a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  addReaction(request: AddReactionRequest!): AddReactionResult!

  """
  Undo reaction to a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  undoReaction(request: UndoReactionRequest!): UndoReactionResult!

  """
  Report a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  reportPost(request: ReportPostRequest!): Void!

  """
  Follow an Account on the global Graph or a specific Graph.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  follow(request: CreateFollowRequest!): FollowResult!

  """
  Unfollow an Account on the global Graph or a specific Graph.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  unfollow(request: CreateUnfollowRequest!): UnfollowResult!

  """
  Create a new graph
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createGraph(request: CreateGraphRequest!): CreateGraphResult!

  """
  Set metadata for a graph
  
  You MUST be authenticated to use this mutation.
  """
  setGraphMetadata(request: SetGraphMetadataRequest!): SetGraphMetadataResult!

  """
  Create a new username namespace aka deploying a new username contract
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createUsernameNamespace(request: CreateUsernameNamespaceRequest!): CreateUsernameNamespaceResult!

  """
  Create a username.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  createUsername(request: CreateUsernameRequest!): CreateUsernameResult!

  """
  Assign a username to an account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  assignUsernameToAccount(request: AssignUsernameToAccountRequest!): AssignUsernameToAccountResult!

  """
  Unassign a username from the logged-in user's Account.
  
  Defaults to the Lens namespace if no request is provided.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  unassignUsernameFromAccount(request: UnassignUsernameFromAccountRequest!): UnassignUsernameToAccountResult!

  """
  Set metadata for a namespace
  
  You MUST be authenticated to use this mutation.
  """
  setNamespaceMetadata(request: SetNamespaceMetadataRequest!): SetNamespaceMetadataResult!

  """
  Add admins to a graph/app/sponsor/feed/username/group.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  addAdmins(request: AddAdminsRequest!): AddAdminsResult!

  """
  Remove admins from a graph/app/sponsor/feed/username/group.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  removeAdmins(request: RemoveAdminsRequest!): RemoveAdminsResult!

  """
  Transfer primitive ownership for the graph/app/sponsor/feed/username/group.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  transferPrimitiveOwnership(request: TransferPrimitiveOwnershipRequest!): TransferPrimitiveOwnershipResult!

  """
  Create a new feed
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createFeed(request: CreateFeedRequest!): CreateFeedResult!

  """
  Set metadata for a feed
  
  You MUST be authenticated to use this mutation.
  """
  setFeedMetadata(request: SetFeedMetadataRequest!): SetFeedMetadataResult!

  """
  Create a new group
  
  You MUST be authenticated to use this mutation.
  """
  createGroup(request: CreateGroupRequest!): CreateGroupResult!

  """
  Join a group
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  joinGroup(request: JoinGroupRequest!): JoinGroupResult!

  """
  Leave a group
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  leaveGroup(request: LeaveGroupRequest!): LeaveGroupResult!

  """
  Set metadata for a group
  
  You MUST be authenticated to use this mutation.
  """
  setGroupMetadata(request: SetGroupMetadataRequest!): SetGroupMetadataResult!
  createSnsSubscriptions(request: CreateSnsSubscriptionRequest!): [SnsSubscription!]!
  deleteSnsSubscription(request: DeleteSnsSubscriptionRequest!): Void!

  """
  Create a new sponsorship.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createSponsorship(request: CreateSponsorshipRequest!): CreateSponsorshipResult!

  """
  Set metadata for a sponsorship
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setSponsorshipMetadata(request: SetSponsorshipMetadataRequest!): SetSponsorshipMetadataResult!

  """
  Update a sponsorship rate limits.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  updateSponsorshipLimits(request: UpdateSponsorshipLimitsRequest!): UpdateSponsorshipLimitsResult!

  """
  Update a sponsorship exclusion list from the rate limits.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  updateSponsorshipExclusionList(request: UpdateSponsorshipExclusionListRequest!): UpdateSponsorshipExclusionListResult!

  """
  Update a sponsorship signers list.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  updateSponsorshipSigners(request: UpdateSponsorshipSignersRequest!): UpdateSponsorshipSignersResult!
}

input MuteRequest {
  """The account to mute."""
  account: EvmAddress!
}

input NamespaceRequest {
  """The namespace"""
  namespace: EvmAddress

  """The transaction hash you created the namespace with."""
  txHash: TxHash
}

input NamespacesFilter {
  """The optional filter to get namespaces managed by address"""
  managedBy: ManagedBy

  """
  The optional filter to narrow namespaces by search query.
  Uses fuzzy search on namespace name
  """
  searchQuery: String
}

enum NamespacesOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
  ALPHABETICAL
}

input NamespacesRequest {
  filter: NamespacesFilter

  """The order by."""
  orderBy: NamespacesOrderBy! = LATEST_FIRST

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type NamespacesResult {
  items: [UsernameNamespace!]!
  pageInfo: PaginatedResultInfo!
}

type NetworkAddress {
  address: EvmAddress!
  chainId: Int!
}

"""The existence of the transaction is not yet indexed. Keep trying."""
type NotIndexedYetStatus {
  reason: String!

  """True if the transaction has been mined."""
  txHasMined: Boolean!
}

union Notification = ReactionNotification | CommentNotification | RepostNotification | QuoteNotification | FollowNotification | MentionNotification

type NotificationAccountFollow {
  followedAt: DateTime!
  account: Account!
}

type NotificationAccountPostReaction {
  account: Account!
  reactions: [PostReaction!]!
}

type NotificationAccountRepost {
  repostId: PostId!
  repostedAt: DateTime!
  account: Account!
}

input NotificationFilter {
  """The feeds to filter by."""
  feeds: [FeedOneOf!]

  """The graphs to filter by."""
  graphs: [GraphOneOf!]

  """The apps to filter by."""
  apps: [EvmAddress!]

  """The notification types to filter by."""
  notificationTypes: [NotificationType!]

  """Include notification from accounts with low score"""
  includeLowScore: Boolean! = false

  """Aggregate notifications by time"""
  timeBasedAggregation: Boolean! = true
}

enum NotificationOrderBy {
  DEFAULT
  ACCOUNT_SCORE
}

input NotificationRequest {
  """An optional filter to narrow down the notifications result."""
  filter: NotificationFilter

  """An optional order to sort the notifications result."""
  orderBy: NotificationOrderBy! = DEFAULT
  cursor: Cursor
}

enum NotificationType {
  REPOSTED
  QUOTED
  COMMENTED
  FOLLOWED
  MENTIONED
  REACTED
}

input OnboardingUserChallengeRequest {
  """
  The App you intend to authenticate with.
  
  It MUST be a valid App address.
  Note: On the testnet, it will default to `0x90C8C68D0ABFB40D4FCD72316A65E42161520BC3`, the
  playground app. This is to make it easier if you forget to set it. This may change in the
  future.
  """
  app: EvmAddress! = "0xe5439696f4057aF073c0FB2dc6e5e755392922e1"

  """The address of the EOA that needs to create their Lens Account."""
  wallet: EvmAddress!
}

type OperationValidationFailed {
  unsatisfiedRules: [UnsatisfiedRule!]
  reason: String!
}

union OperationValidationOutcome = OperationValidationPassed | OperationValidationFailed

type OperationValidationPassed {
  restrictedSignerRequired: Boolean!
  extraChecksRequired: [UnknownRule!]!
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedAccountManagersResult {
  """The account managers."""
  items: [AccountManager!]!

  """The pagination information for the given request."""
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsAvailableResult {
  """The accounts available to use for the given address"""
  items: [AccountAvailable!]!

  """The pagination information for the given request."""
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsBlockedResult {
  items: [AccountBlocked!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsResult {
  items: [Account!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedActions {
  items: [ActionInfo!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedActiveAuthenticationsResult {
  items: [AuthenticatedSession!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAdminsResult {
  items: [Admin!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAnyPostsResult {
  items: [AnyPost!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppFeedsResult {
  """The feeds"""
  items: [AppFeed!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppSignersResult {
  """The signers"""
  items: [AppSigner!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppUsersResult {
  items: [AppUser!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFeedsResult {
  items: [Feed!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFollowersResult {
  items: [Follower!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFollowingResult {
  items: [Following!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedGraphsResult {
  items: [Graph!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedGroupMembersResult {
  items: [GroupMember!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedGroupsResult {
  """The groups"""
  items: [Group!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedNotificationResult {
  items: [Notification!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostEditsResult {
  items: [PostEdit!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostReactionsResult {
  items: [AccountPostReaction!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostTagsResult {
  items: [PostTag!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostsForYouResult {
  items: [PostForYou!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostsResult {
  items: [Post!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedResultInfo {
  """The cursor to the previous page of results, if any."""
  prev: Cursor

  """The cursor to the next page of results, if any."""
  next: Cursor
}

type PaginatedTimelineResult {
  items: [TimelineItem!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUsernamesResult {
  items: [Username!]!
  pageInfo: PaginatedResultInfo!
}

type PaymasterParams {
  """The address of the paymaster."""
  paymaster: EvmAddress!

  """The bytestream input for the paymaster."""
  paymasterInput: BlockchainData!
}

"""
The existence of the transaction is known, but its status is not yet known.

The transaction could be:
- waiting to be included in a block
- waiting for a block to be mined
- waiting to be indexed by the Lens Indexer
- waiting for any associated metadata to be snapshotted and indexed
"""
type PendingTransactionStatus {
  blockTimestamp: DateTime!
  summary: [SubOperationStatus!]!
}

"""PhysicalAddress"""
type PhysicalAddress {
  """The country name component."""
  country: String!

  """The full mailing address formatted for display."""
  formatted: String

  """The city or locality."""
  locality: String!

  """The zip or postal code."""
  postalCode: String

  """The state or region."""
  region: String

  """
  The street address including house number, street name, P.O. Box, apartment or unit number
  and extended multi-line address information.
  """
  streetAddress: String
}

type Post {
  id: PostId!
  slug: PostId!
  author: Account!
  isEdited: Boolean!
  isDeleted: Boolean!
  timestamp: DateTime!
  app: App
  metadata: PostMetadata!
  root: Post
  quoteOf: Post
  commentOn: Post
  actions: [PostAction!]!
  operations: LoggedInPostOperations
  stats: PostStats!
  mentions: [PostMention!]!
  feed: Feed!
  rules(request: RuleInput): PostRulesConfig!
}

input PostAccountPair {
  post: PostId!
  account: EvmAddress!
}

union PostAction = SimpleCollectActionSettings | UnknownActionSettings

enum PostActionCategoryType {
  COLLECT
}

input PostActionInput {
  collectAction: CollectActionInput!
  unknownAction: UnknownActionInput!
}

enum PostActionType {
  SIMPLE_COLLECT_ACTION
  UNKNOWN_ACTION
}

input PostActionsRequest {
  limit: Int
  cursor: Cursor
  includeUnknown: Boolean
  includeOnlyCollectActions: Boolean
  onlyVerified: Boolean
}

input PostBookmarksFilter {
  """The feeds to filter by."""
  feeds: [FeedOneOf!]
  metadata: PostMetadataFilter
}

input PostBookmarksRequest {
  filter: PostBookmarksFilter
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

input PostCreatedNotificationAttributes {
  author: EvmAddress
  parentPostId: PostId
  postTypes: [PostType!]
  feed: EvmAddress
  app: EvmAddress
}

input PostDeletedNotificationAttributes {
  author: EvmAddress
  parentPostId: PostId
  postTypes: [PostType!]
  feed: EvmAddress
  app: EvmAddress
}

type PostEdit {
  metadata: PostMetadata!
  timestamp: DateTime!
}

input PostEditedNotificationAttributes {
  author: EvmAddress
  parentPostId: PostId
  postTypes: [PostType!]
  feed: EvmAddress
  app: EvmAddress
}

input PostEditsRequest {
  """The post ID."""
  post: PostId!
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type PostForYou {
  post: Post!
  source: ForYouSource!
}

scalar PostId

union PostMention = AccountMention | GroupMention

union PostMetadata = ArticleMetadata | AudioMetadata | CheckingInMetadata | EmbedMetadata | EventMetadata | ImageMetadata | LinkMetadata | LivestreamMetadata | MintMetadata | SpaceMetadata | StoryMetadata | TextOnlyMetadata | ThreeDMetadata | TransactionMetadata | VideoMetadata

input PostMetadataContentWarningFilter {
  oneOf: [ContentWarning!]!
}

input PostMetadataFilter {
  """The main focus of the post."""
  mainContentFocus: [MainContentFocus!]

  """The tags to filter by."""
  tags: PostMetadataTagsFilter

  """The content warning to filter by."""
  contentWarning: PostMetadataContentWarningFilter
}

input PostMetadataTagsFilter {
  oneOf: [String!]
  all: [String!]
}

type PostReaction {
  reaction: PostReactionType!
  reactedAt: DateTime!
}

input PostReactionAddedNotificationAttributes {
  postId: PostId
  reactingAccount: EvmAddress
  reactionType: PostReactionType
  app: EvmAddress
}

enum PostReactionOrderBy {
  DEFAULT
  ACCOUNT_SCORE
}

input PostReactionRemovedNotificationAttributes {
  postId: PostId
  reactingAccount: EvmAddress
  reactionType: PostReactionType
  app: EvmAddress
}

type PostReactionStatus {
  postId: PostId!
  account: EvmAddress!
  result: Boolean!
}

input PostReactionStatusRequest {
  pairs: [PostAccountPair!]!
  filter: PostReactionsFilter
}

enum PostReactionType {
  UPVOTE
  DOWNVOTE
}

input PostReactionsFilter {
  """The types of reactions to filter by."""
  anyOf: [PostReactionType!]
}

input PostReactionsRequest {
  """The ID of the post to get reactions for."""
  post: PostId!

  """An optional filter to narrow down the result."""
  filter: PostReactionsFilter

  """The order in which to return the results."""
  orderBy: PostReactionOrderBy
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

enum PostReferenceType {
  COMMENT_ON
  REPOST_OF
  QUOTE_OF
}

input PostReferencesRequest {
  """The post to get references for."""
  referencedPost: PostId!

  """The types of references to get."""
  referenceTypes: [PostReferenceType!]!

  """
  The visibility filter to apply by default it will honour the visibility of the post.
  """
  visibilityFilter: PostVisibilityFilter! = VISIBLE

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

enum PostReportReason {
  ANIMAL_ABUSE
  HARASSMENT
  VIOLENCE
  SELF_HARM
  DIRECT_THREAT
  HATE_SPEECH
  NUDITY
  OFFENSIVE
  SCAM
  UNAUTHORIZED_SALE
  IMPERSONATION
  MISLEADING
  MISUSE_HASHTAGS
  UNRELATED
  REPETITIVE
  FAKE_ENGAGEMENT
  MANIPULATION_ALGO
  SOMETHING_ELSE
}

input PostReportedNotificationAttributes {
  author: EvmAddress
  reporter: EvmAddress
  feed: EvmAddress
  app: EvmAddress
}

"""You must provide either a txHash or a postId, not both."""
input PostRequest {
  """The post ID."""
  post: PostId

  """The transaction hash you sent the post with."""
  txHash: TxHash
}

type PostResponse {
  hash: TxHash!
}

union PostResult = PostResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

union PostRule = FollowerOnlyPostRule | UnknownPostRule

type PostRulesConfig {
  required: [PostRule!]!
  anyOf: [PostRule!]!
}

type PostStats {
  """The total number of bookmarks."""
  bookmarks: Int!

  """The total number of comments."""
  comments: Int!

  """The total number of reposts."""
  reposts: Int!

  """The total number of quotes."""
  quotes: Int!

  """The total number of collects."""
  collects: Int!

  """Get the number of reactions for the post."""
  reactions(request: StatsReactionRequest! = {type: UPVOTE}): Int!
}

type PostTag {
  value: String!
  total: Int!
}

input PostTagsFilter {
  """The feeds to filter by."""
  feeds: [FeedOneOf!]
}

enum PostTagsOrderBy {
  MOST_POPULAR
  ALPHABETICAL
}

input PostTagsRequest {
  """An optional filter to apply to the tags."""
  filter: PostTagsFilter
  orderBy: PostTagsOrderBy! = MOST_POPULAR
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

enum PostType {
  ROOT
  COMMENT
  REPOST
  QUOTE
}

enum PostVisibilityFilter {
  """All posts even if they have been hidden"""
  ALL

  """Only the posts that are hidden"""
  HIDDEN

  """Only the posts that are visible"""
  VISIBLE
}

input PostsFilter {
  """The feeds to filter by."""
  feeds: [FeedOneOf!]
  authors: [EvmAddress!]
  postTypes: [PostType!]
  metadata: PostMetadataFilter
  apps: [EvmAddress!]

  """
  The optional query text to search for in the post content or metadata tags.
  """
  searchQuery: String
}

input PostsRequest {
  filter: PostsFilter
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type Query {
  health: Boolean!

  """Get an account by address, username, or legacy profile ID."""
  account(request: AccountRequest!): Account

  """Get accounts."""
  accounts(request: AccountsRequest!): PaginatedAccountsResult!

  """
  Account information for the authenticated account.
  
  You MUST be authenticated to use this query.
  """
  me: MeResult!

  """Get accounts by address, username, or legacy profile ID."""
  accountsBulk(request: AccountsBulkRequest!): [Account!]!

  """Get the stats for an account."""
  accountStats(request: AccountStatsRequest!): AccountStats!

  """Get the account stats for the graphs."""
  accountGraphsStats(request: AccountGraphsStatsRequest!): AccountGraphsFollowStats!

  """Get the account stats for the feeds."""
  accountFeedsStats(request: AccountFeedsStatsRequest!): AccountFeedsStats!

  """
  Accounts blocked for the authenticated account.
  
  You MUST be authenticated to use this query.
  """
  accountsBlocked(request: AccountsBlockedRequest!): PaginatedAccountsBlockedResult!

  """Get the accounts which are available to use for the given address"""
  accountsAvailable(request: AccountsAvailableRequest!): PaginatedAccountsAvailableResult!

  """
  Account manager for the authenticated account.
  
  You MUST be authenticated to use this query.
  """
  accountManagers(request: AccountManagersRequest!): PaginatedAccountManagersResult!

  """
  Get the last logged in account for the given address and app if specified.
  """
  lastLoggedInAccount(request: LastLoggedInAccountRequest!): Account

  """Get an app"""
  app(request: AppRequest!): App

  """Get the apps."""
  apps(request: AppsRequest!): AppsResult!

  """Get the groups for an app"""
  appGroups(request: AppGroupsRequest!): PaginatedGroupsResult!

  """Get the signers for an app"""
  appSigners(request: AppSignersRequest!): PaginatedAppSignersResult!

  """Get the feeds for an app"""
  appFeeds(request: AppFeedsRequest!): PaginatedAppFeedsResult!

  """Get accounts for an app."""
  appUsers(request: AppUsersRequest!): PaginatedAppUsersResult!

  """
  Get the server side API key for the app you must be the owner of the app to see it.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  appServerApiKey(request: AppServerApiKeyRequest!): ServerAPIKey!

  """
  List all active authenticated sessions for the current account.
  
  You MUST be authenticated to use this query.
  """
  authenticatedSessions(request: AuthenticatedSessionsRequest!): PaginatedActiveAuthenticationsResult!

  """
  Get the current authenticated session for the current account.
  
  You MUST be authenticated to use this query.
  """
  currentSession: AuthenticatedSession!
  feed(request: FeedRequest!): Feed

  """Get the feeds."""
  feeds(request: FeedsRequest!): PaginatedFeedsResult!
  post(request: PostRequest!): AnyPost
  posts(request: PostsRequest!): PaginatedAnyPostsResult!
  postReferences(request: PostReferencesRequest!): PaginatedAnyPostsResult!
  postTags(request: PostTagsRequest!): PaginatedPostTagsResult!
  postBookmarks(request: PostBookmarksRequest!): PaginatedAnyPostsResult!

  """Get the reactions added to a post."""
  postReactions(request: PostReactionsRequest!): PaginatedPostReactionsResult!
  postReactionStatus(request: PostReactionStatusRequest!): [PostReactionStatus!]!
  postActions(request: PostActionsRequest!): PaginatedActions!

  """Get accounts who referenced a post"""
  whoReferencedPost(request: WhoReferencedPostRequest!): PaginatedAccountsResult!
  whoActedOnPost(request: WhoActedOnPostRequest!): PaginatedAccountsResult!
  postEdits(request: PostEditsRequest!): PaginatedPostEditsResult!
  following(request: FollowingRequest!): PaginatedFollowingResult!
  followers(request: FollowersRequest!): PaginatedFollowersResult!
  followersYouKnow(request: FollowersYouKnowRequest!): PaginatedFollowersResult!
  followStatus(request: FollowStatusRequest!): [FollowStatusResult!]!
  graph(request: GraphRequest!): Graph

  """Get the graphs."""
  graphs(request: GraphsRequest!): PaginatedGraphsResult!
  group(request: GroupRequest!): Group

  """Get the groups."""
  groups(request: GroupsRequest!): PaginatedGroupsResult!

  """Get the members of the group"""
  groupMembers(request: GroupMembersRequest!): PaginatedGroupMembersResult!

  """Get the number of members in a Group"""
  groupStats(request: GroupStatsRequest!): GroupStatsResponse!

  """Get admins for a graph/app/sponsor/feed/username/group address"""
  adminsFor(request: AdminsForRequest!): PaginatedAdminsResult!

  """
  Get account timeline.
  
  You MUST be authenticated to use this query.
  """
  timeline(request: TimelineRequest!): PaginatedTimelineResult!

  """Get most engaged posts for the given account timeline."""
  timelineHighlights(request: TimelineHighlightsRequest!): PaginatedPostsResult!

  """
  Get account notifications.
  
  You MUST be authenticated to use this query.
  """
  notifications(request: NotificationRequest!): PaginatedNotificationResult!
  getSnsSubscriptions(request: GetSnsSubscriptionsRequest!): [SnsSubscription!]!
  mlAccountRecommendations(request: MlaccountRecommendationsRequest!): PaginatedAccountsResult!
  mlPostsForYou(request: MlpostsForYouRequest!): PaginatedPostsForYouResult!
  mlPostsExplore(request: MlexplorePostsRequest!): PaginatedPostsResult

  """Get the status of a transaction by its hash."""
  transactionStatus(request: TransactionStatusRequest!): TransactionStatusResult!
  debugMetadata(request: DebugPostMetadataRequest!): DebugPostMetadataResult!
  namespace(request: NamespaceRequest!): UsernameNamespace
  username(request: UsernameRequest!): Username

  """Get the usernames for the account/owner."""
  usernames(request: UsernamesRequest!): PaginatedUsernamesResult!

  """Get the namespaces."""
  namespaces(request: NamespacesRequest!): NamespacesResult!

  """Get paginated Sponsorship limits Exclusion list."""
  sponsorshipLimitsExclusions(request: SponsorshipLimitExclusionsRequest!): SponsorshipLimitsExclusionsResult!

  """Get a Sponsorship"""
  sponsorship(request: SponsorshipRequest!): Sponsorship

  """Get paginated Sponsorship Signers."""
  sponsorshipSigners(request: SponsorshipSignersRequest!): SponsorshipSignersResult!

  """Get paginated Sponsorships."""
  sponsorships(request: SponsorshipsRequest!): SponsorshipsResult!
  _service: _Service!
}

type QuoteNotification {
  id: GeneratedNotificationId!
  quote: Post!
}

type ReactionNotification {
  id: GeneratedNotificationId!
  reactions: [NotificationAccountPostReaction!]!
  post: Post!
}

input RecipientDataInput {
  recipient: EvmAddress!
  split: Float!
}

type RecipientDataOutput {
  recipient: EvmAddress!
  split: Float!
}

input RecommendAccount {
  """The account to recommend."""
  account: EvmAddress!
}

input ReferencingPostInput {
  """The post to reference."""
  post: PostId!
}

input RefreshRequest {
  refreshToken: RefreshToken!
}

union RefreshResult = AuthenticationTokens | ForbiddenError

scalar RefreshToken

input RemoveAccountManagerRequest {
  """The address to remove as a manager."""
  manager: EvmAddress!
}

union RemoveAccountManagerResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input RemoveAdminsRequest {
  """
  The graph/app/sponsor/feed/username/group address which manages these admins
  """
  address: EvmAddress!

  """The addresses to remove as admins"""
  admins: [EvmAddress!]!
}

union RemoveAdminsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input RemoveAppAuthorizationEndpointRequest {
  """The app."""
  app: EvmAddress!
}

input RemoveAppFeedsRequest {
  """The app to update"""
  app: EvmAddress!

  """The app feeds (max 10 per request)"""
  feeds: [EvmAddress!]!
}

union RemoveAppFeedsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input RemoveAppGroupsRequest {
  """The app to update"""
  app: EvmAddress!

  """The app groups (max 10 per request)"""
  groups: [EvmAddress!]!
}

union RemoveAppGroupsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input RemoveAppSignersRequest {
  """The app to update"""
  app: EvmAddress!

  """The app signers (max 10 per request)"""
  signers: [EvmAddress!]!
}

union RemoveAppSignersResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

union RemoveSignlessResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input ReportAccountRequest {
  """The account to report."""
  account: EvmAddress!

  """The reason for the report."""
  reason: AccountReportReason!

  """An optional comment to add to the report."""
  additionalComment: String

  """An optional list of posts to reference in the report."""
  referencePosts: [PostId!]
}

input ReportPostRequest {
  post: PostId!
  reason: PostReportReason!
  additionalComment: String
}

type Repost {
  id: PostId!
  slug: PostId!
  author: Account!
  isDeleted: Boolean!
  timestamp: DateTime!
  app: App
  repostOf: Post!
}

type RepostNotification {
  id: GeneratedNotificationId!
  reposts: [NotificationAccountRepost!]!
  post: Post!
}

type RestrictedSigner {
  label: String!
  signer: EvmAddress!
}

type RestrictedSignerGraphRule {
  rule: EvmAddress!
  signers: [RestrictedSigner!]!
}

type RestrictedSignersFeedRule {
  rule: EvmAddress!
  signers: [RestrictedSigner!]!
}

input RevokeAuthenticationRequest {
  authenticationId: UUID!
}

input RolloverRefreshRequest {
  """The app that new tokens will be issued for."""
  app: EvmAddress!

  """A valid Lens API v2 refresh token for a Profile session."""
  refreshToken: LegacyRefreshToken!
}

input RuleInput {
  rules: [EvmAddress!]!
}

enum SelfFundedFallbackReason {
  NOT_SPONSORED
  CANNOT_SPONSOR
}

type SelfFundedTransactionRequest {
  """
  The raw transaction request object.
  
  Use this object if your library does not have a parser for the encoded transaction data.
  """
  raw: Eip1559TransactionRequest!
  reason: String!
  selfFundedReason: SelfFundedFallbackReason
}

scalar ServerAPIKey

input SetAccountMetadataRequest {
  """The metadata URI to set."""
  metadataUri: URI!
}

type SetAccountMetadataResponse {
  hash: TxHash!
}

union SetAccountMetadataResult = SetAccountMetadataResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppGraphRequest {
  """The app to update"""
  app: EvmAddress!

  """The app graph to set"""
  graph: EvmAddress!
}

union SetAppGraphResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppMetadataRequest {
  """The app to update"""
  app: EvmAddress!

  """The app metadata to set"""
  metadataUri: String!
}

union SetAppMetadataResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppSponsorshipRequest {
  """The app to update"""
  app: EvmAddress!

  """The app sponsorship to set"""
  sponsorship: EvmAddress!
}

union SetAppSponsorshipResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppTreasuryRequest {
  """The app to update"""
  app: EvmAddress!

  """The app treasury to set"""
  treasury: EvmAddress!
}

union SetAppTreasuryResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppUsernameNamespaceRequest {
  """The app to update"""
  app: EvmAddress!

  """The app username namespace to set"""
  usernameNamespace: EvmAddress!
}

union SetAppUsernameNamespaceResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppVerificationRequest {
  """The app to update"""
  app: EvmAddress!

  """The new verification state"""
  enabled: Boolean!
}

union SetAppVerificationResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetDefaultAppFeedRequest {
  """The app to update"""
  app: EvmAddress!

  """The app default feed to set"""
  feed: EvmAddress!
}

union SetDefaultAppFeedResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetFeedMetadataRequest {
  """The feed to update"""
  feed: EvmAddress!

  """The feed metadata to set"""
  metadataUri: String!
}

union SetFeedMetadataResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetGraphMetadataRequest {
  """The graph to update"""
  graph: EvmAddress!

  """The graph metadata to set"""
  metadataUri: String!
}

union SetGraphMetadataResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetGroupMetadataRequest {
  """The group to update"""
  group: EvmAddress!

  """The group metadata to set"""
  metadataUri: String!
}

union SetGroupMetadataResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetNamespaceMetadataRequest {
  """The namespace to update"""
  namespace: EvmAddress!

  """The namespace metadata to set"""
  metadataUri: String!
}

union SetNamespaceMetadataResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetSponsorshipMetadataRequest {
  """The sponsorship to update"""
  sponsorship: EvmAddress!

  """The sponsorship metadata to set"""
  metadataUri: URI!
}

union SetSponsorshipMetadataResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar Signature

input SignedAuthChallenge {
  id: UUID!
  signature: Signature!
}

input SimpleCollectActionInput {
  amount: AmountInput
  referralFee: Float
  recipient: EvmAddress
  collectLimit: String
  followerOnly: Boolean!
  endsAt: DateTime
  recipients: [RecipientDataInput!]
}

type SimpleCollectActionSettings {
  contract: NetworkAddress!
  amount: Amount!
  collectNft: EvmAddress
  collectLimit: String
  followerOnly: Boolean!
  recipient: EvmAddress!
  referralFee: Float!
  endsAt: DateTime
  recipients: [RecipientDataOutput!]!
}

type SimplePaymentFeedRule {
  rule: EvmAddress!
  amount: Amount!
  recipient: EvmAddress!
}

type SimplePaymentFollowRule {
  rule: EvmAddress!
  amount: Amount!
  recipient: EvmAddress!
}

type SimplePaymentGroupRule {
  rule: EvmAddress!
  amount: Amount!
  recipient: EvmAddress!
}

type SimplePaymentUsernameNamespaceRule {
  rule: EvmAddress!
  amount: Amount!
  recipient: EvmAddress!
}

enum SnsNotificationType {
  MEDIA_SNAPSHOT_SUCCESS
  MEDIA_SNAPSHOT_ERROR
  METADATA_SNAPSHOT_SUCCESS
  METADATA_SNAPSHOT_ERROR
  POST_CREATED
  QUOTE_CREATED
  COMMENT_CREATED
  REPOST_CREATED
  POST_EDITED
  POST_DELETED
  POST_COLLECTED
  POST_ACTION_COMPLETED
  POST_REACTION_ADDED
  POST_REACTION_REMOVED
  POST_REPORTED
  ACCOUNT_CREATED
  ACCOUNT_MENTIONED
  ACCOUNT_FOLLOWED
  ACCOUNT_UNFOLLOWED
  ACCOUNT_FOLLOW_RULES_UPDATED
  ACCOUNT_BLOCKED
  ACCOUNT_UNBLOCKED
  ACCOUNT_METADATA_UPDATED
  ACCOUNT_USERNAME_CREATED
  ACCOUNT_USERNAME_ASSIGNED
  ACCOUNT_USERNAME_UNASSIGNED
  ACCOUNT_CONTENT_CONSUMED
  ACCOUNT_MANAGER_ADDED
  ACCOUNT_MANAGER_REMOVED
  ACCOUNT_MANAGER_UPDATED
  ACCOUNT_OWNERSHIP_TRANSFERRED
  ACCOUNT_REPORTED
  ML_PROFILE_SIGNAL
}

type SnsSubscription {
  id: UUID!
  account: EvmAddress!
  webhook: URL!
  app: EvmAddress
  topic: SnsNotificationType!
  topicArn: String!
  filter: JSON!
}

input SnsTopicInput @oneOf {
  mediaSnapshotSuccess: MediaSnapshotNotificationAttributes
  mediaSnapshotError: MediaSnapshotNotificationAttributes
  metadataSnapshotSuccess: MetadataSnapshotNotificationAttributes
  metadataSnapshotError: MetadataSnapshotNotificationAttributes
  postCreated: PostCreatedNotificationAttributes
  quoteCreated: PostCreatedNotificationAttributes
  commentCreated: PostCreatedNotificationAttributes
  repostCreated: PostCreatedNotificationAttributes
  postEdited: PostEditedNotificationAttributes
  postDeleted: PostDeletedNotificationAttributes
  postReactionAdded: PostReactionAddedNotificationAttributes
  postReactionRemoved: PostReactionRemovedNotificationAttributes
  postReported: PostReportedNotificationAttributes
  accountCreated: AccountCreatedNotificationAttributes
  accountMentioned: AccountMentionedNotificationAttributes
  accountFollowed: AccountFollowedNotificationAttributes
  accountUnfollowed: AccountUnfollowedNotificationAttributes
  accountBlocked: AccountBlockedNotificationAttributes
  accountUnblocked: AccountUnblockedNotificationAttributes
  accountUsernameCreated: AccountUsernameCreatedNotificationAttributes
  accountUsernameAssigned: AccountUsernameAssignedNotificationAttributes
  accountUsernameUnassigned: AccountUsernameUnassignedNotificationAttributes
  accountManagerAdded: AccountManagerAddedNotificationAttributes
  accountManagerRemoved: AccountManagerRemovedNotificationAttributes
  accountManagerUpdated: AccountManagerUpdatedNotificationAttributes
  accountOwnershipTransferred: AccountOwnershipTransferredNotificationAttributes
  accountReported: AccountReportedNotificationAttributes
}

type SpaceMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!

  """The space join link."""
  link: URI!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """The space start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: DateTime!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The space title."""
  title: String!
  content: String!
}

type SponsorLimit {
  window: SponsorshipRateLimitWindow!
  allowance: Int!
}

enum SponsoredFallbackReason {
  SIGNLESS_DISABLED
  SIGNLESS_FAILED
}

type SponsoredTransactionRequest {
  """
  The raw transaction request object.
  
  Use this object if your library does not have a parser for the encoded transaction data.
  """
  raw: Eip712TransactionRequest!
  reason: String!
  sponsoredReason: SponsoredFallbackReason
}

type Sponsorship {
  address: EvmAddress!
  isPaused: Boolean!
  createdAt: DateTime!
  metadata: SponsorshipMetadata
  globalRateLimit: SponsorLimit
  userRateLimit: SponsorLimit
  owner: EvmAddress!

  """
  The native token balance of the sponsorship contract.
  
  This value is cached for up to 2 minutes for each sponsorship contract.
  """
  balance: BigDecimal

  """
  Indicates whether the Lens API is authorized as the sponsorship signer
  to sponsor end-user social operations (e.g., posts, comments, follows)
  performed through the Lens API for apps associated with this sponsorship.
  """
  allowsLensAccess: Boolean!
}

type SponsorshipAllowance {
  """The sponsorship window type."""
  window: SponsorshipRateLimitWindow!

  """The number of remaining sponsorship allowance."""
  allowanceLeft: Int!

  """The number of sponsorship allowance used."""
  allowanceUsed: Int!

  """The total sponsorship allowance."""
  allowance: Int!
}

input SponsorshipLimitExclusionsFilter {
  """The sponsorship address."""
  sponsorship: EvmAddress!
}

enum SponsorshipLimitExclusionsOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
  ALPHABETICAL
}

input SponsorshipLimitExclusionsRequest {
  """The filter options."""
  filter: SponsorshipLimitExclusionsFilter!

  """The order by criteria."""
  orderBy: SponsorshipLimitExclusionsOrderBy! = OLDEST_FIRST

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type SponsorshipLimitsExclusionsResult {
  items: [SponsorshipLimitsExempt!]!
  pageInfo: PaginatedResultInfo!
}

type SponsorshipLimitsExempt {
  sponsorship: EvmAddress!
  label: String!
  address: EvmAddress!
  createdAt: DateTime!
}

type SponsorshipMetadata {
  """An optional description of the Username collection."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """The name of the Sponsorship."""
  name: String!
}

input SponsorshipRateLimit {
  """The limit time window."""
  window: SponsorshipRateLimitWindow!

  """The limit value."""
  limit: Int!
}

enum SponsorshipRateLimitWindow {
  HOUR
  DAY
  WEEK
  MONTH
}

input SponsorshipRateLimits {
  """The global rate limit."""
  global: SponsorshipRateLimit

  """The user rate limit."""
  user: SponsorshipRateLimit
}

input SponsorshipRateLimitsExempt {
  """The exempt address."""
  address: EvmAddress!

  """The human-readable label for the exempt address."""
  label: String!
}

input SponsorshipRequest {
  """The Sponsorship address."""
  address: EvmAddress

  """The transaction hash you created the Sponsorship with."""
  txHash: TxHash
}

type SponsorshipSigner {
  sponsorship: EvmAddress!
  label: String!
  address: EvmAddress!
  createdAt: DateTime!
}

input SponsorshipSignerInput {
  """The signer address"""
  address: EvmAddress!

  """The human-readable label for the signer"""
  label: String!
}

input SponsorshipSignersFilter {
  """The sponsorship address."""
  sponsorship: EvmAddress!
}

enum SponsorshipSignersOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
  ALPHABETICAL
}

input SponsorshipSignersRequest {
  """The filter options."""
  filter: SponsorshipSignersFilter!

  """The order by criteria."""
  orderBy: SponsorshipSignersOrderBy! = OLDEST_FIRST

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type SponsorshipSignersResult {
  items: [SponsorshipSigner!]!
  pageInfo: PaginatedResultInfo!
}

input SponsorshipsFilter {
  """The filter to get Sponsorships managed by address"""
  managedBy: ManagedBy!
}

enum SponsorshipsOrderBy {
  LATEST_FIRST
  OLDEST_FIRST
  ALPHABETICAL
}

input SponsorshipsRequest {
  """The filter options."""
  filter: SponsorshipsFilter!

  """The order by criteria."""
  orderBy: SponsorshipsOrderBy! = LATEST_FIRST

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type SponsorshipsResult {
  items: [Sponsorship!]!
  pageInfo: PaginatedResultInfo!
}

input StatsReactionRequest {
  type: PostReactionType!
}

type StoryMetadata {
  """The story asset."""
  asset: AnyMedia!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: String!
}

type SubOperationStatus {
  operation: TransactionOperation!
  status: IndexingStatus!
}

input SwitchAccountRequest {
  account: EvmAddress!
}

union SwitchAccountResult = AuthenticationTokens | ForbiddenError

scalar Tag

type TextOnlyMetadata {
  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  content: String!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

type ThreeDAsset {
  """The 3D format of the asset."""
  format: ThreeDAssetFormat!

  """The license regulating the use of the 3D asset."""
  license: MetadataLicenseType

  """
  The URL of the recommended web based 3D player to use to view the 3D asset.
  """
  playerUrl: URI!

  """The URI of the 3D asset zip file."""
  uri: URI!

  """Path in extracted zip. Relative. 3D start point, MUST be 3D file type."""
  zipPath: String
}

enum ThreeDAssetFormat {
  G_LTF_GLB
  FBX
  VRM
  OBJ
}

type ThreeDMetadata {
  """The 3D items for the post"""
  assets: [ThreeDAsset!]!

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: String!
}

enum TimelineEventItemType {
  POST
  COMMENT
  REPOST
  QUOTE
}

input TimelineFilter {
  """The feeds to filter by."""
  feeds: [FeedOneOf!]

  """The apps to filter by."""
  apps: [EvmAddress!]

  """The post event types to filter by."""
  eventType: [TimelineEventItemType!]

  """The optional metadata filter."""
  metadata: PostMetadataFilter
}

input TimelineHighlightsFilter {
  """The feeds to filter by."""
  feeds: [FeedOneOf!]

  """The apps to filter by."""
  apps: [EvmAddress!]
  metadata: PostMetadataFilter
}

input TimelineHighlightsRequest {
  """The account to get timeline highlights for."""
  account: EvmAddress!

  """An optional filter to apply to the timeline."""
  filter: TimelineHighlightsFilter
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type TimelineItem {
  id: UUID!
  primary: Post!
  reposts: [Post!]!
  comments: [Post!]!
}

input TimelineRequest {
  """The account to get timeline for."""
  account: EvmAddress!

  """An optional filter to apply to the timeline."""
  filter: TimelineFilter

  """The cursor."""
  cursor: Cursor
}

type TokenGatedFeedRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

type TokenGatedFollowRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

type TokenGatedGraphRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

type TokenGatedGroupRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

type TokenGatedUsernameNamespaceRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

enum TokenStandard {
  ERC_20
  ERC_721
  ERC_1155
}

type TransactionMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """The Chain Id."""
  chainId: ChainId!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The transaction hash."""
  txHash: String!

  """The type of transaction."""
  type: TransactionType!
  content: String!
}

enum TransactionOperation {
  ACCESS_CONTROL_ROLE_GRANTED
  ACCESS_CONTROL_ROLE_REVOKED
  ACCESS_CONTROL_FACTORY_OWNER_ADMIN_DEPLOYMENT
  ACCOUNT_FACTORY_DEPLOYMENT
  ACCOUNT_MANAGER_ADDED
  ACCOUNT_MANAGER_REMOVED
  ACCOUNT_MANAGER_UPDATED
  ACCOUNT_OWNER_TRANSFERRED
  ACCOUNT_METADATA_URI_SET
  APP_FACTORY_DEPLOYMENT
  APP_ACCESS_CONTROL_ADDED
  APP_ACCESS_CONTROL_UPDATED
  APP_DEFAULT_FEED_SET
  APP_EXTRA_DATA_ADDED
  APP_EXTRA_DATA_REMOVED
  APP_EXTRA_DATA_UPDATED
  APP_FEED_ADDED
  APP_FEED_REMOVED
  APP_GRAPH_ADDED
  APP_GRAPH_REMOVED
  APP_GROUP_ADDED
  APP_GROUP_REMOVED
  APP_METADATA_URI_SET
  APP_SIGNER_ADDED
  APP_SIGNER_REMOVED
  APP_SOURCE_STAMP_VERIFICATION_SET
  APP_PAYMASTER_ADDED
  APP_PAYMASTER_REMOVED
  APP_TREASURY_SET
  APP_USERNAME_ADDED
  APP_USERNAME_REMOVED
  FEED_ACCESS_CONTROL_ADDED
  FEED_ACCESS_CONTROL_UPDATED
  FEED_EXTRA_DATA_ADDED
  FEED_EXTRA_DATA_REMOVED
  FEED_EXTRA_DATA_UPDATED
  FEED_METADATA_URI_SET
  FEED_POST_CREATED
  FEED_POST_DELETED
  FEED_POST_EDITED
  GRAPH_FACTORY_DEPLOYMENT
  GRAPH_ACCESS_CONTROL_ADDED
  GRAPH_ACCESS_CONTROL_UPDATED
  GRAPH_EXTRA_DATA_ADDED
  GRAPH_EXTRA_DATA_REMOVED
  GRAPH_EXTRA_DATA_UPDATED
  GRAPH_FOLLOWED
  GRAPH_METADATA_URI_SET
  GRAPH_UNFOLLOWED
  GROUP_FACTORY_DEPLOYMENT
  GROUP_MEMBER_JOINED
  GROUP_MEMBER_LEFT
  GROUP_MEMBER_REMOVED
  GROUP_ACCESS_CONTROL_ADDED
  GROUP_ACCESS_CONTROL_UPDATED
  GROUP_EXTRA_DATA_ADDED
  GROUP_EXTRA_DATA_REMOVED
  GROUP_EXTRA_DATA_UPDATED
  GROUP_METADATA_URI_SET
  SPONSOR_FREE_PAYMASTER_CREATED
  SPONSOR_ADDED_TO_APPROVED_SIGNERS
  SPONSOR_METADATA_URI_CHANGED
  USERNAME_ASSIGNED
  USERNAME_CREATED
  USERNAME_FACTORY_DEPLOYMENT
  USERNAME_REMOVED
  USERNAME_UNASSIGNED
  USERNAME_ACCESS_CONTROL_ADDED
  USERNAME_ACCESS_CONTROL_UPDATED
  USERNAME_EXTRA_DATA_ADDED
  USERNAME_EXTRA_DATA_REMOVED
  USERNAME_EXTRA_DATA_UPDATED
  USERNAME_METADATA_URI_SET
  SPONSORSHIP_ACCESS_CONTROL_ADDED
  SPONSORSHIP_ACCESS_CONTROL_UPDATED
  SPONSORSHIP_ADDED_TO_EXCLUSION_LIST
  SPONSORSHIP_REMOVED_FROM_EXCLUSION_LIST
  SPONSORSHIP_FACTORY_DEPLOYMENT
  SPONSORSHIP_FUNDS_SPENT
  SPONSORSHIP_GRANT_REVOKED
  SPONSORSHIP_GRANTED_FUNDS
  SPONSORSHIP_METADATA_URI_SET
  SPONSORSHIP_PAUSED
  SPONSORSHIP_RATE_LIMITS_CHANGED
  SPONSORSHIP_UNPAUSED
  SPONSORSHIP_SIGNER_ADDED
  SPONSORSHIP_SIGNER_REMOVED
  FEED_FACTORY_DEPLOYMENT
}

input TransactionStatusRequest {
  txHash: TxHash!
}

union TransactionStatusResult = PendingTransactionStatus | FinishedTransactionStatus | FailedTransactionStatus | NotIndexedYetStatus

enum TransactionType {
  ERC_721
  ERC_20
  OTHER
}

type TransactionWillFail {
  reason: String!
}

input TransferPrimitiveOwnershipRequest {
  """
  The graph/app/sponsor/feed/username/group address to change ownership for
  """
  address: EvmAddress!

  """The address of the new owner"""
  newOwner: EvmAddress!
}

union TransferPrimitiveOwnershipResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar TxHash

scalar URI

scalar URL

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique Identifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID @specifiedBy(url: "http://tools.ietf.org/html/rfc4122")

input UnassignUsernameFromAccountRequest {
  namespace: EvmAddress! = "0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"
}

type UnassignUsernameResponse {
  hash: TxHash!
}

union UnassignUsernameToAccountResult = UnassignUsernameResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type UnblockError {
  error: UnblockErrorType!
}

enum UnblockErrorType {
  UNKNOWN
  NOT_BLOCKED
  UNAUTHORIZED
}

input UnblockRequest {
  """The account to unblock."""
  account: EvmAddress!
}

type UnblockResponse {
  hash: TxHash!
}

union UnblockResult = UnblockResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | UnblockError

type UndoReactionFailure {
  reason: String!
}

input UndoReactionRequest {
  """The reaction to add."""
  reaction: PostReactionType!

  """The post to react to."""
  post: PostId!
}

type UndoReactionResponse {
  success: Boolean!
}

union UndoReactionResult = UndoReactionResponse | UndoReactionFailure

input UndoRecommendedAccount {
  """The account to remove as a recommendation."""
  account: EvmAddress!
}

type UnfollowResponse {
  hash: TxHash!
}

union UnfollowResult = UnfollowResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input UnhideManagedAccountRequest {
  """The account to unhide."""
  account: EvmAddress!
}

input UnhideReplyRequest {
  post: PostId!
}

type UnknownAction {
  name: String!
  contract: NetworkAddress!
}

input UnknownActionInput {
  address: EvmAddress!
  data: String!
}

type UnknownActionSettings {
  initializeCalldata: BlockchainData
  initializeResultData: BlockchainData
  verified: Boolean!
  contract: NetworkAddress!
  collectNft: EvmAddress
}

type UnknownFeedRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

input UnknownFeedRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

type UnknownFollowRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

input UnknownFollowRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

type UnknownGraphRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

input UnknownGraphRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

type UnknownGroupRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

type UnknownPostRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

type UnknownRule {
  rule: EvmAddress!
  configParams: [KeyValue!]!
}

type UnknownUsernameNamespaceRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

type UnsatisfiedRule {
  name: String!
  rule: EvmAddress!
  reason: String!
}

input UpdateAccountManagerRequest {
  """The address to update as a manager."""
  manager: EvmAddress!

  """The permissions to update for the account manager."""
  permissions: AccountManagerPermissionsInput!
}

union UpdateAccountManagerResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input UpdateSponsorshipExclusionListRequest {
  """The sponsorship to update"""
  sponsorship: EvmAddress!

  """The new entries to add."""
  toAdd: [SponsorshipRateLimitsExempt!]! = []

  """The entries to remove."""
  toRemove: [EvmAddress!]! = []
}

union UpdateSponsorshipExclusionListResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input UpdateSponsorshipLimitsRequest {
  """The sponsorship to update"""
  sponsorship: EvmAddress!

  """The new rate limits"""
  rateLimits: SponsorshipRateLimits
}

union UpdateSponsorshipLimitsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input UpdateSponsorshipSignersRequest {
  """The sponsorship to update"""
  sponsorship: EvmAddress!

  """The new entries to add."""
  toAdd: [SponsorshipSignerInput!]! = []

  """The entries to remove."""
  toRemove: [EvmAddress!]! = []
}

union UpdateSponsorshipSignersResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type UserBlockingRule {
  rule: EvmAddress!
  blockedUsers: [EvmAddress!]!
}

type Username {
  """A unique identifier for the username entry."""
  id: ID!

  """The username value (e.g., lens/bob)."""
  value: UsernameValue!

  """The local name of the username (e.g., bob)."""
  localName: String!

  """The address that the username is linked to, if any."""
  linkedTo: EvmAddress

  """The address that owns the username entry."""
  ownedBy: EvmAddress!

  """The timestamp when the username was created."""
  timestamp: DateTime!
  namespace: UsernameNamespace!
  operations: LoggedInUsernameOperations
}

input UsernameInput {
  """The local name, should not include the namespace"""
  localName: String!

  """The namespace. Defaults to lens namespace"""
  namespace: EvmAddress! = "0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"
}

type UsernameNamespace {
  """The address of the namespace."""
  address: EvmAddress!

  """The namespace for example `lens`"""
  namespace: String!
  createdAt: DateTime!
  metadata: UsernameNamespaceMetadata
  owner: EvmAddress!
  stats: UsernameNamespaceStats!
  operations: LoggedInUsernameNamespaceOperations
  rules(request: RuleInput): UsernameNamespaceRulesConfig!
}

type UsernameNamespaceMetadata {
  """An optional description of the Username collection."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!
}

union UsernameNamespaceRule = TokenGatedUsernameNamespaceRule | SimplePaymentUsernameNamespaceRule | CharsetUsernameNamespaceRule | LengthUsernameNamespaceRule | UnknownUsernameNamespaceRule

type UsernameNamespaceRulesConfig {
  required: [UsernameNamespaceRule!]!
  anyOf: [UsernameNamespaceRule!]!
}

type UsernameNamespaceStats {
  totalUsernames: Int!
}

"""You must provide either an id or a username, not both."""
input UsernameRequest {
  """The username ID."""
  id: ID

  """The username namespace and local name."""
  username: UsernameInput
}

input UsernameSearchInput {
  """
  The local name to search for
  Uses fuzzy search on username name
  """
  localNameQuery: String!

  """
  The namespaces to search for local name in. Defaults to global namespace
  """
  namespaces: [EvmAddress!]! = ["0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"]
}

scalar UsernameValue

input UsernamesFilter {
  """The optional filter to get usernames owned by address"""
  owner: EvmAddress

  """The optional filter to get usernames linked to an address"""
  linkedTo: EvmAddress

  """The optional filter to get usernames for a namespace"""
  namespace: EvmAddress

  """
  The optional filter to narrow usernames
  Uses fuzzy search by local name
  """
  localNameQuery: String
}

enum UsernamesOrderBy {
  LAST_MINTED
  FIRST_MINTED
}

input UsernamesRequest {
  filter: UsernamesFilter

  """The order by."""
  orderBy: UsernamesOrderBy! = LAST_MINTED

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type VideoMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional video title."""
  title: String
  video: MediaVideo!
  content: String!
}

scalar Void

input WhoActedOnPostFilter {
  anyOf: [ActionFilter!]!
}

enum WhoActedOnPostOrderBy {
  LAST_ACTIONED
  FIRST_ACTIONED
  ACCOUNT_SCORE
}

input WhoActedOnPostRequest {
  """The post id to get who acted on."""
  post: PostId!
  filter: WhoActedOnPostFilter
  orderBy: WhoActedOnPostOrderBy

  """The page size."""
  pageSize: Int

  """The cursor."""
  cursor: Cursor
}

enum WhoReferencedPostOrderBy {
  MOST_RECENT
  OLDEST
  ACCOUNT_SCORE
}

input WhoReferencedPostRequest {
  """The post id to get who referenced."""
  post: PostId!

  """The types of references to get."""
  referenceTypes: [PostReferenceType!]!
  orderBy: WhoReferencedPostOrderBy! = MOST_RECENT

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

"""The signature was not signed by the expected signer."""
type WrongSignerError {
  reason: String!
}

type _Service {
  sdl: String
}
