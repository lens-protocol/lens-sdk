"""
The comparison operator to use. In case of boolean functions you can only use EQUAL or NOT_EQUAL

<details><summary>JSON schema</summary>

```json
{
"description": "The comparison operator to use. In case of boolean functions you can only use EQUAL or NOT_EQUAL",
"type": "string",
"enum": [
"EQUAL",
"NOT_EQUAL",
"GREATER_THAN",
"GREATER_THAN_OR_EQUAL",
"LESS_THAN",
"LESS_THAN_OR_EQUAL"
]
}
```
</details>
"""
enum AccessConditionComparison {
  EQUAL
  NOT_EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
}

"""
AccessConditionCriteriaItemVariant0CriteriaItem

<details><summary>JSON schema</summary>

```json
{
"anyOf": [
{
"$ref": "#/$defs/NftOwnershipCondition"
},
{
"$ref": "#/$defs/Erc20OwnershipCondition"
},
{
"$ref": "#/$defs/EoaOwnershipCondition"
},
{
"$ref": "#/$defs/ProfileOwnershipCondition"
},
{
"$ref": "#/$defs/FollowCondition"
},
{
"$ref": "#/$defs/CollectCondition"
},
{
"$ref": "#/$defs/AdvancedContractCondition"
}
]
}
```
</details>
"""
union AccessConditionType = NftOwnershipCondition | Erc20OwnershipCondition | EoaOwnershipCondition | ProfileOwnershipCondition | FollowCondition | CollectCondition | AdvancedContractCondition

scalar AccessToken

type Account {
  address: EvmAddress!
  score: Int!
  metadata: AccountMetadata
  username: UsernameValue
  operations: LoggedInAccountOperations
}

input AccountAuthenticationsRequest {
  app: EvmAddress
  pageSize: PageSize
  cursor: Cursor
}

type AccountBlocked {
  account: Account!
  blockedAt: DateTime!
}

type AccountFeedsStats {
  posts: Int!
  comments: Int!
  reposts: Int!
  quotes: Int!
  reacted: Int!
  reactions: Int!
  collects: Int!
}

input AccountFeedsStatsRequest {
  account: EvmAddress!
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
}

type AccountFollowRuleError {
  error: AccountFollowRuleErrorType!
}

enum AccountFollowRuleErrorType {
  UNKNOWN
}

union AccountFollowRuleResult = OptimisticAccountFollowRule | SponsoredTransactionRequest | TransactionRequest | AccountFollowRuleError

type AccountGraphsFollowStats {
  followers: Int!
  following: Int!
}

input AccountGraphsStatsRequest {
  account: EvmAddress!
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
}

type AccountManaged {
  account: Account!
  addedAt: DateTime!
}

type AccountManager {
  address: EvmAddress!
  isLensManager: Boolean!
  addedAt: DateTime!
}

input AccountManagersRequest {
  pageSize: PageSize
  cursor: Cursor
}

"""
AccountMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/profile/2.0.0.json"
},
"lens": {
"description": "The Lens specific metadata details.",
"type": "object",
"required": [
"id"
],
"properties": {
"appId": {
"description": "The App Id that this Profile data refers to. If omitted the data is considered to be the global Profile data.",
"$ref": "#/$defs/AppId"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"bio": {
"description": "The profile bio as markdown.",
"$ref": "#/$defs/NonEmptyString"
},
"coverPicture": {
"description": "The profile cover picture.",
"$ref": "#/$defs/Uri"
},
"id": {
"description": "A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI. Use a UUID if unsure.",
"$ref": "#/$defs/NonEmptyString"
},
"name": {
"description": "The profile display name.",
"$ref": "#/$defs/NonEmptyString"
},
"picture": {
"description": "The profile picture.",
"$ref": "#/$defs/Uri"
}
},
"additionalProperties": false
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": false
}
```
</details>
"""
type AccountMetadata {
  lens: AccountMetadataLens!
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
The Lens specific metadata details.

<details><summary>JSON schema</summary>

```json
{
"description": "The Lens specific metadata details.",
"type": "object",
"required": [
"id"
],
"properties": {
"appId": {
"description": "The App Id that this Profile data refers to. If omitted the data is considered to be the global Profile data.",
"$ref": "#/$defs/AppId"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"bio": {
"description": "The profile bio as markdown.",
"$ref": "#/$defs/NonEmptyString"
},
"coverPicture": {
"description": "The profile cover picture.",
"$ref": "#/$defs/Uri"
},
"id": {
"description": "A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI. Use a UUID if unsure.",
"$ref": "#/$defs/NonEmptyString"
},
"name": {
"description": "The profile display name.",
"$ref": "#/$defs/NonEmptyString"
},
"picture": {
"description": "The profile picture.",
"$ref": "#/$defs/Uri"
}
},
"additionalProperties": false
}
```
</details>
"""
type AccountMetadataLens {
  """
  The App Id that this Profile data refers to. If omitted the data is considered to be the
  global Profile data.
  """
  appId: AppId

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """The profile bio as markdown."""
  bio: NonEmptyString

  """The profile cover picture."""
  coverPicture: URI

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: NonEmptyString!

  """The profile display name."""
  name: NonEmptyString

  """The profile picture."""
  picture: URI
}

type AccountPostReaction {
  account: Account!
  reactions: [PostReaction!]!
}

enum AccountReportReason {
  IMPERSONATION
  REPETITIVE_SPAM
  OTHER
}

input AccountRequest {
  address: EvmAddress
  username: UsernameValue
  legacyProfileId: LegacyProfileId
}

enum AccountSearchOrderBy {
  USERNAME_PREFIX_ORDER
  ACCOUNT_SCORE
}

input AccountSearchRequest {
  limit: Int
  cursor: Cursor
  query: String!
  namespace: [String!]
  orderBy: AccountSearchOrderBy
}

type AccountSponsorLimit {
  window: SponsorLimitType!
  allowanceLeft: Int!
  allowanceUsed: Int!
  allowance: Int!
}

input AccountSponsorRequest {
  account: EvmAddress!
  appOrSponsor: EvmAddress
}

type AccountSponsorResult {
  global: AccountSponsorLimit
  user: AccountSponsorLimit
}

type AccountStats {
  feedStats: AccountFeedsStats!
  graphFollowStats: AccountGraphsFollowStats!
}

input AccountStatsRequest {
  account: EvmAddress!
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
}

type AccountUsername {
  id: String
  value: UsernameValue!
  prefix: String!
  localName: String!
  linkedTo: EvmAddress
  ownedBy: EvmAddress!
}

input AccountUsernameRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
}

input AccountsBlockedRequest {
  pageSize: PageSize
  cursor: Cursor
}

input AccountsManagedRequest {
  pageSize: PageSize
  cursor: Cursor
  managedBy: EvmAddress!
  includeOwned: Boolean
  hiddenFilter: ManagedAccountsVisibility
}

input AccountsRequest {
  addresses: [EvmAddress!]
  usernames: [UsernameValue!]
  legacyProfileIds: [LegacyProfileId!]
  limit: Int
  cursor: Cursor
}

input ActionFilter {
  address: EvmAddress
  actionType: PostActionType
  category: PostActionCategoryType
}

union ActionInfo = KnownAction | UnknownAction

type ActionInputInfo {
  name: String!
  type: String!
}

type ActiveAuthentication {
  authenticationId: UUID!
  app: EvmAddress!
  browser: String
  device: String
  os: String
  origin: URL
  signer: EvmAddress!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type AddReactionFailure {
  reason: String!
}

input AddReactionRequest {
  """The reaction to add."""
  reaction: PostReactionType!

  """The post to react to."""
  postId: PostId!
}

type AddReactionResponse {
  success: Boolean!
}

union AddReactionResult = AddReactionResponse | AddReactionFailure

"""
AdvancedContractCondition

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"abi",
"comparison",
"contract",
"functionName",
"params",
"type",
"value"
],
"properties": {
"abi": {
"description": "The contract ABI. Has to be in human readable single string format containing the signature of the function you want to call. See https://docs.ethers.org/v5/api/utils/abi/formats/#abi-formats--human-readable-abi for more info",
"$ref": "#/$defs/NonEmptyString"
},
"comparison": {
"description": "The comparison operator to use. In case of boolean functions you can only use EQUAL or NOT_EQUAL",
"type": "string",
"enum": [
"EQUAL",
"NOT_EQUAL",
"GREATER_THAN",
"GREATER_THAN_OR_EQUAL",
"LESS_THAN",
"LESS_THAN_OR_EQUAL"
]
},
"contract": {
"description": "The contract address and chain id",
"type": "object",
"required": [
"address",
"chainId"
],
"properties": {
"address": {
"$ref": "#/$defs/EvmAddress"
},
"chainId": {
"$ref": "#/$defs/ChainId"
}
},
"additionalProperties": false
},
"functionName": {
"description": "The name of the function you want to call",
"type": "string",
"minLength": 1
},
"params": {
"description": "The parameters to pass to the function. Must be exactly matching the function arguments. You *must* pass in the `:userAddress` parameter to represent the decrypter address. Any array or tuple arguments, must be stringified JSON arrays.",
"type": "array",
"items": {
"type": "string"
}
},
"type": {
"type": "string",
"const": "ADVANCED_CONTRACT"
},
"value": {
"description": "The comparison value. Accepts 'true', 'false' or a number",
"type": "string",
"pattern": "^(true|false|\\d{1,70})$"
}
},
"additionalProperties": false
}
```
</details>
"""
type AdvancedContractCondition {
  """
  The contract ABI. Has to be in human readable single string format containing the signature of the function you want to call. See https://docs.ethers.org/v5/api/utils/abi/formats/#abi-formats--human-readable-abi for more info
  """
  abi: NonEmptyString!

  """
  The comparison operator to use. In case of boolean functions you can only use EQUAL or
  NOT_EQUAL
  """
  comparison: AccessConditionComparison!
  contract: NetworkAddress!

  """The name of the function you want to call"""
  functionName: NonEmptyString!

  """
  The parameters to pass to the function. Must be exactly matching the function arguments.
  You *must* pass in the `:userAddress` parameter to represent the decrypter address. Any
  array or tuple arguments, must be stringified JSON arrays.
  """
  params: [String!]!
  type: String!

  """The comparison value. Accepts 'true', 'false' or a number"""
  value: AdvancedContractConditionValue!
}

scalar AdvancedContractConditionValue

type Amount {
  asset: Asset!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!
}

input AmountInput {
  """
  The token address. To represent the native token, use the
  0x000000000000000000000000000000000000800a.
  """
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!
}

"""
AccessConditionCriteriaItem

<details><summary>JSON schema</summary>

```json
{
"anyOf": [
{
"type": "object",
"required": [
"criteria",
"type"
],
"properties": {
"criteria": {
"type": "array",
"items": {
"anyOf": [
{
"$ref": "#/$defs/NftOwnershipCondition"
},
{
"$ref": "#/$defs/Erc20OwnershipCondition"
},
{
"$ref": "#/$defs/EoaOwnershipCondition"
},
{
"$ref": "#/$defs/ProfileOwnershipCondition"
},
{
"$ref": "#/$defs/FollowCondition"
},
{
"$ref": "#/$defs/CollectCondition"
},
{
"$ref": "#/$defs/AdvancedContractCondition"
}
]
},
"maxItems": 5
},
"type": {
"type": "string",
"const": "AND"
}
},
"additionalProperties": false
},
{
"$ref": "#/$defs/CollectCondition"
},
{
"$ref": "#/$defs/AdvancedContractCondition"
},
{
"$ref": "#/$defs/EoaOwnershipCondition"
},
{
"$ref": "#/$defs/Erc20OwnershipCondition"
},
{
"$ref": "#/$defs/FollowCondition"
},
{
"$ref": "#/$defs/NftOwnershipCondition"
},
{
"type": "object",
"required": [
"criteria",
"type"
],
"properties": {
"criteria": {
"type": "array",
"items": {
"anyOf": [
{
"$ref": "#/$defs/NftOwnershipCondition"
},
{
"$ref": "#/$defs/Erc20OwnershipCondition"
},
{
"$ref": "#/$defs/EoaOwnershipCondition"
},
{
"$ref": "#/$defs/ProfileOwnershipCondition"
},
{
"$ref": "#/$defs/FollowCondition"
},
{
"$ref": "#/$defs/CollectCondition"
},
{
"$ref": "#/$defs/AdvancedContractCondition"
}
]
},
"maxItems": 5
},
"type": {
"type": "string",
"const": "OR"
}
},
"additionalProperties": false
},
{
"$ref": "#/$defs/ProfileOwnershipCondition"
}
]
}
```
</details>
"""
union AnyAccessCondition = BooleanAndCondition | BooleanOrCondition | CollectCondition | AdvancedContractCondition | EoaOwnershipCondition | Erc20OwnershipCondition | FollowCondition | NftOwnershipCondition | ProfileOwnershipCondition

"""
AnyMedia

<details><summary>JSON schema</summary>

```json
{
"anyOf": [
{
"$ref": "#/$defs/MediaAudio"
},
{
"$ref": "#/$defs/MediaImage"
},
{
"$ref": "#/$defs/MediaVideo"
}
]
}
```
</details>
"""
union AnyMedia = MediaAudio | MediaImage | MediaVideo

union AnyPost = Post | Repost

type App {
  address: EvmAddress!
  graphAddress: EvmAddress
  sponsorshipAddress: EvmAddress
  defaultFeedAddress: EvmAddress
  usernameAddress: EvmAddress
  treasuryAddress: EvmAddress
  createdAt: DateTime!
  metadata: AppMetadata
}

scalar AppId

"""
AppMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"lens",
"schema"
],
"properties": {
"lens": {
"type": "object",
"required": [
"developer",
"name",
"platforms",
"url"
],
"properties": {
"description": {
"description": "An optional short and detailed description of the app, explaining its features and purpose.",
"anyOf": [
{
"$ref": "#/$defs/Markdown"
},
{
"type": "null"
}
]
},
"developer": {
"description": "The Developer of the app.",
"$ref": "#/$defs/NonEmptyString"
},
"logo": {
"description": "The Logo icon for the app.",
"anyOf": [
{
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"name": {
"description": "The name of the app.",
"$ref": "#/$defs/NonEmptyString"
},
"platforms": {
"description": "The platforms supported by the app.",
"type": "array",
"items": {
"type": "string",
"enum": [
"web",
"ios",
"android"
]
}
},
"privacyPolicy": {
"description": "The privacy policy for the app.",
"anyOf": [
{
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"termsOfService": {
"description": "The terms of service for the app.",
"anyOf": [
{
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"url": {
"description": "The url of the app.",
"type": "string",
"format": "uri"
}
},
"additionalProperties": false
},
"schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/app/1.0.0.json"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": false
}
```
</details>
"""
type AppMetadata {
  lens: AppMetadataLens!
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
AppMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"developer",
"name",
"platforms",
"url"
],
"properties": {
"description": {
"description": "An optional short and detailed description of the app, explaining its features and purpose.",
"anyOf": [
{
"$ref": "#/$defs/Markdown"
},
{
"type": "null"
}
]
},
"developer": {
"description": "The Developer of the app.",
"$ref": "#/$defs/NonEmptyString"
},
"logo": {
"description": "The Logo icon for the app.",
"anyOf": [
{
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"name": {
"description": "The name of the app.",
"$ref": "#/$defs/NonEmptyString"
},
"platforms": {
"description": "The platforms supported by the app.",
"type": "array",
"items": {
"type": "string",
"enum": [
"web",
"ios",
"android"
]
}
},
"privacyPolicy": {
"description": "The privacy policy for the app.",
"anyOf": [
{
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"termsOfService": {
"description": "The terms of service for the app.",
"anyOf": [
{
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"url": {
"description": "The url of the app.",
"type": "string",
"format": "uri"
}
},
"additionalProperties": false
}
```
</details>
"""
type AppMetadataLens {
  """
  An optional short and detailed description of the app, explaining its features and purpose.
  """
  description: NonEmptyString

  """The Developer of the app."""
  developer: NonEmptyString!

  """The Logo icon for the app."""
  logo: URI

  """The name of the app."""
  name: NonEmptyString!

  """The platforms supported by the app."""
  platforms: [AppMetadataLensPlatformsItem!]!

  """The privacy policy for the app."""
  privacyPolicy: URI

  """The terms of service for the app."""
  termsOfService: URI

  """The url of the app."""
  url: String!
}

"""
AppMetadataLensPlatformsItem

<details><summary>JSON schema</summary>

```json
{
"type": "string",
"enum": [
"web",
"ios",
"android"
]
}
```
</details>
"""
enum AppMetadataLensPlatformsItem {
  WEB
  IOS
  ANDROID
}

input AppRequest {
  app: EvmAddress!
}

enum AppsOrderBy {
  ALPHABETICAL
  LATEST_FIRST
  OLDEST_FIRST
}

input AppsRequest {
  pageSize: PageSize
  cursor: Cursor
  orderBy: AppsOrderBy! = LATEST_FIRST
}

"""
ArticleMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/article/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"content",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "Any attachment you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "ARTICLE"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The optional article title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type ArticleMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: ArticleMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
ArticleMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"content",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "Any attachment you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "ARTICLE"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The optional article title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
```
</details>
"""
type ArticleMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """Any attachment you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  content: Encryptable!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional article title."""
  title: NonEmptyString
}

union Asset = Erc20

type AssignUsernameToAccountError {
  error: AssignUsernameToAccountErrorType!
}

enum AssignUsernameToAccountErrorType {
  UNKNOWN
  USERNAME_ALREADY_ASSIGNED
  INVALID_USERNAME
  UNAUTHORIZED
}

input AssignUsernameToAccountRequest {
  usernameAddress: EvmAddress!
  accountUsernameId: String!
}

union AssignUsernameToAccountResult = OptimisticAssignUsernameToAccount | SponsoredTransactionRequest | TransactionRequest | AssignUsernameToAccountError

"""
AudioMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/audio/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"audio",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"audio": {
"$ref": "#/$defs/MediaAudio"
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "AUDIO"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The optional audio title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type AudioMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: AudioMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
AudioMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"audio",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"audio": {
"$ref": "#/$defs/MediaAudio"
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "AUDIO"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The optional audio title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
```
</details>
"""
type AudioMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  audio: MediaAudio!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional audio title."""
  title: NonEmptyString
}

type AuthenticationChallenge {
  id: UUID!
  text: String!
  app: App!
}

union AuthenticationResult = AuthenticationTokens | WrongSignerError | ExpiredChallengeError | ForbiddenError

type AuthenticationTokens {
  accessToken: AccessToken!
  refreshToken: RefreshToken!
  identityToken: IdToken!
}

scalar BigDecimal

scalar BigInt

type BlockError {
  error: BlockErrorType!
}

enum BlockErrorType {
  UNKNOWN
  ALREADY_BLOCKED
  UNAUTHORIZED
}

input BlockRequest {
  account: EvmAddress!
}

union BlockResult = OptimisticBlock | SponsoredTransactionRequest | TransactionRequest | BlockError

scalar BlockchainData

input BookmarkPostRequest {
  postId: PostId!
}

type BooleanAndCondition {
  criteria: [AccessConditionType!]!
  type: String!
}

type BooleanAttribute {
  """The attribute's unique identifier."""
  key: NonEmptyString!

  """
  A JS boolean value serialized as string. It's consumer responsibility to parse it.
  """
  value: BooleanString!
}

type BooleanOrCondition {
  criteria: [AccessConditionType!]!
  type: String!
}

scalar BooleanString

type BooleanValue {
  optimistic: Boolean!
  onChain: Boolean!
}

input CanFollowRequest {
  appOrGraph: EvmAddress!
}

input CanUnfollowRequest {
  appOrGraph: EvmAddress!
}

scalar ChainId

input ChallengeRequest {
  account: EvmAddress!
  app: EvmAddress!
  signedBy: EvmAddress!
}

"""
CheckingInMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/checking-in/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"id",
"locale",
"location",
"mainContentFocus"
],
"properties": {
"address": {
"description": "The optional address of the location.",
"$ref": "#/$defs/PhysicalAddress"
},
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"location": {
"description": "Where you checking in from (free form text).",
"$ref": "#/$defs/EncryptableString"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "CHECKING_IN"
},
"position": {
"description": "The optional geographic position of the location.",
"$ref": "#/$defs/EncryptableGeoURI"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type CheckingInMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: CheckingInMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
CheckingInMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"id",
"locale",
"location",
"mainContentFocus"
],
"properties": {
"address": {
"description": "The optional address of the location.",
"$ref": "#/$defs/PhysicalAddress"
},
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"location": {
"description": "Where you checking in from (free form text).",
"$ref": "#/$defs/EncryptableString"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "CHECKING_IN"
},
"position": {
"description": "The optional geographic position of the location.",
"$ref": "#/$defs/EncryptableGeoURI"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
}
```
</details>
"""
type CheckingInMetadataLens {
  """The optional address of the location."""
  address: PhysicalAddress

  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """Where you checking in from (free form text)."""
  location: Encryptable!

  """The main focus of the publication."""
  mainContentFocus: String!

  """The optional geographic position of the location."""
  position: Encryptable

  """An arbitrary list of tags."""
  tags: [Tag!]
}

input CollectActionInput {
  simpleCollectAction: SimpleCollectActionInput
}

"""
CollectCondition

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"publicationId",
"type"
],
"properties": {
"publicationId": {
"$ref": "#/$defs/PublicationId"
},
"thisPublication": {
"default": false,
"type": "boolean"
},
"type": {
"type": "string",
"const": "COLLECT"
}
},
"additionalProperties": false
}
```
</details>
"""
type CollectCondition {
  publicationId: PostId!
  thisPublication: Boolean!
  type: String!
}

"""
Specify a content warning.

<details><summary>JSON schema</summary>

```json
{
"description": "Specify a content warning.",
"type": "string",
"enum": [
"NSFW",
"SENSITIVE",
"SPOILER"
]
}
```
</details>
"""
enum ContentWarning {
  NSFW
  SENSITIVE
  SPOILER
}

input CreateAccountFollowRuleRequest {
  account: EvmAddress!
  graph: EvmAddress
  rule: FollowRulesInput!
}

input CreateFollowRequest {
  """The account to follow."""
  account: EvmAddress!

  """
  The graph to follow the account on. If not provided, the global graph is used.
  """
  graph: EvmAddress! = "0x7bE2cA3B7be499546f3f31605f4818D70d14439A"

  """
  The data required by any follow rules associated with the account being followed.
  """
  followRule: FollowRulesInput

  """
  The data required by the graph rules associated with the specified graph.
  """
  graphRule: GraphRulesInput
}

type CreateFrameEIP712TypedData {
  types: CreateFrameEIP712TypedDataTypes!
  domain: Eip712TypedDataDomain!
  value: CreateFrameEIP712TypedDataValue!
}

input CreateFrameEIP712TypedDataInput {
  types: CreateFrameEIP712TypedDataTypesInput!
  domain: Eip712TypedDataDomainInput!
  value: CreateFrameEIP712TypedDataValueInput!
}

type CreateFrameEIP712TypedDataTypes {
  frameData: [Eip712TypedDataField!]!
}

input CreateFrameEIP712TypedDataTypesInput {
  frameData: [Eip712TypedDataFieldInput!]!
}

type CreateFrameEIP712TypedDataValue {
  specVersion: String!
  url: URI!
  buttonIndex: Int!
  account: EvmAddress!
  postId: PostId!
  inputText: String!
  state: String!
  actionResponse: String!
  deadline: Int!
}

input CreateFrameEIP712TypedDataValueInput {
  specVersion: String!
  url: URI!
  buttonIndex: Int!
  account: EvmAddress!
  postId: PostId!
  inputText: String!
  state: String!
  actionResponse: String!
  deadline: Int!
}

input CreatePostRequest {
  """The feed to post to. If not provided, the global feed is used."""
  feed: EvmAddress! = "0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"

  """The URI of the post metadata."""
  contentUri: URI!

  """The post to quote, if any."""
  quoteOf: ReferencingPostInput

  """The post to comment on, if any."""
  commentOn: ReferencingPostInput

  """The actions to attach to the post."""
  actions: [PostActionInput!]
}

input CreateRepostRequest {
  """The feed to repost to. If not provided, the global feed is used."""
  feed: EvmAddress! = "0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"

  """The post to reference."""
  post: PostId!
}

input CreateUnfollowRequest {
  """The account to unfollow."""
  account: EvmAddress!

  """
  The graph where the account is followed and should be unfollowed.
  If not provided, the global graph is used.
  """
  graph: EvmAddress! = "0x7bE2cA3B7be499546f3f31605f4818D70d14439A"

  """
  The data required by the graph rules associated with the specified graph.
  """
  graphRule: GraphRulesInput
}

input CurrencyRequest {
  limit: Int
  cursor: Cursor
  verified: Boolean
}

scalar Cursor

type DateAttribute {
  """The attribute's unique identifier."""
  key: NonEmptyString!

  """
  A valid ISO 8601 date string.  It's consumer responsibility to parse it.
  """
  value: DateTime!
}

scalar DateTime

input DebugPostMetadataRequest {
  rawUri: URI
  json: String
  source: EntityType!
}

type DebugPostMetadataResult {
  valid: Boolean!
  reason: String
}

input DebugTransactionStatusRequest {
  txHash: TxHash!
}

type DebugTransactionStatusResult {
  blockExplorer: URI
  reason: String!
}

input DeletePostRequest {
  """The post to delete."""
  post: PostId!

  """If needed, the feed rule data required to accomplish the deletion."""
  feedRules: FeedRulesInput
}

type DeletePostResponse {
  hash: TxHash!
}

union DeletePostResult = DeletePostResponse | SponsoredTransactionRequest | TransactionRequest | TransactionWillFail

input DismissRecommendedAccountsRequest {
  accounts: [EvmAddress!]!
}

type DisputedReport {
  createdAt: DateTime!
  reporter: Account!
  reportedAccount: Account!
  reportReason: String!
  reportSubreason: String!
  reportAdditionalInfo: String!
  reportedPost: Post
  disputer: Account!
  disputeReason: String!
}

input EditPostRequest {
  post: PostId!
  contentUri: URI!
}

type Eip1559TransactionRequest {
  """The transaction type: 2 for EIP-1559 transactions."""
  type: Int!

  """The target of the transaction."""
  to: EvmAddress!

  """The nonce of the transaction, used to prevent replay attacks."""
  nonce: Int!

  """The maximum amount of gas to allow this transaction to consume."""
  gasLimit: Int!

  """The EIP_1559 maximum priority fee to pay per gas."""
  maxPriorityFeePerGas: BigInt!

  """
  The EIP_1559 maximum total fee to pay per gas. The actual
  value used is protocol enforced to be the block's base fee.
  """
  maxFeePerGas: BigInt!

  """The transaction data."""
  data: BlockchainData!

  """The transaction value (in wei)."""
  value: BigInt

  """The chain ID for the network this transaction is valid on."""
  chainId: Int!
}

"""Contains EIP-712 transaction metadata."""
type Eip712Meta {
  """
  The maximum amount of gas the user is willing to pay for a single byte of pubdata.
  """
  gasPerPubdata: BigInt!

  """
  An array of bytes containing the bytecode of the contract being deployed and any related
  contracts it can deploy.
  """
  factoryDeps: [BlockchainData!]!

  """
  Custom signature used for cases where the signer's account is not an EOA.
  """
  customSignature: BlockchainData

  """Parameters for configuring the custom paymaster for the transaction."""
  paymasterParams: PaymasterParams
}

type Eip712TransactionRequest {
  """The transaction type: 113 for EIP-712 transactions."""
  type: Int!

  """The target of the transaction."""
  to: EvmAddress!

  """The sender of the transaction."""
  from: EvmAddress!

  """The nonce of the transaction, used to prevent replay attacks."""
  nonce: Int!

  """The maximum amount of gas to allow this transaction to consume."""
  gasLimit: Int!

  """The gas price to use."""
  gasPrice: BigInt!

  """The transaction data."""
  data: BlockchainData!

  """The transaction value (in wei)."""
  value: BigInt

  """The chain ID for the network this transaction is valid on."""
  chainId: Int!

  """The custom data for EIP-712 transaction metadata."""
  customData: Eip712Meta!
}

type Eip712TypedDataDomain {
  name: String!
  chainId: Int!
  version: String!
  verifyingContract: EvmAddress!
}

input Eip712TypedDataDomainInput {
  name: String!
  chainId: Int!
  version: String!
  verifyingContract: EvmAddress!
}

type Eip712TypedDataField {
  name: String!
  type: String!
}

input Eip712TypedDataFieldInput {
  name: String!
  type: String!
}

"""
EmbedMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/embed/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"embed",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"embed": {
"description": "The embed URL.",
"$ref": "#/$defs/EncryptableUri"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "EMBED"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type EmbedMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: EmbedMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
EmbedMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"embed",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"embed": {
"description": "The embed URL.",
"$ref": "#/$defs/EncryptableUri"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "EMBED"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
}
```
</details>
"""
type EmbedMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning

  """The embed URL."""
  embed: Encryptable!
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

scalar EncodedTransaction

scalar Encryptable

scalar EncryptionKey

"""
PublicationEncryptionStrategy

<details><summary>JSON schema</summary>

```json
{
"anyOf": [
{
"description": "Publication encryption strategy powered by the LIT Protocol.",
"type": "object",
"required": [
"accessCondition",
"encryptedPaths",
"encryptionKey",
"provider"
],
"properties": {
"accessCondition": {
"$ref": "#/$defs/AccessCondition"
},
"encryptedPaths": {
"type": "array",
"items": {
"description": "An encrypted path is a string of keys separated by . that describe a path to a value in a JSON object (e.g. lens.attachments.0.item.url, lens.content).",
"type": "string",
"minLength": 1
},
"minItems": 1
},
"encryptionKey": {
"description": "A symmetric encryption key.",
"type": "string",
"maxLength": 368,
"minLength": 368
},
"provider": {
"type": "string",
"const": "LIT_PROTOCOL"
}
},
"additionalProperties": false
}
]
}
```
</details>
"""
union EncryptionStrategy = LitProtocolEncryptionStrategy

enum EntityType {
  ACCOUNT
  GRAPH
  FEED
  USERNAME
  GROUP
  POST
  APP
  SPONSORSHIP
}

"""
EoaOwnershipCondition

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"address",
"type"
],
"properties": {
"address": {
"$ref": "#/$defs/EvmAddress"
},
"type": {
"type": "string",
"const": "EOA_OWNERSHIP"
}
},
"additionalProperties": false
}
```
</details>
"""
type EoaOwnershipCondition {
  address: EvmAddress!
  type: String!
}

type Erc20 {
  name: String!
  symbol: String!
  decimals: Int!
  contract: NetworkAddress!
}

"""
Erc20OwnershipCondition

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"amount",
"condition",
"type"
],
"properties": {
"amount": {
"$ref": "#/$defs/Amount"
},
"condition": {
"type": "string",
"enum": [
"EQUAL",
"NOT_EQUAL",
"GREATER_THAN",
"GREATER_THAN_OR_EQUAL",
"LESS_THAN",
"LESS_THAN_OR_EQUAL"
]
},
"type": {
"type": "string",
"const": "ERC20_OWNERSHIP"
}
},
"additionalProperties": false
}
```
</details>
"""
type Erc20OwnershipCondition {
  amount: Amount!
  condition: AccessConditionComparison!
  type: String!
}

"""
EventMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/event/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"endsAt",
"id",
"locale",
"location",
"mainContentFocus",
"startsAt"
],
"properties": {
"address": {
"description": "The address of the event.",
"$ref": "#/$defs/PhysicalAddress"
},
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"endsAt": {
"description": "The event end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`).",
"$ref": "#/$defs/EncryptableDateTime"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"links": {
"description": "The links you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/EncryptableUri"
},
"minItems": 1
},
"locale": {
"$ref": "#/$defs/Locale"
},
"location": {
"description": "The location of the event.",
"anyOf": [
{
"description": "A virtual location.",
"$ref": "#/$defs/EncryptableUri"
},
{
"description": "The event location (free form text).",
"$ref": "#/$defs/EncryptableString"
}
]
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "EVENT"
},
"position": {
"description": "The geographic position of the event.",
"$ref": "#/$defs/EncryptableGeoURI"
},
"schedulingAdjustments": {
"description": "Captures extra criteria to recompute correctly future start and end times.See: https://www.w3.org/International/wiki/WorkingWithTimeZones#Working_with_Future_and_Recurring_Events",
"type": "object",
"required": [
"timezoneId",
"timezoneOffset"
],
"properties": {
"timezoneId": {
"description": "Indicates a reference timezone for the event start and end times. If physical event, you could use the timezone of the event location. If virtual event, the timezone of the event organizer.",
"type": "string",
"enum": [
"Africa/Abidjan",
"Africa/Accra",
"Africa/Addis_Ababa",
"Africa/Algiers",
"Africa/Asmera",
"Africa/Bamako",
"Africa/Bangui",
"Africa/Banjul",
"Africa/Bissau",
"Africa/Blantyre",
"Africa/Brazzaville",
"Africa/Bujumbura",
"Africa/Cairo",
"Africa/Casablanca",
"Africa/Ceuta",
"Africa/Conakry",
"Africa/Dakar",
"Africa/Dar_es_Salaam",
"Africa/Djibouti",
"Africa/Douala",
"Africa/El_Aaiun",
"Africa/Freetown",
"Africa/Gaborone",
"Africa/Harare",
"Africa/Johannesburg",
"Africa/Juba",
"Africa/Kampala",
"Africa/Khartoum",
"Africa/Kigali",
"Africa/Kinshasa",
"Africa/Lagos",
"Africa/Libreville",
"Africa/Lome",
"Africa/Luanda",
"Africa/Lubumbashi",
"Africa/Lusaka",
"Africa/Malabo",
"Africa/Maputo",
"Africa/Maseru",
"Africa/Mbabane",
"Africa/Mogadishu",
"Africa/Monrovia",
"Africa/Nairobi",
"Africa/Ndjamena",
"Africa/Niamey",
"Africa/Nouakchott",
"Africa/Ouagadougou",
"Africa/Porto-Novo",
"Africa/Sao_Tome",
"Africa/Tripoli",
"Africa/Tunis",
"Africa/Windhoek",
"America/Adak",
"America/Anchorage",
"America/Anguilla",
"America/Antigua",
"America/Araguaina",
"America/Argentina/La_Rioja",
"America/Argentina/Rio_Gallegos",
"America/Argentina/Salta",
"America/Argentina/San_Juan",
"America/Argentina/San_Luis",
"America/Argentina/Tucuman",
"America/Argentina/Ushuaia",
"America/Aruba",
"America/Asuncion",
"America/Bahia",
"America/Bahia_Banderas",
"America/Barbados",
"America/Belem",
"America/Belize",
"America/Blanc-Sablon",
"America/Boa_Vista",
"America/Bogota",
"America/Boise",
"America/Buenos_Aires",
"America/Cambridge_Bay",
"America/Campo_Grande",
"America/Cancun",
"America/Caracas",
"America/Catamarca",
"America/Cayenne",
"America/Cayman",
"America/Chicago",
"America/Chihuahua",
"America/Ciudad_Juarez",
"America/Coral_Harbour",
"America/Cordoba",
"America/Costa_Rica",
"America/Creston",
"America/Cuiaba",
"America/Curacao",
"America/Danmarkshavn",
"America/Dawson",
"America/Dawson_Creek",
"America/Denver",
"America/Detroit",
"America/Dominica",
"America/Edmonton",
"America/Eirunepe",
"America/El_Salvador",
"America/Fort_Nelson",
"America/Fortaleza",
"America/Glace_Bay",
"America/Godthab",
"America/Goose_Bay",
"America/Grand_Turk",
"America/Grenada",
"America/Guadeloupe",
"America/Guatemala",
"America/Guayaquil",
"America/Guyana",
"America/Halifax",
"America/Havana",
"America/Hermosillo",
"America/Indiana/Knox",
"America/Indiana/Marengo",
"America/Indiana/Petersburg",
"America/Indiana/Tell_City",
"America/Indiana/Vevay",
"America/Indiana/Vincennes",
"America/Indiana/Winamac",
"America/Indianapolis",
"America/Inuvik",
"America/Iqaluit",
"America/Jamaica",
"America/Jujuy",
"America/Juneau",
"America/Kentucky/Monticello",
"America/Kralendijk",
"America/La_Paz",
"America/Lima",
"America/Los_Angeles",
"America/Louisville",
"America/Lower_Princes",
"America/Maceio",
"America/Managua",
"America/Manaus",
"America/Marigot",
"America/Martinique",
"America/Matamoros",
"America/Mazatlan",
"America/Mendoza",
"America/Menominee",
"America/Merida",
"America/Metlakatla",
"America/Mexico_City",
"America/Miquelon",
"America/Moncton",
"America/Monterrey",
"America/Montevideo",
"America/Montserrat",
"America/Nassau",
"America/New_York",
"America/Nipigon",
"America/Nome",
"America/Noronha",
"America/North_Dakota/Beulah",
"America/North_Dakota/Center",
"America/North_Dakota/New_Salem",
"America/Ojinaga",
"America/Panama",
"America/Pangnirtung",
"America/Paramaribo",
"America/Phoenix",
"America/Port-au-Prince",
"America/Port_of_Spain",
"America/Porto_Velho",
"America/Puerto_Rico",
"America/Punta_Arenas",
"America/Rainy_River",
"America/Rankin_Inlet",
"America/Recife",
"America/Regina",
"America/Resolute",
"America/Rio_Branco",
"America/Santa_Isabel",
"America/Santarem",
"America/Santiago",
"America/Santo_Domingo",
"America/Sao_Paulo",
"America/Scoresbysund",
"America/Sitka",
"America/St_Barthelemy",
"America/St_Johns",
"America/St_Kitts",
"America/St_Lucia",
"America/St_Thomas",
"America/St_Vincent",
"America/Swift_Current",
"America/Tegucigalpa",
"America/Thule",
"America/Thunder_Bay",
"America/Tijuana",
"America/Toronto",
"America/Tortola",
"America/Vancouver",
"America/Whitehorse",
"America/Winnipeg",
"America/Yakutat",
"America/Yellowknife",
"Antarctica/Casey",
"Antarctica/Davis",
"Antarctica/DumontDUrville",
"Antarctica/Macquarie",
"Antarctica/Mawson",
"Antarctica/McMurdo",
"Antarctica/Palmer",
"Antarctica/Rothera",
"Antarctica/Syowa",
"Antarctica/Troll",
"Antarctica/Vostok",
"Arctic/Longyearbyen",
"Asia/Aden",
"Asia/Almaty",
"Asia/Amman",
"Asia/Anadyr",
"Asia/Aqtau",
"Asia/Aqtobe",
"Asia/Ashgabat",
"Asia/Atyrau",
"Asia/Baghdad",
"Asia/Bahrain",
"Asia/Baku",
"Asia/Bangkok",
"Asia/Barnaul",
"Asia/Beirut",
"Asia/Bishkek",
"Asia/Brunei",
"Asia/Calcutta",
"Asia/Chita",
"Asia/Choibalsan",
"Asia/Colombo",
"Asia/Damascus",
"Asia/Dhaka",
"Asia/Dili",
"Asia/Dubai",
"Asia/Dushanbe",
"Asia/Famagusta",
"Asia/Gaza",
"Asia/Hebron",
"Asia/Hong_Kong",
"Asia/Hovd",
"Asia/Irkutsk",
"Asia/Jakarta",
"Asia/Jayapura",
"Asia/Jerusalem",
"Asia/Kabul",
"Asia/Kamchatka",
"Asia/Karachi",
"Asia/Katmandu",
"Asia/Khandyga",
"Asia/Krasnoyarsk",
"Asia/Kuala_Lumpur",
"Asia/Kuching",
"Asia/Kuwait",
"Asia/Macau",
"Asia/Magadan",
"Asia/Makassar",
"Asia/Manila",
"Asia/Muscat",
"Asia/Nicosia",
"Asia/Novokuznetsk",
"Asia/Novosibirsk",
"Asia/Omsk",
"Asia/Oral",
"Asia/Phnom_Penh",
"Asia/Pontianak",
"Asia/Pyongyang",
"Asia/Qatar",
"Asia/Qostanay",
"Asia/Qyzylorda",
"Asia/Rangoon",
"Asia/Riyadh",
"Asia/Saigon",
"Asia/Sakhalin",
"Asia/Samarkand",
"Asia/Seoul",
"Asia/Shanghai",
"Asia/Singapore",
"Asia/Srednekolymsk",
"Asia/Taipei",
"Asia/Tashkent",
"Asia/Tbilisi",
"Asia/Tehran",
"Asia/Thimphu",
"Asia/Tokyo",
"Asia/Tomsk",
"Asia/Ulaanbaatar",
"Asia/Urumqi",
"Asia/Ust-Nera",
"Asia/Vientiane",
"Asia/Vladivostok",
"Asia/Yakutsk",
"Asia/Yekaterinburg",
"Asia/Yerevan",
"Atlantic/Azores",
"Atlantic/Bermuda",
"Atlantic/Canary",
"Atlantic/Cape_Verde",
"Atlantic/Faeroe",
"Atlantic/Madeira",
"Atlantic/Reykjavik",
"Atlantic/South_Georgia",
"Atlantic/St_Helena",
"Atlantic/Stanley",
"Australia/Adelaide",
"Australia/Brisbane",
"Australia/Broken_Hill",
"Australia/Currie",
"Australia/Darwin",
"Australia/Eucla",
"Australia/Hobart",
"Australia/Lindeman",
"Australia/Lord_Howe",
"Australia/Melbourne",
"Australia/Perth",
"Australia/Sydney",
"Europe/Amsterdam",
"Europe/Andorra",
"Europe/Astrakhan",
"Europe/Athens",
"Europe/Belgrade",
"Europe/Berlin",
"Europe/Bratislava",
"Europe/Brussels",
"Europe/Bucharest",
"Europe/Budapest",
"Europe/Busingen",
"Europe/Chisinau",
"Europe/Copenhagen",
"Europe/Dublin",
"Europe/Gibraltar",
"Europe/Guernsey",
"Europe/Helsinki",
"Europe/Isle_of_Man",
"Europe/Istanbul",
"Europe/Jersey",
"Europe/Kaliningrad",
"Europe/Kiev",
"Europe/Kirov",
"Europe/Lisbon",
"Europe/Ljubljana",
"Europe/London",
"Europe/Luxembourg",
"Europe/Madrid",
"Europe/Malta",
"Europe/Mariehamn",
"Europe/Minsk",
"Europe/Monaco",
"Europe/Moscow",
"Europe/Oslo",
"Europe/Paris",
"Europe/Podgorica",
"Europe/Prague",
"Europe/Riga",
"Europe/Rome",
"Europe/Samara",
"Europe/San_Marino",
"Europe/Sarajevo",
"Europe/Saratov",
"Europe/Simferopol",
"Europe/Skopje",
"Europe/Sofia",
"Europe/Stockholm",
"Europe/Tallinn",
"Europe/Tirane",
"Europe/Ulyanovsk",
"Europe/Uzhgorod",
"Europe/Vaduz",
"Europe/Vatican",
"Europe/Vienna",
"Europe/Vilnius",
"Europe/Volgograd",
"Europe/Warsaw",
"Europe/Zagreb",
"Europe/Zaporozhye",
"Europe/Zurich",
"Indian/Antananarivo",
"Indian/Chagos",
"Indian/Christmas",
"Indian/Cocos",
"Indian/Comoro",
"Indian/Kerguelen",
"Indian/Mahe",
"Indian/Maldives",
"Indian/Mauritius",
"Indian/Mayotte",
"Indian/Reunion",
"Pacific/Apia",
"Pacific/Auckland",
"Pacific/Bougainville",
"Pacific/Chatham",
"Pacific/Easter",
"Pacific/Efate",
"Pacific/Enderbury",
"Pacific/Fakaofo",
"Pacific/Fiji",
"Pacific/Funafuti",
"Pacific/Galapagos",
"Pacific/Gambier",
"Pacific/Guadalcanal",
"Pacific/Guam",
"Pacific/Honolulu",
"Pacific/Johnston",
"Pacific/Kiritimati",
"Pacific/Kosrae",
"Pacific/Kwajalein",
"Pacific/Majuro",
"Pacific/Marquesas",
"Pacific/Midway",
"Pacific/Nauru",
"Pacific/Niue",
"Pacific/Norfolk",
"Pacific/Noumea",
"Pacific/Pago_Pago",
"Pacific/Palau",
"Pacific/Pitcairn",
"Pacific/Ponape",
"Pacific/Port_Moresby",
"Pacific/Rarotonga",
"Pacific/Saipan",
"Pacific/Tahiti",
"Pacific/Tarawa",
"Pacific/Tongatapu",
"Pacific/Truk",
"Pacific/Wake",
"Pacific/Wallis"
]
},
"timezoneOffset": {
"description": "Indicates the reference timezone offset with respect to UTC timezone a the time of event creation. The difference in minutes between the reference timezone time and UTC time (e.g. UTC+2 would be -120, UTC-5 would be 300, UTC would be 0).",
"type": "number"
}
},
"additionalProperties": false
},
"startsAt": {
"description": "The event start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`).",
"$ref": "#/$defs/EncryptableDateTime"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The title of the event.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type EventMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: EventMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
EventMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"endsAt",
"id",
"locale",
"location",
"mainContentFocus",
"startsAt"
],
"properties": {
"address": {
"description": "The address of the event.",
"$ref": "#/$defs/PhysicalAddress"
},
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"endsAt": {
"description": "The event end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`).",
"$ref": "#/$defs/EncryptableDateTime"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"links": {
"description": "The links you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/EncryptableUri"
},
"minItems": 1
},
"locale": {
"$ref": "#/$defs/Locale"
},
"location": {
"description": "The location of the event.",
"anyOf": [
{
"description": "A virtual location.",
"$ref": "#/$defs/EncryptableUri"
},
{
"description": "The event location (free form text).",
"$ref": "#/$defs/EncryptableString"
}
]
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "EVENT"
},
"position": {
"description": "The geographic position of the event.",
"$ref": "#/$defs/EncryptableGeoURI"
},
"schedulingAdjustments": {
"description": "Captures extra criteria to recompute correctly future start and end times.See: https://www.w3.org/International/wiki/WorkingWithTimeZones#Working_with_Future_and_Recurring_Events",
"type": "object",
"required": [
"timezoneId",
"timezoneOffset"
],
"properties": {
"timezoneId": {
"description": "Indicates a reference timezone for the event start and end times. If physical event, you could use the timezone of the event location. If virtual event, the timezone of the event organizer.",
"type": "string",
"enum": [
"Africa/Abidjan",
"Africa/Accra",
"Africa/Addis_Ababa",
"Africa/Algiers",
"Africa/Asmera",
"Africa/Bamako",
"Africa/Bangui",
"Africa/Banjul",
"Africa/Bissau",
"Africa/Blantyre",
"Africa/Brazzaville",
"Africa/Bujumbura",
"Africa/Cairo",
"Africa/Casablanca",
"Africa/Ceuta",
"Africa/Conakry",
"Africa/Dakar",
"Africa/Dar_es_Salaam",
"Africa/Djibouti",
"Africa/Douala",
"Africa/El_Aaiun",
"Africa/Freetown",
"Africa/Gaborone",
"Africa/Harare",
"Africa/Johannesburg",
"Africa/Juba",
"Africa/Kampala",
"Africa/Khartoum",
"Africa/Kigali",
"Africa/Kinshasa",
"Africa/Lagos",
"Africa/Libreville",
"Africa/Lome",
"Africa/Luanda",
"Africa/Lubumbashi",
"Africa/Lusaka",
"Africa/Malabo",
"Africa/Maputo",
"Africa/Maseru",
"Africa/Mbabane",
"Africa/Mogadishu",
"Africa/Monrovia",
"Africa/Nairobi",
"Africa/Ndjamena",
"Africa/Niamey",
"Africa/Nouakchott",
"Africa/Ouagadougou",
"Africa/Porto-Novo",
"Africa/Sao_Tome",
"Africa/Tripoli",
"Africa/Tunis",
"Africa/Windhoek",
"America/Adak",
"America/Anchorage",
"America/Anguilla",
"America/Antigua",
"America/Araguaina",
"America/Argentina/La_Rioja",
"America/Argentina/Rio_Gallegos",
"America/Argentina/Salta",
"America/Argentina/San_Juan",
"America/Argentina/San_Luis",
"America/Argentina/Tucuman",
"America/Argentina/Ushuaia",
"America/Aruba",
"America/Asuncion",
"America/Bahia",
"America/Bahia_Banderas",
"America/Barbados",
"America/Belem",
"America/Belize",
"America/Blanc-Sablon",
"America/Boa_Vista",
"America/Bogota",
"America/Boise",
"America/Buenos_Aires",
"America/Cambridge_Bay",
"America/Campo_Grande",
"America/Cancun",
"America/Caracas",
"America/Catamarca",
"America/Cayenne",
"America/Cayman",
"America/Chicago",
"America/Chihuahua",
"America/Ciudad_Juarez",
"America/Coral_Harbour",
"America/Cordoba",
"America/Costa_Rica",
"America/Creston",
"America/Cuiaba",
"America/Curacao",
"America/Danmarkshavn",
"America/Dawson",
"America/Dawson_Creek",
"America/Denver",
"America/Detroit",
"America/Dominica",
"America/Edmonton",
"America/Eirunepe",
"America/El_Salvador",
"America/Fort_Nelson",
"America/Fortaleza",
"America/Glace_Bay",
"America/Godthab",
"America/Goose_Bay",
"America/Grand_Turk",
"America/Grenada",
"America/Guadeloupe",
"America/Guatemala",
"America/Guayaquil",
"America/Guyana",
"America/Halifax",
"America/Havana",
"America/Hermosillo",
"America/Indiana/Knox",
"America/Indiana/Marengo",
"America/Indiana/Petersburg",
"America/Indiana/Tell_City",
"America/Indiana/Vevay",
"America/Indiana/Vincennes",
"America/Indiana/Winamac",
"America/Indianapolis",
"America/Inuvik",
"America/Iqaluit",
"America/Jamaica",
"America/Jujuy",
"America/Juneau",
"America/Kentucky/Monticello",
"America/Kralendijk",
"America/La_Paz",
"America/Lima",
"America/Los_Angeles",
"America/Louisville",
"America/Lower_Princes",
"America/Maceio",
"America/Managua",
"America/Manaus",
"America/Marigot",
"America/Martinique",
"America/Matamoros",
"America/Mazatlan",
"America/Mendoza",
"America/Menominee",
"America/Merida",
"America/Metlakatla",
"America/Mexico_City",
"America/Miquelon",
"America/Moncton",
"America/Monterrey",
"America/Montevideo",
"America/Montserrat",
"America/Nassau",
"America/New_York",
"America/Nipigon",
"America/Nome",
"America/Noronha",
"America/North_Dakota/Beulah",
"America/North_Dakota/Center",
"America/North_Dakota/New_Salem",
"America/Ojinaga",
"America/Panama",
"America/Pangnirtung",
"America/Paramaribo",
"America/Phoenix",
"America/Port-au-Prince",
"America/Port_of_Spain",
"America/Porto_Velho",
"America/Puerto_Rico",
"America/Punta_Arenas",
"America/Rainy_River",
"America/Rankin_Inlet",
"America/Recife",
"America/Regina",
"America/Resolute",
"America/Rio_Branco",
"America/Santa_Isabel",
"America/Santarem",
"America/Santiago",
"America/Santo_Domingo",
"America/Sao_Paulo",
"America/Scoresbysund",
"America/Sitka",
"America/St_Barthelemy",
"America/St_Johns",
"America/St_Kitts",
"America/St_Lucia",
"America/St_Thomas",
"America/St_Vincent",
"America/Swift_Current",
"America/Tegucigalpa",
"America/Thule",
"America/Thunder_Bay",
"America/Tijuana",
"America/Toronto",
"America/Tortola",
"America/Vancouver",
"America/Whitehorse",
"America/Winnipeg",
"America/Yakutat",
"America/Yellowknife",
"Antarctica/Casey",
"Antarctica/Davis",
"Antarctica/DumontDUrville",
"Antarctica/Macquarie",
"Antarctica/Mawson",
"Antarctica/McMurdo",
"Antarctica/Palmer",
"Antarctica/Rothera",
"Antarctica/Syowa",
"Antarctica/Troll",
"Antarctica/Vostok",
"Arctic/Longyearbyen",
"Asia/Aden",
"Asia/Almaty",
"Asia/Amman",
"Asia/Anadyr",
"Asia/Aqtau",
"Asia/Aqtobe",
"Asia/Ashgabat",
"Asia/Atyrau",
"Asia/Baghdad",
"Asia/Bahrain",
"Asia/Baku",
"Asia/Bangkok",
"Asia/Barnaul",
"Asia/Beirut",
"Asia/Bishkek",
"Asia/Brunei",
"Asia/Calcutta",
"Asia/Chita",
"Asia/Choibalsan",
"Asia/Colombo",
"Asia/Damascus",
"Asia/Dhaka",
"Asia/Dili",
"Asia/Dubai",
"Asia/Dushanbe",
"Asia/Famagusta",
"Asia/Gaza",
"Asia/Hebron",
"Asia/Hong_Kong",
"Asia/Hovd",
"Asia/Irkutsk",
"Asia/Jakarta",
"Asia/Jayapura",
"Asia/Jerusalem",
"Asia/Kabul",
"Asia/Kamchatka",
"Asia/Karachi",
"Asia/Katmandu",
"Asia/Khandyga",
"Asia/Krasnoyarsk",
"Asia/Kuala_Lumpur",
"Asia/Kuching",
"Asia/Kuwait",
"Asia/Macau",
"Asia/Magadan",
"Asia/Makassar",
"Asia/Manila",
"Asia/Muscat",
"Asia/Nicosia",
"Asia/Novokuznetsk",
"Asia/Novosibirsk",
"Asia/Omsk",
"Asia/Oral",
"Asia/Phnom_Penh",
"Asia/Pontianak",
"Asia/Pyongyang",
"Asia/Qatar",
"Asia/Qostanay",
"Asia/Qyzylorda",
"Asia/Rangoon",
"Asia/Riyadh",
"Asia/Saigon",
"Asia/Sakhalin",
"Asia/Samarkand",
"Asia/Seoul",
"Asia/Shanghai",
"Asia/Singapore",
"Asia/Srednekolymsk",
"Asia/Taipei",
"Asia/Tashkent",
"Asia/Tbilisi",
"Asia/Tehran",
"Asia/Thimphu",
"Asia/Tokyo",
"Asia/Tomsk",
"Asia/Ulaanbaatar",
"Asia/Urumqi",
"Asia/Ust-Nera",
"Asia/Vientiane",
"Asia/Vladivostok",
"Asia/Yakutsk",
"Asia/Yekaterinburg",
"Asia/Yerevan",
"Atlantic/Azores",
"Atlantic/Bermuda",
"Atlantic/Canary",
"Atlantic/Cape_Verde",
"Atlantic/Faeroe",
"Atlantic/Madeira",
"Atlantic/Reykjavik",
"Atlantic/South_Georgia",
"Atlantic/St_Helena",
"Atlantic/Stanley",
"Australia/Adelaide",
"Australia/Brisbane",
"Australia/Broken_Hill",
"Australia/Currie",
"Australia/Darwin",
"Australia/Eucla",
"Australia/Hobart",
"Australia/Lindeman",
"Australia/Lord_Howe",
"Australia/Melbourne",
"Australia/Perth",
"Australia/Sydney",
"Europe/Amsterdam",
"Europe/Andorra",
"Europe/Astrakhan",
"Europe/Athens",
"Europe/Belgrade",
"Europe/Berlin",
"Europe/Bratislava",
"Europe/Brussels",
"Europe/Bucharest",
"Europe/Budapest",
"Europe/Busingen",
"Europe/Chisinau",
"Europe/Copenhagen",
"Europe/Dublin",
"Europe/Gibraltar",
"Europe/Guernsey",
"Europe/Helsinki",
"Europe/Isle_of_Man",
"Europe/Istanbul",
"Europe/Jersey",
"Europe/Kaliningrad",
"Europe/Kiev",
"Europe/Kirov",
"Europe/Lisbon",
"Europe/Ljubljana",
"Europe/London",
"Europe/Luxembourg",
"Europe/Madrid",
"Europe/Malta",
"Europe/Mariehamn",
"Europe/Minsk",
"Europe/Monaco",
"Europe/Moscow",
"Europe/Oslo",
"Europe/Paris",
"Europe/Podgorica",
"Europe/Prague",
"Europe/Riga",
"Europe/Rome",
"Europe/Samara",
"Europe/San_Marino",
"Europe/Sarajevo",
"Europe/Saratov",
"Europe/Simferopol",
"Europe/Skopje",
"Europe/Sofia",
"Europe/Stockholm",
"Europe/Tallinn",
"Europe/Tirane",
"Europe/Ulyanovsk",
"Europe/Uzhgorod",
"Europe/Vaduz",
"Europe/Vatican",
"Europe/Vienna",
"Europe/Vilnius",
"Europe/Volgograd",
"Europe/Warsaw",
"Europe/Zagreb",
"Europe/Zaporozhye",
"Europe/Zurich",
"Indian/Antananarivo",
"Indian/Chagos",
"Indian/Christmas",
"Indian/Cocos",
"Indian/Comoro",
"Indian/Kerguelen",
"Indian/Mahe",
"Indian/Maldives",
"Indian/Mauritius",
"Indian/Mayotte",
"Indian/Reunion",
"Pacific/Apia",
"Pacific/Auckland",
"Pacific/Bougainville",
"Pacific/Chatham",
"Pacific/Easter",
"Pacific/Efate",
"Pacific/Enderbury",
"Pacific/Fakaofo",
"Pacific/Fiji",
"Pacific/Funafuti",
"Pacific/Galapagos",
"Pacific/Gambier",
"Pacific/Guadalcanal",
"Pacific/Guam",
"Pacific/Honolulu",
"Pacific/Johnston",
"Pacific/Kiritimati",
"Pacific/Kosrae",
"Pacific/Kwajalein",
"Pacific/Majuro",
"Pacific/Marquesas",
"Pacific/Midway",
"Pacific/Nauru",
"Pacific/Niue",
"Pacific/Norfolk",
"Pacific/Noumea",
"Pacific/Pago_Pago",
"Pacific/Palau",
"Pacific/Pitcairn",
"Pacific/Ponape",
"Pacific/Port_Moresby",
"Pacific/Rarotonga",
"Pacific/Saipan",
"Pacific/Tahiti",
"Pacific/Tarawa",
"Pacific/Tongatapu",
"Pacific/Truk",
"Pacific/Wake",
"Pacific/Wallis"
]
},
"timezoneOffset": {
"description": "Indicates the reference timezone offset with respect to UTC timezone a the time of event creation. The difference in minutes between the reference timezone time and UTC time (e.g. UTC+2 would be -120, UTC-5 would be 300, UTC would be 0).",
"type": "number"
}
},
"additionalProperties": false
},
"startsAt": {
"description": "The event start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`).",
"$ref": "#/$defs/EncryptableDateTime"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The title of the event.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
```
</details>
"""
type EventMetadataLens {
  """The address of the event."""
  address: PhysicalAddress

  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """The event end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  endsAt: Encryptable!

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!

  """The links you want to include with it."""
  links: [Encryptable!]!
  locale: Locale!

  """The location of the event."""
  location: EventMetadataLensLocation!

  """The main focus of the publication."""
  mainContentFocus: String!

  """The geographic position of the event."""
  position: Encryptable
  schedulingAdjustments: EventMetadataLensSchedulingAdjustments

  """The event start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The title of the event."""
  title: NonEmptyString
}

"""
The location of the event.

<details><summary>JSON schema</summary>

```json
{
"description": "The location of the event.",
"anyOf": [
{
"description": "A virtual location.",
"$ref": "#/$defs/EncryptableUri"
},
{
"description": "The event location (free form text).",
"$ref": "#/$defs/EncryptableString"
}
]
}
```
</details>
"""
type EventMetadataLensLocation {
  physical: Encryptable
  virtual: Encryptable
}

"""
Captures extra criteria to recompute correctly future start and end times.See: https://www.w3.org/International/wiki/WorkingWithTimeZones#Working_with_Future_and_Recurring_Events

<details><summary>JSON schema</summary>

```json
{
"description": "Captures extra criteria to recompute correctly future start and end times.See: https://www.w3.org/International/wiki/WorkingWithTimeZones#Working_with_Future_and_Recurring_Events",
"type": "object",
"required": [
"timezoneId",
"timezoneOffset"
],
"properties": {
"timezoneId": {
"description": "Indicates a reference timezone for the event start and end times. If physical event, you could use the timezone of the event location. If virtual event, the timezone of the event organizer.",
"type": "string",
"enum": [
"Africa/Abidjan",
"Africa/Accra",
"Africa/Addis_Ababa",
"Africa/Algiers",
"Africa/Asmera",
"Africa/Bamako",
"Africa/Bangui",
"Africa/Banjul",
"Africa/Bissau",
"Africa/Blantyre",
"Africa/Brazzaville",
"Africa/Bujumbura",
"Africa/Cairo",
"Africa/Casablanca",
"Africa/Ceuta",
"Africa/Conakry",
"Africa/Dakar",
"Africa/Dar_es_Salaam",
"Africa/Djibouti",
"Africa/Douala",
"Africa/El_Aaiun",
"Africa/Freetown",
"Africa/Gaborone",
"Africa/Harare",
"Africa/Johannesburg",
"Africa/Juba",
"Africa/Kampala",
"Africa/Khartoum",
"Africa/Kigali",
"Africa/Kinshasa",
"Africa/Lagos",
"Africa/Libreville",
"Africa/Lome",
"Africa/Luanda",
"Africa/Lubumbashi",
"Africa/Lusaka",
"Africa/Malabo",
"Africa/Maputo",
"Africa/Maseru",
"Africa/Mbabane",
"Africa/Mogadishu",
"Africa/Monrovia",
"Africa/Nairobi",
"Africa/Ndjamena",
"Africa/Niamey",
"Africa/Nouakchott",
"Africa/Ouagadougou",
"Africa/Porto-Novo",
"Africa/Sao_Tome",
"Africa/Tripoli",
"Africa/Tunis",
"Africa/Windhoek",
"America/Adak",
"America/Anchorage",
"America/Anguilla",
"America/Antigua",
"America/Araguaina",
"America/Argentina/La_Rioja",
"America/Argentina/Rio_Gallegos",
"America/Argentina/Salta",
"America/Argentina/San_Juan",
"America/Argentina/San_Luis",
"America/Argentina/Tucuman",
"America/Argentina/Ushuaia",
"America/Aruba",
"America/Asuncion",
"America/Bahia",
"America/Bahia_Banderas",
"America/Barbados",
"America/Belem",
"America/Belize",
"America/Blanc-Sablon",
"America/Boa_Vista",
"America/Bogota",
"America/Boise",
"America/Buenos_Aires",
"America/Cambridge_Bay",
"America/Campo_Grande",
"America/Cancun",
"America/Caracas",
"America/Catamarca",
"America/Cayenne",
"America/Cayman",
"America/Chicago",
"America/Chihuahua",
"America/Ciudad_Juarez",
"America/Coral_Harbour",
"America/Cordoba",
"America/Costa_Rica",
"America/Creston",
"America/Cuiaba",
"America/Curacao",
"America/Danmarkshavn",
"America/Dawson",
"America/Dawson_Creek",
"America/Denver",
"America/Detroit",
"America/Dominica",
"America/Edmonton",
"America/Eirunepe",
"America/El_Salvador",
"America/Fort_Nelson",
"America/Fortaleza",
"America/Glace_Bay",
"America/Godthab",
"America/Goose_Bay",
"America/Grand_Turk",
"America/Grenada",
"America/Guadeloupe",
"America/Guatemala",
"America/Guayaquil",
"America/Guyana",
"America/Halifax",
"America/Havana",
"America/Hermosillo",
"America/Indiana/Knox",
"America/Indiana/Marengo",
"America/Indiana/Petersburg",
"America/Indiana/Tell_City",
"America/Indiana/Vevay",
"America/Indiana/Vincennes",
"America/Indiana/Winamac",
"America/Indianapolis",
"America/Inuvik",
"America/Iqaluit",
"America/Jamaica",
"America/Jujuy",
"America/Juneau",
"America/Kentucky/Monticello",
"America/Kralendijk",
"America/La_Paz",
"America/Lima",
"America/Los_Angeles",
"America/Louisville",
"America/Lower_Princes",
"America/Maceio",
"America/Managua",
"America/Manaus",
"America/Marigot",
"America/Martinique",
"America/Matamoros",
"America/Mazatlan",
"America/Mendoza",
"America/Menominee",
"America/Merida",
"America/Metlakatla",
"America/Mexico_City",
"America/Miquelon",
"America/Moncton",
"America/Monterrey",
"America/Montevideo",
"America/Montserrat",
"America/Nassau",
"America/New_York",
"America/Nipigon",
"America/Nome",
"America/Noronha",
"America/North_Dakota/Beulah",
"America/North_Dakota/Center",
"America/North_Dakota/New_Salem",
"America/Ojinaga",
"America/Panama",
"America/Pangnirtung",
"America/Paramaribo",
"America/Phoenix",
"America/Port-au-Prince",
"America/Port_of_Spain",
"America/Porto_Velho",
"America/Puerto_Rico",
"America/Punta_Arenas",
"America/Rainy_River",
"America/Rankin_Inlet",
"America/Recife",
"America/Regina",
"America/Resolute",
"America/Rio_Branco",
"America/Santa_Isabel",
"America/Santarem",
"America/Santiago",
"America/Santo_Domingo",
"America/Sao_Paulo",
"America/Scoresbysund",
"America/Sitka",
"America/St_Barthelemy",
"America/St_Johns",
"America/St_Kitts",
"America/St_Lucia",
"America/St_Thomas",
"America/St_Vincent",
"America/Swift_Current",
"America/Tegucigalpa",
"America/Thule",
"America/Thunder_Bay",
"America/Tijuana",
"America/Toronto",
"America/Tortola",
"America/Vancouver",
"America/Whitehorse",
"America/Winnipeg",
"America/Yakutat",
"America/Yellowknife",
"Antarctica/Casey",
"Antarctica/Davis",
"Antarctica/DumontDUrville",
"Antarctica/Macquarie",
"Antarctica/Mawson",
"Antarctica/McMurdo",
"Antarctica/Palmer",
"Antarctica/Rothera",
"Antarctica/Syowa",
"Antarctica/Troll",
"Antarctica/Vostok",
"Arctic/Longyearbyen",
"Asia/Aden",
"Asia/Almaty",
"Asia/Amman",
"Asia/Anadyr",
"Asia/Aqtau",
"Asia/Aqtobe",
"Asia/Ashgabat",
"Asia/Atyrau",
"Asia/Baghdad",
"Asia/Bahrain",
"Asia/Baku",
"Asia/Bangkok",
"Asia/Barnaul",
"Asia/Beirut",
"Asia/Bishkek",
"Asia/Brunei",
"Asia/Calcutta",
"Asia/Chita",
"Asia/Choibalsan",
"Asia/Colombo",
"Asia/Damascus",
"Asia/Dhaka",
"Asia/Dili",
"Asia/Dubai",
"Asia/Dushanbe",
"Asia/Famagusta",
"Asia/Gaza",
"Asia/Hebron",
"Asia/Hong_Kong",
"Asia/Hovd",
"Asia/Irkutsk",
"Asia/Jakarta",
"Asia/Jayapura",
"Asia/Jerusalem",
"Asia/Kabul",
"Asia/Kamchatka",
"Asia/Karachi",
"Asia/Katmandu",
"Asia/Khandyga",
"Asia/Krasnoyarsk",
"Asia/Kuala_Lumpur",
"Asia/Kuching",
"Asia/Kuwait",
"Asia/Macau",
"Asia/Magadan",
"Asia/Makassar",
"Asia/Manila",
"Asia/Muscat",
"Asia/Nicosia",
"Asia/Novokuznetsk",
"Asia/Novosibirsk",
"Asia/Omsk",
"Asia/Oral",
"Asia/Phnom_Penh",
"Asia/Pontianak",
"Asia/Pyongyang",
"Asia/Qatar",
"Asia/Qostanay",
"Asia/Qyzylorda",
"Asia/Rangoon",
"Asia/Riyadh",
"Asia/Saigon",
"Asia/Sakhalin",
"Asia/Samarkand",
"Asia/Seoul",
"Asia/Shanghai",
"Asia/Singapore",
"Asia/Srednekolymsk",
"Asia/Taipei",
"Asia/Tashkent",
"Asia/Tbilisi",
"Asia/Tehran",
"Asia/Thimphu",
"Asia/Tokyo",
"Asia/Tomsk",
"Asia/Ulaanbaatar",
"Asia/Urumqi",
"Asia/Ust-Nera",
"Asia/Vientiane",
"Asia/Vladivostok",
"Asia/Yakutsk",
"Asia/Yekaterinburg",
"Asia/Yerevan",
"Atlantic/Azores",
"Atlantic/Bermuda",
"Atlantic/Canary",
"Atlantic/Cape_Verde",
"Atlantic/Faeroe",
"Atlantic/Madeira",
"Atlantic/Reykjavik",
"Atlantic/South_Georgia",
"Atlantic/St_Helena",
"Atlantic/Stanley",
"Australia/Adelaide",
"Australia/Brisbane",
"Australia/Broken_Hill",
"Australia/Currie",
"Australia/Darwin",
"Australia/Eucla",
"Australia/Hobart",
"Australia/Lindeman",
"Australia/Lord_Howe",
"Australia/Melbourne",
"Australia/Perth",
"Australia/Sydney",
"Europe/Amsterdam",
"Europe/Andorra",
"Europe/Astrakhan",
"Europe/Athens",
"Europe/Belgrade",
"Europe/Berlin",
"Europe/Bratislava",
"Europe/Brussels",
"Europe/Bucharest",
"Europe/Budapest",
"Europe/Busingen",
"Europe/Chisinau",
"Europe/Copenhagen",
"Europe/Dublin",
"Europe/Gibraltar",
"Europe/Guernsey",
"Europe/Helsinki",
"Europe/Isle_of_Man",
"Europe/Istanbul",
"Europe/Jersey",
"Europe/Kaliningrad",
"Europe/Kiev",
"Europe/Kirov",
"Europe/Lisbon",
"Europe/Ljubljana",
"Europe/London",
"Europe/Luxembourg",
"Europe/Madrid",
"Europe/Malta",
"Europe/Mariehamn",
"Europe/Minsk",
"Europe/Monaco",
"Europe/Moscow",
"Europe/Oslo",
"Europe/Paris",
"Europe/Podgorica",
"Europe/Prague",
"Europe/Riga",
"Europe/Rome",
"Europe/Samara",
"Europe/San_Marino",
"Europe/Sarajevo",
"Europe/Saratov",
"Europe/Simferopol",
"Europe/Skopje",
"Europe/Sofia",
"Europe/Stockholm",
"Europe/Tallinn",
"Europe/Tirane",
"Europe/Ulyanovsk",
"Europe/Uzhgorod",
"Europe/Vaduz",
"Europe/Vatican",
"Europe/Vienna",
"Europe/Vilnius",
"Europe/Volgograd",
"Europe/Warsaw",
"Europe/Zagreb",
"Europe/Zaporozhye",
"Europe/Zurich",
"Indian/Antananarivo",
"Indian/Chagos",
"Indian/Christmas",
"Indian/Cocos",
"Indian/Comoro",
"Indian/Kerguelen",
"Indian/Mahe",
"Indian/Maldives",
"Indian/Mauritius",
"Indian/Mayotte",
"Indian/Reunion",
"Pacific/Apia",
"Pacific/Auckland",
"Pacific/Bougainville",
"Pacific/Chatham",
"Pacific/Easter",
"Pacific/Efate",
"Pacific/Enderbury",
"Pacific/Fakaofo",
"Pacific/Fiji",
"Pacific/Funafuti",
"Pacific/Galapagos",
"Pacific/Gambier",
"Pacific/Guadalcanal",
"Pacific/Guam",
"Pacific/Honolulu",
"Pacific/Johnston",
"Pacific/Kiritimati",
"Pacific/Kosrae",
"Pacific/Kwajalein",
"Pacific/Majuro",
"Pacific/Marquesas",
"Pacific/Midway",
"Pacific/Nauru",
"Pacific/Niue",
"Pacific/Norfolk",
"Pacific/Noumea",
"Pacific/Pago_Pago",
"Pacific/Palau",
"Pacific/Pitcairn",
"Pacific/Ponape",
"Pacific/Port_Moresby",
"Pacific/Rarotonga",
"Pacific/Saipan",
"Pacific/Tahiti",
"Pacific/Tarawa",
"Pacific/Tongatapu",
"Pacific/Truk",
"Pacific/Wake",
"Pacific/Wallis"
]
},
"timezoneOffset": {
"description": "Indicates the reference timezone offset with respect to UTC timezone a the time of event creation. The difference in minutes between the reference timezone time and UTC time (e.g. UTC+2 would be -120, UTC-5 would be 300, UTC would be 0).",
"type": "number"
}
},
"additionalProperties": false
}
```
</details>
"""
type EventMetadataLensSchedulingAdjustments {
  """
  Indicates a reference timezone for the event start and end times. If physical event, you
  could use the timezone of the event location. If virtual event, the timezone of the event
  organizer.
  """
  timezoneId: EventMetadataLensSchedulingAdjustmentsTimezoneId!
  timezoneOffset: Float!
}

"""
Indicates a reference timezone for the event start and end times. If physical event, you could
use the timezone of the event location. If virtual event, the timezone of the event organizer.

<details><summary>JSON schema</summary>

```json
{
"description": "Indicates a reference timezone for the event start and end times. If physical event, you could use the timezone of the event location. If virtual event, the timezone of the event organizer.",
"type": "string",
"enum": [
"Africa/Abidjan",
"Africa/Accra",
"Africa/Addis_Ababa",
"Africa/Algiers",
"Africa/Asmera",
"Africa/Bamako",
"Africa/Bangui",
"Africa/Banjul",
"Africa/Bissau",
"Africa/Blantyre",
"Africa/Brazzaville",
"Africa/Bujumbura",
"Africa/Cairo",
"Africa/Casablanca",
"Africa/Ceuta",
"Africa/Conakry",
"Africa/Dakar",
"Africa/Dar_es_Salaam",
"Africa/Djibouti",
"Africa/Douala",
"Africa/El_Aaiun",
"Africa/Freetown",
"Africa/Gaborone",
"Africa/Harare",
"Africa/Johannesburg",
"Africa/Juba",
"Africa/Kampala",
"Africa/Khartoum",
"Africa/Kigali",
"Africa/Kinshasa",
"Africa/Lagos",
"Africa/Libreville",
"Africa/Lome",
"Africa/Luanda",
"Africa/Lubumbashi",
"Africa/Lusaka",
"Africa/Malabo",
"Africa/Maputo",
"Africa/Maseru",
"Africa/Mbabane",
"Africa/Mogadishu",
"Africa/Monrovia",
"Africa/Nairobi",
"Africa/Ndjamena",
"Africa/Niamey",
"Africa/Nouakchott",
"Africa/Ouagadougou",
"Africa/Porto-Novo",
"Africa/Sao_Tome",
"Africa/Tripoli",
"Africa/Tunis",
"Africa/Windhoek",
"America/Adak",
"America/Anchorage",
"America/Anguilla",
"America/Antigua",
"America/Araguaina",
"America/Argentina/La_Rioja",
"America/Argentina/Rio_Gallegos",
"America/Argentina/Salta",
"America/Argentina/San_Juan",
"America/Argentina/San_Luis",
"America/Argentina/Tucuman",
"America/Argentina/Ushuaia",
"America/Aruba",
"America/Asuncion",
"America/Bahia",
"America/Bahia_Banderas",
"America/Barbados",
"America/Belem",
"America/Belize",
"America/Blanc-Sablon",
"America/Boa_Vista",
"America/Bogota",
"America/Boise",
"America/Buenos_Aires",
"America/Cambridge_Bay",
"America/Campo_Grande",
"America/Cancun",
"America/Caracas",
"America/Catamarca",
"America/Cayenne",
"America/Cayman",
"America/Chicago",
"America/Chihuahua",
"America/Ciudad_Juarez",
"America/Coral_Harbour",
"America/Cordoba",
"America/Costa_Rica",
"America/Creston",
"America/Cuiaba",
"America/Curacao",
"America/Danmarkshavn",
"America/Dawson",
"America/Dawson_Creek",
"America/Denver",
"America/Detroit",
"America/Dominica",
"America/Edmonton",
"America/Eirunepe",
"America/El_Salvador",
"America/Fort_Nelson",
"America/Fortaleza",
"America/Glace_Bay",
"America/Godthab",
"America/Goose_Bay",
"America/Grand_Turk",
"America/Grenada",
"America/Guadeloupe",
"America/Guatemala",
"America/Guayaquil",
"America/Guyana",
"America/Halifax",
"America/Havana",
"America/Hermosillo",
"America/Indiana/Knox",
"America/Indiana/Marengo",
"America/Indiana/Petersburg",
"America/Indiana/Tell_City",
"America/Indiana/Vevay",
"America/Indiana/Vincennes",
"America/Indiana/Winamac",
"America/Indianapolis",
"America/Inuvik",
"America/Iqaluit",
"America/Jamaica",
"America/Jujuy",
"America/Juneau",
"America/Kentucky/Monticello",
"America/Kralendijk",
"America/La_Paz",
"America/Lima",
"America/Los_Angeles",
"America/Louisville",
"America/Lower_Princes",
"America/Maceio",
"America/Managua",
"America/Manaus",
"America/Marigot",
"America/Martinique",
"America/Matamoros",
"America/Mazatlan",
"America/Mendoza",
"America/Menominee",
"America/Merida",
"America/Metlakatla",
"America/Mexico_City",
"America/Miquelon",
"America/Moncton",
"America/Monterrey",
"America/Montevideo",
"America/Montserrat",
"America/Nassau",
"America/New_York",
"America/Nipigon",
"America/Nome",
"America/Noronha",
"America/North_Dakota/Beulah",
"America/North_Dakota/Center",
"America/North_Dakota/New_Salem",
"America/Ojinaga",
"America/Panama",
"America/Pangnirtung",
"America/Paramaribo",
"America/Phoenix",
"America/Port-au-Prince",
"America/Port_of_Spain",
"America/Porto_Velho",
"America/Puerto_Rico",
"America/Punta_Arenas",
"America/Rainy_River",
"America/Rankin_Inlet",
"America/Recife",
"America/Regina",
"America/Resolute",
"America/Rio_Branco",
"America/Santa_Isabel",
"America/Santarem",
"America/Santiago",
"America/Santo_Domingo",
"America/Sao_Paulo",
"America/Scoresbysund",
"America/Sitka",
"America/St_Barthelemy",
"America/St_Johns",
"America/St_Kitts",
"America/St_Lucia",
"America/St_Thomas",
"America/St_Vincent",
"America/Swift_Current",
"America/Tegucigalpa",
"America/Thule",
"America/Thunder_Bay",
"America/Tijuana",
"America/Toronto",
"America/Tortola",
"America/Vancouver",
"America/Whitehorse",
"America/Winnipeg",
"America/Yakutat",
"America/Yellowknife",
"Antarctica/Casey",
"Antarctica/Davis",
"Antarctica/DumontDUrville",
"Antarctica/Macquarie",
"Antarctica/Mawson",
"Antarctica/McMurdo",
"Antarctica/Palmer",
"Antarctica/Rothera",
"Antarctica/Syowa",
"Antarctica/Troll",
"Antarctica/Vostok",
"Arctic/Longyearbyen",
"Asia/Aden",
"Asia/Almaty",
"Asia/Amman",
"Asia/Anadyr",
"Asia/Aqtau",
"Asia/Aqtobe",
"Asia/Ashgabat",
"Asia/Atyrau",
"Asia/Baghdad",
"Asia/Bahrain",
"Asia/Baku",
"Asia/Bangkok",
"Asia/Barnaul",
"Asia/Beirut",
"Asia/Bishkek",
"Asia/Brunei",
"Asia/Calcutta",
"Asia/Chita",
"Asia/Choibalsan",
"Asia/Colombo",
"Asia/Damascus",
"Asia/Dhaka",
"Asia/Dili",
"Asia/Dubai",
"Asia/Dushanbe",
"Asia/Famagusta",
"Asia/Gaza",
"Asia/Hebron",
"Asia/Hong_Kong",
"Asia/Hovd",
"Asia/Irkutsk",
"Asia/Jakarta",
"Asia/Jayapura",
"Asia/Jerusalem",
"Asia/Kabul",
"Asia/Kamchatka",
"Asia/Karachi",
"Asia/Katmandu",
"Asia/Khandyga",
"Asia/Krasnoyarsk",
"Asia/Kuala_Lumpur",
"Asia/Kuching",
"Asia/Kuwait",
"Asia/Macau",
"Asia/Magadan",
"Asia/Makassar",
"Asia/Manila",
"Asia/Muscat",
"Asia/Nicosia",
"Asia/Novokuznetsk",
"Asia/Novosibirsk",
"Asia/Omsk",
"Asia/Oral",
"Asia/Phnom_Penh",
"Asia/Pontianak",
"Asia/Pyongyang",
"Asia/Qatar",
"Asia/Qostanay",
"Asia/Qyzylorda",
"Asia/Rangoon",
"Asia/Riyadh",
"Asia/Saigon",
"Asia/Sakhalin",
"Asia/Samarkand",
"Asia/Seoul",
"Asia/Shanghai",
"Asia/Singapore",
"Asia/Srednekolymsk",
"Asia/Taipei",
"Asia/Tashkent",
"Asia/Tbilisi",
"Asia/Tehran",
"Asia/Thimphu",
"Asia/Tokyo",
"Asia/Tomsk",
"Asia/Ulaanbaatar",
"Asia/Urumqi",
"Asia/Ust-Nera",
"Asia/Vientiane",
"Asia/Vladivostok",
"Asia/Yakutsk",
"Asia/Yekaterinburg",
"Asia/Yerevan",
"Atlantic/Azores",
"Atlantic/Bermuda",
"Atlantic/Canary",
"Atlantic/Cape_Verde",
"Atlantic/Faeroe",
"Atlantic/Madeira",
"Atlantic/Reykjavik",
"Atlantic/South_Georgia",
"Atlantic/St_Helena",
"Atlantic/Stanley",
"Australia/Adelaide",
"Australia/Brisbane",
"Australia/Broken_Hill",
"Australia/Currie",
"Australia/Darwin",
"Australia/Eucla",
"Australia/Hobart",
"Australia/Lindeman",
"Australia/Lord_Howe",
"Australia/Melbourne",
"Australia/Perth",
"Australia/Sydney",
"Europe/Amsterdam",
"Europe/Andorra",
"Europe/Astrakhan",
"Europe/Athens",
"Europe/Belgrade",
"Europe/Berlin",
"Europe/Bratislava",
"Europe/Brussels",
"Europe/Bucharest",
"Europe/Budapest",
"Europe/Busingen",
"Europe/Chisinau",
"Europe/Copenhagen",
"Europe/Dublin",
"Europe/Gibraltar",
"Europe/Guernsey",
"Europe/Helsinki",
"Europe/Isle_of_Man",
"Europe/Istanbul",
"Europe/Jersey",
"Europe/Kaliningrad",
"Europe/Kiev",
"Europe/Kirov",
"Europe/Lisbon",
"Europe/Ljubljana",
"Europe/London",
"Europe/Luxembourg",
"Europe/Madrid",
"Europe/Malta",
"Europe/Mariehamn",
"Europe/Minsk",
"Europe/Monaco",
"Europe/Moscow",
"Europe/Oslo",
"Europe/Paris",
"Europe/Podgorica",
"Europe/Prague",
"Europe/Riga",
"Europe/Rome",
"Europe/Samara",
"Europe/San_Marino",
"Europe/Sarajevo",
"Europe/Saratov",
"Europe/Simferopol",
"Europe/Skopje",
"Europe/Sofia",
"Europe/Stockholm",
"Europe/Tallinn",
"Europe/Tirane",
"Europe/Ulyanovsk",
"Europe/Uzhgorod",
"Europe/Vaduz",
"Europe/Vatican",
"Europe/Vienna",
"Europe/Vilnius",
"Europe/Volgograd",
"Europe/Warsaw",
"Europe/Zagreb",
"Europe/Zaporozhye",
"Europe/Zurich",
"Indian/Antananarivo",
"Indian/Chagos",
"Indian/Christmas",
"Indian/Cocos",
"Indian/Comoro",
"Indian/Kerguelen",
"Indian/Mahe",
"Indian/Maldives",
"Indian/Mauritius",
"Indian/Mayotte",
"Indian/Reunion",
"Pacific/Apia",
"Pacific/Auckland",
"Pacific/Bougainville",
"Pacific/Chatham",
"Pacific/Easter",
"Pacific/Efate",
"Pacific/Enderbury",
"Pacific/Fakaofo",
"Pacific/Fiji",
"Pacific/Funafuti",
"Pacific/Galapagos",
"Pacific/Gambier",
"Pacific/Guadalcanal",
"Pacific/Guam",
"Pacific/Honolulu",
"Pacific/Johnston",
"Pacific/Kiritimati",
"Pacific/Kosrae",
"Pacific/Kwajalein",
"Pacific/Majuro",
"Pacific/Marquesas",
"Pacific/Midway",
"Pacific/Nauru",
"Pacific/Niue",
"Pacific/Norfolk",
"Pacific/Noumea",
"Pacific/Pago_Pago",
"Pacific/Palau",
"Pacific/Pitcairn",
"Pacific/Ponape",
"Pacific/Port_Moresby",
"Pacific/Rarotonga",
"Pacific/Saipan",
"Pacific/Tahiti",
"Pacific/Tarawa",
"Pacific/Tongatapu",
"Pacific/Truk",
"Pacific/Wake",
"Pacific/Wallis"
]
}
```
</details>
"""
enum EventMetadataLensSchedulingAdjustmentsTimezoneId {
  AFRICA_ABIDJAN
  AFRICA_ACCRA
  AFRICA_ADDIS_ABABA
  AFRICA_ALGIERS
  AFRICA_ASMERA
  AFRICA_BAMAKO
  AFRICA_BANGUI
  AFRICA_BANJUL
  AFRICA_BISSAU
  AFRICA_BLANTYRE
  AFRICA_BRAZZAVILLE
  AFRICA_BUJUMBURA
  AFRICA_CAIRO
  AFRICA_CASABLANCA
  AFRICA_CEUTA
  AFRICA_CONAKRY
  AFRICA_DAKAR
  AFRICA_DAR_ES_SALAAM
  AFRICA_DJIBOUTI
  AFRICA_DOUALA
  AFRICA_EL_AAIUN
  AFRICA_FREETOWN
  AFRICA_GABORONE
  AFRICA_HARARE
  AFRICA_JOHANNESBURG
  AFRICA_JUBA
  AFRICA_KAMPALA
  AFRICA_KHARTOUM
  AFRICA_KIGALI
  AFRICA_KINSHASA
  AFRICA_LAGOS
  AFRICA_LIBREVILLE
  AFRICA_LOME
  AFRICA_LUANDA
  AFRICA_LUBUMBASHI
  AFRICA_LUSAKA
  AFRICA_MALABO
  AFRICA_MAPUTO
  AFRICA_MASERU
  AFRICA_MBABANE
  AFRICA_MOGADISHU
  AFRICA_MONROVIA
  AFRICA_NAIROBI
  AFRICA_NDJAMENA
  AFRICA_NIAMEY
  AFRICA_NOUAKCHOTT
  AFRICA_OUAGADOUGOU
  AFRICA_PORTO_NOVO
  AFRICA_SAO_TOME
  AFRICA_TRIPOLI
  AFRICA_TUNIS
  AFRICA_WINDHOEK
  AMERICA_ADAK
  AMERICA_ANCHORAGE
  AMERICA_ANGUILLA
  AMERICA_ANTIGUA
  AMERICA_ARAGUAINA
  AMERICA_ARGENTINA_LA_RIOJA
  AMERICA_ARGENTINA_RIO_GALLEGOS
  AMERICA_ARGENTINA_SALTA
  AMERICA_ARGENTINA_SAN_JUAN
  AMERICA_ARGENTINA_SAN_LUIS
  AMERICA_ARGENTINA_TUCUMAN
  AMERICA_ARGENTINA_USHUAIA
  AMERICA_ARUBA
  AMERICA_ASUNCION
  AMERICA_BAHIA
  AMERICA_BAHIA_BANDERAS
  AMERICA_BARBADOS
  AMERICA_BELEM
  AMERICA_BELIZE
  AMERICA_BLANC_SABLON
  AMERICA_BOA_VISTA
  AMERICA_BOGOTA
  AMERICA_BOISE
  AMERICA_BUENOS_AIRES
  AMERICA_CAMBRIDGE_BAY
  AMERICA_CAMPO_GRANDE
  AMERICA_CANCUN
  AMERICA_CARACAS
  AMERICA_CATAMARCA
  AMERICA_CAYENNE
  AMERICA_CAYMAN
  AMERICA_CHICAGO
  AMERICA_CHIHUAHUA
  AMERICA_CIUDAD_JUAREZ
  AMERICA_CORAL_HARBOUR
  AMERICA_CORDOBA
  AMERICA_COSTA_RICA
  AMERICA_CRESTON
  AMERICA_CUIABA
  AMERICA_CURACAO
  AMERICA_DANMARKSHAVN
  AMERICA_DAWSON
  AMERICA_DAWSON_CREEK
  AMERICA_DENVER
  AMERICA_DETROIT
  AMERICA_DOMINICA
  AMERICA_EDMONTON
  AMERICA_EIRUNEPE
  AMERICA_EL_SALVADOR
  AMERICA_FORT_NELSON
  AMERICA_FORTALEZA
  AMERICA_GLACE_BAY
  AMERICA_GODTHAB
  AMERICA_GOOSE_BAY
  AMERICA_GRAND_TURK
  AMERICA_GRENADA
  AMERICA_GUADELOUPE
  AMERICA_GUATEMALA
  AMERICA_GUAYAQUIL
  AMERICA_GUYANA
  AMERICA_HALIFAX
  AMERICA_HAVANA
  AMERICA_HERMOSILLO
  AMERICA_INDIANA_KNOX
  AMERICA_INDIANA_MARENGO
  AMERICA_INDIANA_PETERSBURG
  AMERICA_INDIANA_TELL_CITY
  AMERICA_INDIANA_VEVAY
  AMERICA_INDIANA_VINCENNES
  AMERICA_INDIANA_WINAMAC
  AMERICA_INDIANAPOLIS
  AMERICA_INUVIK
  AMERICA_IQALUIT
  AMERICA_JAMAICA
  AMERICA_JUJUY
  AMERICA_JUNEAU
  AMERICA_KENTUCKY_MONTICELLO
  AMERICA_KRALENDIJK
  AMERICA_LA_PAZ
  AMERICA_LIMA
  AMERICA_LOS_ANGELES
  AMERICA_LOUISVILLE
  AMERICA_LOWER_PRINCES
  AMERICA_MACEIO
  AMERICA_MANAGUA
  AMERICA_MANAUS
  AMERICA_MARIGOT
  AMERICA_MARTINIQUE
  AMERICA_MATAMOROS
  AMERICA_MAZATLAN
  AMERICA_MENDOZA
  AMERICA_MENOMINEE
  AMERICA_MERIDA
  AMERICA_METLAKATLA
  AMERICA_MEXICO_CITY
  AMERICA_MIQUELON
  AMERICA_MONCTON
  AMERICA_MONTERREY
  AMERICA_MONTEVIDEO
  AMERICA_MONTSERRAT
  AMERICA_NASSAU
  AMERICA_NEW_YORK
  AMERICA_NIPIGON
  AMERICA_NOME
  AMERICA_NORONHA
  AMERICA_NORTH_DAKOTA_BEULAH
  AMERICA_NORTH_DAKOTA_CENTER
  AMERICA_NORTH_DAKOTA_NEW_SALEM
  AMERICA_OJINAGA
  AMERICA_PANAMA
  AMERICA_PANGNIRTUNG
  AMERICA_PARAMARIBO
  AMERICA_PHOENIX
  AMERICA_PORT_AU_PRINCE
  AMERICA_PORT_OF_SPAIN
  AMERICA_PORTO_VELHO
  AMERICA_PUERTO_RICO
  AMERICA_PUNTA_ARENAS
  AMERICA_RAINY_RIVER
  AMERICA_RANKIN_INLET
  AMERICA_RECIFE
  AMERICA_REGINA
  AMERICA_RESOLUTE
  AMERICA_RIO_BRANCO
  AMERICA_SANTA_ISABEL
  AMERICA_SANTAREM
  AMERICA_SANTIAGO
  AMERICA_SANTO_DOMINGO
  AMERICA_SAO_PAULO
  AMERICA_SCORESBYSUND
  AMERICA_SITKA
  AMERICA_ST_BARTHELEMY
  AMERICA_ST_JOHNS
  AMERICA_ST_KITTS
  AMERICA_ST_LUCIA
  AMERICA_ST_THOMAS
  AMERICA_ST_VINCENT
  AMERICA_SWIFT_CURRENT
  AMERICA_TEGUCIGALPA
  AMERICA_THULE
  AMERICA_THUNDER_BAY
  AMERICA_TIJUANA
  AMERICA_TORONTO
  AMERICA_TORTOLA
  AMERICA_VANCOUVER
  AMERICA_WHITEHORSE
  AMERICA_WINNIPEG
  AMERICA_YAKUTAT
  AMERICA_YELLOWKNIFE
  ANTARCTICA_CASEY
  ANTARCTICA_DAVIS
  ANTARCTICA_DUMONT_D_URVILLE
  ANTARCTICA_MACQUARIE
  ANTARCTICA_MAWSON
  ANTARCTICA_MC_MURDO
  ANTARCTICA_PALMER
  ANTARCTICA_ROTHERA
  ANTARCTICA_SYOWA
  ANTARCTICA_TROLL
  ANTARCTICA_VOSTOK
  ARCTIC_LONGYEARBYEN
  ASIA_ADEN
  ASIA_ALMATY
  ASIA_AMMAN
  ASIA_ANADYR
  ASIA_AQTAU
  ASIA_AQTOBE
  ASIA_ASHGABAT
  ASIA_ATYRAU
  ASIA_BAGHDAD
  ASIA_BAHRAIN
  ASIA_BAKU
  ASIA_BANGKOK
  ASIA_BARNAUL
  ASIA_BEIRUT
  ASIA_BISHKEK
  ASIA_BRUNEI
  ASIA_CALCUTTA
  ASIA_CHITA
  ASIA_CHOIBALSAN
  ASIA_COLOMBO
  ASIA_DAMASCUS
  ASIA_DHAKA
  ASIA_DILI
  ASIA_DUBAI
  ASIA_DUSHANBE
  ASIA_FAMAGUSTA
  ASIA_GAZA
  ASIA_HEBRON
  ASIA_HONG_KONG
  ASIA_HOVD
  ASIA_IRKUTSK
  ASIA_JAKARTA
  ASIA_JAYAPURA
  ASIA_JERUSALEM
  ASIA_KABUL
  ASIA_KAMCHATKA
  ASIA_KARACHI
  ASIA_KATMANDU
  ASIA_KHANDYGA
  ASIA_KRASNOYARSK
  ASIA_KUALA_LUMPUR
  ASIA_KUCHING
  ASIA_KUWAIT
  ASIA_MACAU
  ASIA_MAGADAN
  ASIA_MAKASSAR
  ASIA_MANILA
  ASIA_MUSCAT
  ASIA_NICOSIA
  ASIA_NOVOKUZNETSK
  ASIA_NOVOSIBIRSK
  ASIA_OMSK
  ASIA_ORAL
  ASIA_PHNOM_PENH
  ASIA_PONTIANAK
  ASIA_PYONGYANG
  ASIA_QATAR
  ASIA_QOSTANAY
  ASIA_QYZYLORDA
  ASIA_RANGOON
  ASIA_RIYADH
  ASIA_SAIGON
  ASIA_SAKHALIN
  ASIA_SAMARKAND
  ASIA_SEOUL
  ASIA_SHANGHAI
  ASIA_SINGAPORE
  ASIA_SREDNEKOLYMSK
  ASIA_TAIPEI
  ASIA_TASHKENT
  ASIA_TBILISI
  ASIA_TEHRAN
  ASIA_THIMPHU
  ASIA_TOKYO
  ASIA_TOMSK
  ASIA_ULAANBAATAR
  ASIA_URUMQI
  ASIA_UST_NERA
  ASIA_VIENTIANE
  ASIA_VLADIVOSTOK
  ASIA_YAKUTSK
  ASIA_YEKATERINBURG
  ASIA_YEREVAN
  ATLANTIC_AZORES
  ATLANTIC_BERMUDA
  ATLANTIC_CANARY
  ATLANTIC_CAPE_VERDE
  ATLANTIC_FAEROE
  ATLANTIC_MADEIRA
  ATLANTIC_REYKJAVIK
  ATLANTIC_SOUTH_GEORGIA
  ATLANTIC_ST_HELENA
  ATLANTIC_STANLEY
  AUSTRALIA_ADELAIDE
  AUSTRALIA_BRISBANE
  AUSTRALIA_BROKEN_HILL
  AUSTRALIA_CURRIE
  AUSTRALIA_DARWIN
  AUSTRALIA_EUCLA
  AUSTRALIA_HOBART
  AUSTRALIA_LINDEMAN
  AUSTRALIA_LORD_HOWE
  AUSTRALIA_MELBOURNE
  AUSTRALIA_PERTH
  AUSTRALIA_SYDNEY
  EUROPE_AMSTERDAM
  EUROPE_ANDORRA
  EUROPE_ASTRAKHAN
  EUROPE_ATHENS
  EUROPE_BELGRADE
  EUROPE_BERLIN
  EUROPE_BRATISLAVA
  EUROPE_BRUSSELS
  EUROPE_BUCHAREST
  EUROPE_BUDAPEST
  EUROPE_BUSINGEN
  EUROPE_CHISINAU
  EUROPE_COPENHAGEN
  EUROPE_DUBLIN
  EUROPE_GIBRALTAR
  EUROPE_GUERNSEY
  EUROPE_HELSINKI
  EUROPE_ISLE_OF_MAN
  EUROPE_ISTANBUL
  EUROPE_JERSEY
  EUROPE_KALININGRAD
  EUROPE_KIEV
  EUROPE_KIROV
  EUROPE_LISBON
  EUROPE_LJUBLJANA
  EUROPE_LONDON
  EUROPE_LUXEMBOURG
  EUROPE_MADRID
  EUROPE_MALTA
  EUROPE_MARIEHAMN
  EUROPE_MINSK
  EUROPE_MONACO
  EUROPE_MOSCOW
  EUROPE_OSLO
  EUROPE_PARIS
  EUROPE_PODGORICA
  EUROPE_PRAGUE
  EUROPE_RIGA
  EUROPE_ROME
  EUROPE_SAMARA
  EUROPE_SAN_MARINO
  EUROPE_SARAJEVO
  EUROPE_SARATOV
  EUROPE_SIMFEROPOL
  EUROPE_SKOPJE
  EUROPE_SOFIA
  EUROPE_STOCKHOLM
  EUROPE_TALLINN
  EUROPE_TIRANE
  EUROPE_ULYANOVSK
  EUROPE_UZHGOROD
  EUROPE_VADUZ
  EUROPE_VATICAN
  EUROPE_VIENNA
  EUROPE_VILNIUS
  EUROPE_VOLGOGRAD
  EUROPE_WARSAW
  EUROPE_ZAGREB
  EUROPE_ZAPOROZHYE
  EUROPE_ZURICH
  INDIAN_ANTANANARIVO
  INDIAN_CHAGOS
  INDIAN_CHRISTMAS
  INDIAN_COCOS
  INDIAN_COMORO
  INDIAN_KERGUELEN
  INDIAN_MAHE
  INDIAN_MALDIVES
  INDIAN_MAURITIUS
  INDIAN_MAYOTTE
  INDIAN_REUNION
  PACIFIC_APIA
  PACIFIC_AUCKLAND
  PACIFIC_BOUGAINVILLE
  PACIFIC_CHATHAM
  PACIFIC_EASTER
  PACIFIC_EFATE
  PACIFIC_ENDERBURY
  PACIFIC_FAKAOFO
  PACIFIC_FIJI
  PACIFIC_FUNAFUTI
  PACIFIC_GALAPAGOS
  PACIFIC_GAMBIER
  PACIFIC_GUADALCANAL
  PACIFIC_GUAM
  PACIFIC_HONOLULU
  PACIFIC_JOHNSTON
  PACIFIC_KIRITIMATI
  PACIFIC_KOSRAE
  PACIFIC_KWAJALEIN
  PACIFIC_MAJURO
  PACIFIC_MARQUESAS
  PACIFIC_MIDWAY
  PACIFIC_NAURU
  PACIFIC_NIUE
  PACIFIC_NORFOLK
  PACIFIC_NOUMEA
  PACIFIC_PAGO_PAGO
  PACIFIC_PALAU
  PACIFIC_PITCAIRN
  PACIFIC_PONAPE
  PACIFIC_PORT_MORESBY
  PACIFIC_RAROTONGA
  PACIFIC_SAIPAN
  PACIFIC_TAHITI
  PACIFIC_TARAWA
  PACIFIC_TONGATAPU
  PACIFIC_TRUK
  PACIFIC_WAKE
  PACIFIC_WALLIS
}

scalar EvmAddress

"""The challenge has expired or was not found."""
type ExpiredChallengeError {
  reason: String!
}

"""
The transaction has failed to be mined or indexed.

The reason for the failure is provided.
"""
type FailedTransactionStatus {
  reason: String!
  blockTimestamp: DateTime!
}

input FeeFollowRuleInput {
  amount: AmountInput!
}

type Feed {
  address: EvmAddress!
}

input FeedRequest {
  feed: EvmAddress!
}

input FeedRulesInput {
  unknownFeedRule: UnknownFeedRuleInput
}

"""
The transaction has been mined and indexed correctly.

If the transaction involves any metadata, the metadata has been snapshotted and indexed.
"""
type FinishedTransactionStatus {
  blockTimestamp: DateTime!
}

"""
FollowCondition

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"follow",
"type"
],
"properties": {
"follow": {
"$ref": "#/$defs/ProfileId"
},
"type": {
"type": "string",
"const": "FOLLOW"
}
},
"additionalProperties": false
}
```
</details>
"""
type FollowCondition {
  follow: EvmAddress!
  type: String!
}

input FollowPair {
  graph: EvmAddress!
  follower: EvmAddress!
  account: EvmAddress!
}

type FollowResponse {
  hash: TxHash!
}

union FollowResult = FollowResponse | SponsoredTransactionRequest | TransactionRequest | TransactionWillFail

type FollowRule {
  moduleName: String!
  contract: NetworkAddress!
}

input FollowRulesInput {
  feeFollowRule: FeeFollowRuleInput
  unknownFollowRule: UnknownFollowRuleInput
}

input FollowRulesRequest {
  limit: Int
  cursor: Cursor
  includeUnknown: Boolean
  onlyVerified: Boolean
}

input FollowStatusRequest {
  pairs: [FollowPair!]!
}

type FollowStatusResult {
  graph: EvmAddress!
  follower: EvmAddress!
  account: EvmAddress!
  isFollowing: BooleanValue!
}

enum FollowersOrderBy {
  APPS_OR_GRAPHS_FILTER_ORDER
  ACCOUNT_SCORE
}

input FollowersRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
  orderBy: FollowersOrderBy
}

enum FollowersYouKnowOrderBy {
  APPS_OR_GRAPHS_FILTER_ORDER
  ACCOUNT_SCORE
}

input FollowersYouKnowRequest {
  limit: Int
  cursor: Cursor
  target: EvmAddress!
  observer: EvmAddress!
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
  orderBy: FollowersYouKnowOrderBy
}

enum FollowingOrderBy {
  APPS_OR_GRAPHS_FILTER_ORDER
  ACCOUNT_SCORE
}

input FollowingRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  forGraphs: [EvmAddress!]! = ["0x7bE2cA3B7be499546f3f31605f4818D70d14439A"]
  orderBy: FollowingOrderBy
}

enum ForYouSource {
  FOLLOWING
  CURATED
  POPULAR
  EXTENDED_NETWORK
}

type ForbiddenError {
  reason: String!
}

input FrameEIP712Request {
  specVersion: String!
  url: URI!
  buttonIndex: Int!
  account: EvmAddress!
  postId: PostId!
  inputText: String!
  state: String!
  actionResponse: String!
  deadline: Int!
}

input FrameLensManagerEIP712Request {
  specVersion: String!
  url: URI!
  buttonIndex: Int!
  account: EvmAddress!
  postId: PostId!
  inputText: String!
  state: String!
  actionResponse: String!
}

type FrameLensManagerSignatureResult {
  signedTypedData: CreateFrameEIP712TypedData!
  signature: Signature!
}

input FrameVerifySignature {
  signedTypedData: CreateFrameEIP712TypedDataInput!
  signature: Signature!
  identityToken: IdToken!
}

enum FrameVerifySignatureResult {
  VERIFIED
  IDENTITY_UNAUTHORIZED
  IDENTITY_CANNOT_USE_PROFILE
  DEADLINE_EXPIRED
  SIGNER_ADDRESS_CANNOT_USE_PROFILE
}

type Graph {
  address: EvmAddress!
  metadata: GraphMetadata
}

"""
GraphMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"lens",
"schema"
],
"properties": {
"lens": {
"type": "object",
"required": [
"name",
"title"
],
"properties": {
"description": {
"description": "Optional markdown formatted description of the graph.",
"$ref": "#/$defs/NonEmptyString"
},
"name": {
"description": "The name of the graph.",
"$ref": "#/$defs/NonEmptyString"
},
"title": {
"description": "The human-friendly title for the graph.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/graph/1.0.0.json"
}
},
"additionalProperties": false
}
```
</details>
"""
type GraphMetadata {
  lens: GraphMetadataLens!
  schema: String!
}

"""
GraphMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"name",
"title"
],
"properties": {
"description": {
"description": "Optional markdown formatted description of the graph.",
"$ref": "#/$defs/NonEmptyString"
},
"name": {
"description": "The name of the graph.",
"$ref": "#/$defs/NonEmptyString"
},
"title": {
"description": "The human-friendly title for the graph.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
```
</details>
"""
type GraphMetadataLens {
  """Optional markdown formatted description of the graph."""
  description: NonEmptyString

  """The name of the graph."""
  name: NonEmptyString!

  """The human-friendly title for the graph."""
  title: NonEmptyString!
}

input GraphRequest {
  graph: EvmAddress!
}

input GraphRulesInput {
  unknownGraphRule: UnknownGraphRuleInput
}

input GraphsRequest {
  app: EvmAddress
  limit: Int
  cursor: Cursor
}

input HasReactedRequest {
  type: PostReactionType
}

input HideManagedAccountRequest {
  account: EvmAddress!
}

input HideReplyRequest {
  postId: PostId!
}

scalar IdToken

"""
ImageMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/image/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"id",
"image",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"image": {
"$ref": "#/$defs/MediaImage"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "IMAGE"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The optional image title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type ImageMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: ImageMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
ImageMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"id",
"image",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"image": {
"$ref": "#/$defs/MediaImage"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "IMAGE"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The optional image title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
```
</details>
"""
type ImageMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  image: MediaImage!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional image title."""
  title: NonEmptyString
}

input IsFollowedByMeRequest {
  appOrGraph: EvmAddress!
}

input IsFollowingMeRequest {
  appOrGraph: EvmAddress!
}

type JsonAttribute {
  """The attribute's unique identifier."""
  key: NonEmptyString!

  """A JSON string. It's consumer responsibility to validate and parse it."""
  value: NonEmptyString!
}

type KnownAction {
  name: String!
  contract: NetworkAddress!
  setupInput: [ActionInputInfo!]!
  actionInput: [ActionInputInfo!]!
  returnSetupInput: [ActionInputInfo!]!
}

input LastLoggedInAccountRequest {
  address: EvmAddress!
  app: EvmAddress
}

scalar LegacyProfileId

scalar LegacyRefreshToken

"""
LinkMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/link/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"id",
"locale",
"mainContentFocus",
"sharingLink"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "LINK"
},
"sharingLink": {
"description": "The sharing link url.",
"$ref": "#/$defs/EncryptableUri"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type LinkMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: LinkMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
LinkMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"id",
"locale",
"mainContentFocus",
"sharingLink"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "LINK"
},
"sharingLink": {
"description": "The sharing link url.",
"$ref": "#/$defs/EncryptableUri"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
}
```
</details>
"""
type LinkMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """The sharing link url."""
  sharingLink: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

type LitProtocolEncryptionStrategy {
  accessCondition: TopLevelAccessCondition!
  encryptedPaths: [NonEmptyString!]!
  encryptionKey: EncryptionKey!
}

"""
LiveStreamMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/livestream/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"id",
"liveUrl",
"locale",
"mainContentFocus",
"playbackUrl",
"startsAt"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"checkLiveAPI": {
"description": "The data cannot be changed so you can put in an API endpoint to know if it is still live or not for clients to be able to check.",
"$ref": "#/$defs/EncryptableUri"
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"endsAt": {
"description": "The optional stream end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)",
"$ref": "#/$defs/EncryptableDateTime"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"liveUrl": {
"description": "Some livestream platforms have the live url as a separate url. If not your case make sure `liveUrl` and `playbackUrl` are the same.",
"$ref": "#/$defs/EncryptableUri"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "LIVESTREAM"
},
"playbackUrl": {
"description": "Some livestream platforms have the playback url as a separate url. If not your case make sure `liveUrl` and `playbackUrl` are the same.",
"$ref": "#/$defs/EncryptableUri"
},
"startsAt": {
"description": "The stream start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`).",
"$ref": "#/$defs/EncryptableDateTime"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The livestream title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type LivestreamMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: LivestreamMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
LiveStreamMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"id",
"liveUrl",
"locale",
"mainContentFocus",
"playbackUrl",
"startsAt"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"checkLiveAPI": {
"description": "The data cannot be changed so you can put in an API endpoint to know if it is still live or not for clients to be able to check.",
"$ref": "#/$defs/EncryptableUri"
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"endsAt": {
"description": "The optional stream end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)",
"$ref": "#/$defs/EncryptableDateTime"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"liveUrl": {
"description": "Some livestream platforms have the live url as a separate url. If not your case make sure `liveUrl` and `playbackUrl` are the same.",
"$ref": "#/$defs/EncryptableUri"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "LIVESTREAM"
},
"playbackUrl": {
"description": "Some livestream platforms have the playback url as a separate url. If not your case make sure `liveUrl` and `playbackUrl` are the same.",
"$ref": "#/$defs/EncryptableUri"
},
"startsAt": {
"description": "The stream start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`).",
"$ref": "#/$defs/EncryptableDateTime"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The livestream title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
```
</details>
"""
type LivestreamMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """
  The data cannot be changed so you can put in an API endpoint to know if it is still live or
  not for clients to be able to check.
  """
  checkLiveApi: Encryptable

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """The optional stream end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)"""
  endsAt: Encryptable

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!

  """
  Some livestream platforms have the live url as a separate url. If not your case make sure
  `liveUrl` and `playbackUrl` are the same.
  """
  liveUrl: Encryptable!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """
  Some livestream platforms have the playback url as a separate url. If not your case make
  sure `liveUrl` and `playbackUrl` are the same.
  """
  playbackUrl: Encryptable!

  """The stream start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The livestream title."""
  title: NonEmptyString
}

scalar Locale

type LoggedInAccountOperations {
  id: ID!
  isFollowedByMe(request: IsFollowedByMeRequest): Boolean!
  isFollowingMe(request: IsFollowingMeRequest): Boolean!
  canFollow(request: CanFollowRequest): TriStateValue!
  canUnfollow(request: CanUnfollowRequest): Boolean!
  isMutedByMe: Boolean!
  isBlockedByMe: Boolean!
  hasBlockedMe: Boolean!
  canBlock: Boolean!
  canUnblock: Boolean!
  hasReported: Boolean!
}

type LoggedInPostOperations {
  id: ID!
  isNotInterested: Boolean!
  hasBookmarked: Boolean!
  hasReported: Boolean!
  hasReacted(request: HasReactedRequest): Boolean!
  canComment: TriStateValue!
  canQuote: TriStateValue!
  canRepost: TriStateValue!
  hasCommented: BooleanValue!
  hasQuoted: BooleanValue!
  hasReposted: BooleanValue!
}

enum ManagedAccountsVisibility {
  NONE_HIDDEN
  HIDDEN_ONLY
  ALL
}

"""
MarketplaceMetadataAttribute

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"properties": {
"display_type": {
"type": "string",
"enum": [
"number",
"string",
"date"
]
},
"trait_type": {
"description": "The name of the trait.",
"$ref": "#/$defs/NonEmptyString"
},
"value": {
"type": [
"string",
"number"
]
}
},
"additionalProperties": true
}
```
</details>
"""
type MarketplaceMetadataAttribute {
  displayType: MarketplaceMetadataAttributeDisplayType

  """The name of the trait."""
  traitType: NonEmptyString
  value: MarketplaceMetadataAttributeValue
}

"""
MarketplaceMetadataAttributeDisplayType

<details><summary>JSON schema</summary>

```json
{
"type": "string",
"enum": [
"number",
"string",
"date"
]
}
```
</details>
"""
enum MarketplaceMetadataAttributeDisplayType {
  NUMBER
  STRING
  DATE
}

scalar MarketplaceMetadataAttributeValue

"""
MediaAudio

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"artist": {
"description": "The name of the artist.",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"cover": {
"$ref": "#/$defs/EncryptableUri"
},
"credits": {
"description": "The credits for the audio.",
"$ref": "#/$defs/EncryptableString"
},
"duration": {
"description": "How long the the audio is in seconds.",
"type": "integer",
"exclusiveMinimum": 0.0
},
"genre": {
"description": "The genre of the audio",
"$ref": "#/$defs/EncryptableString"
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"kind": {
"description": "The type of audio.",
"type": "string",
"enum": [
"MUSIC",
"PODCAST",
"AUDIOBOOK",
"VOICE_NOTE",
"SOUND",
"OTHER"
]
},
"license": {
"description": "The license for the audio.",
"$ref": "#/$defs/MetadataLicenseType"
},
"lyrics": {
"$ref": "#/$defs/EncryptableUri"
},
"recordLabel": {
"description": "The record label for the audio.",
"$ref": "#/$defs/EncryptableString"
},
"type": {
"description": "The mime type of the audio file.",
"type": "string",
"enum": [
"audio/wav",
"audio/vnd.wave",
"audio/mpeg",
"audio/ogg",
"audio/mp4",
"audio/aac",
"audio/webm",
"audio/flac"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaAudio {
  """The name of the artist."""
  artist: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  cover: Encryptable

  """The credits for the audio."""
  credits: Encryptable

  """How long the the audio is in seconds."""
  duration: Int

  """The genre of the audio"""
  genre: Encryptable
  item: Encryptable!

  """The type of audio."""
  kind: MediaAudioKind

  """The license for the audio."""
  license: MetadataLicenseType
  lyrics: Encryptable

  """The record label for the audio."""
  recordLabel: Encryptable

  """The mime type of the audio file."""
  type: MediaAudioType!
}

"""
The type of audio.

<details><summary>JSON schema</summary>

```json
{
"description": "The type of audio.",
"type": "string",
"enum": [
"MUSIC",
"PODCAST",
"AUDIOBOOK",
"VOICE_NOTE",
"SOUND",
"OTHER"
]
}
```
</details>
"""
enum MediaAudioKind {
  MUSIC
  PODCAST
  AUDIOBOOK
  VOICE_NOTE
  SOUND
  OTHER
}

"""
The mime type of the audio file.

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the audio file.",
"type": "string",
"enum": [
"audio/wav",
"audio/vnd.wave",
"audio/mpeg",
"audio/ogg",
"audio/mp4",
"audio/aac",
"audio/webm",
"audio/flac"
]
}
```
</details>
"""
enum MediaAudioType {
  AUDIO_WAV
  AUDIO_VND_WAVE
  AUDIO_MPEG
  AUDIO_OGG
  AUDIO_MP_4
  AUDIO_AAC
  AUDIO_WEBM
  AUDIO_FLAC
}

"""
MediaImage

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"altTag": {
"description": "The alt tag for accessibility",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"license": {
"description": "The license for the image",
"$ref": "#/$defs/MetadataLicenseType"
},
"type": {
"description": "The mime type of the image",
"type": "string",
"enum": [
"image/bmp",
"image/gif",
"image/heic",
"image/jpeg",
"image/png",
"image/svg+xml",
"image/tiff",
"image/webp",
"image/x-ms-bmp"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaImage {
  """The alt tag for accessibility"""
  altTag: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  item: Encryptable!

  """The license for the image"""
  license: MetadataLicenseType

  """The mime type of the image"""
  type: MediaImageType!
}

"""
The mime type of the image

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the image",
"type": "string",
"enum": [
"image/bmp",
"image/gif",
"image/heic",
"image/jpeg",
"image/png",
"image/svg+xml",
"image/tiff",
"image/webp",
"image/x-ms-bmp"
]
}
```
</details>
"""
enum MediaImageType {
  BMP
  GIF
  HEIC
  JPEG
  PNG
  SVG_XML
  TIFF
  WEBP
  X_MS_BMP
}

"""
MediaVideo

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"altTag": {
"description": "The alt tag for accessibility",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"cover": {
"$ref": "#/$defs/EncryptableUri"
},
"duration": {
"description": "How long the the video is in seconds",
"type": "integer",
"exclusiveMinimum": 0.0
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"license": {
"description": "The license for the video",
"$ref": "#/$defs/MetadataLicenseType"
},
"type": {
"description": "The mime type of the video",
"type": "string",
"enum": [
"model/gltf+json",
"model/gltf-binary",
"video/x-m4v",
"video/mov",
"video/mp4",
"video/mpeg",
"video/ogg",
"video/ogv",
"video/quicktime",
"video/webm"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaVideo {
  """The alt tag for accessibility"""
  altTag: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  cover: Encryptable

  """How long the the video is in seconds"""
  duration: Int
  item: Encryptable!

  """The license for the video"""
  license: MetadataLicenseType

  """The mime type of the video"""
  type: MediaVideoType!
}

"""
The mime type of the video

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the video",
"type": "string",
"enum": [
"model/gltf+json",
"model/gltf-binary",
"video/x-m4v",
"video/mov",
"video/mp4",
"video/mpeg",
"video/ogg",
"video/ogv",
"video/quicktime",
"video/webm"
]
}
```
</details>
"""
enum MediaVideoType {
  MODEL_GLTF_JSON
  MODEL_GLTF_BINARY
  VIDEO_XM_4V
  VIDEO_MOV
  VIDEO_MP_4
  VIDEO_MPEG
  VIDEO_OGG
  VIDEO_OGV
  VIDEO_QUICKTIME
  VIDEO_WEBM
}

"""
MetadataAttribute

<details><summary>JSON schema</summary>

```json
{
"anyOf": [
{
"type": "object",
"required": [
"key",
"type",
"value"
],
"properties": {
"key": {
"description": "The attribute's unique identifier.",
"$ref": "#/$defs/NonEmptyString"
},
"type": {
"type": "string",
"const": "Boolean"
},
"value": {
"description": "A JS boolean value serialized as string. It's consumer responsibility to parse it.",
"type": "string",
"enum": [
"true",
"false"
]
}
},
"additionalProperties": false
},
{
"type": "object",
"required": [
"key",
"type",
"value"
],
"properties": {
"key": {
"description": "The attribute's unique identifier.",
"$ref": "#/$defs/NonEmptyString"
},
"type": {
"type": "string",
"const": "Date"
},
"value": {
"description": "A valid ISO 8601 date string.  It's consumer responsibility to parse it.",
"type": "string",
"format": "date-time"
}
},
"additionalProperties": false
},
{
"type": "object",
"required": [
"key",
"type",
"value"
],
"properties": {
"key": {
"description": "The attribute's unique identifier.",
"$ref": "#/$defs/NonEmptyString"
},
"type": {
"type": "string",
"const": "Number"
},
"value": {
"description": "A valid JS number serialized as string. It's consumer responsibility to parse it.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
{
"type": "object",
"required": [
"key",
"type",
"value"
],
"properties": {
"key": {
"description": "The attribute's unique identifier.",
"$ref": "#/$defs/NonEmptyString"
},
"type": {
"type": "string",
"const": "String"
},
"value": {
"description": "Any string value.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
{
"type": "object",
"required": [
"key",
"type",
"value"
],
"properties": {
"key": {
"description": "The attribute's unique identifier.",
"$ref": "#/$defs/NonEmptyString"
},
"type": {
"type": "string",
"const": "JSON"
},
"value": {
"description": "A JSON string. It's consumer responsibility to validate and parse it.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
]
}
```
</details>
"""
union MetadataAttribute = BooleanAttribute | DateAttribute | NumberAttribute | StringAttribute | JsonAttribute

scalar MetadataId

"""
MetadataLicenseType

<details><summary>JSON schema</summary>

```json
{
"type": "string",
"enum": [
"CCO",
"CC BY",
"CC BY-ND",
"CC BY-NC",
"TBNL-C-D-PL-Legal",
"TBNL-C-DT-PL-Legal",
"TBNL-C-ND-PL-Legal",
"TBNL-C-D-NPL-Legal",
"TBNL-C-DT-NPL-Legal",
"TBNL-C-DTSA-PL-Legal",
"TBNL-C-DTSA-NPL-Legal",
"TBNL-C-ND-NPL-Legal",
"TBNL-C-D-PL-Ledger",
"TBNL-C-DT-PL-Ledger",
"TBNL-C-ND-PL-Ledger",
"TBNL-C-D-NPL-Ledger",
"TBNL-C-DT-NPL-Ledger",
"TBNL-C-DTSA-PL-Ledger",
"TBNL-C-DTSA-NPL-Ledger",
"TBNL-C-ND-NPL-Ledger",
"TBNL-NC-D-PL-Legal",
"TBNL-NC-DT-PL-Legal",
"TBNL-NC-ND-PL-Legal",
"TBNL-NC-D-NPL-Legal",
"TBNL-NC-DT-NPL-Legal",
"TBNL-NC-DTSA-PL-Legal",
"TBNL-NC-DTSA-NPL-Legal",
"TBNL-NC-ND-NPL-Legal",
"TBNL-NC-D-PL-Ledger",
"TBNL-NC-DT-PL-Ledger",
"TBNL-NC-ND-PL-Ledger",
"TBNL-NC-D-NPL-Ledger",
"TBNL-NC-DT-NPL-Ledger",
"TBNL-NC-DTSA-PL-Ledger",
"TBNL-NC-DTSA-NPL-Ledger",
"TBNL-NC-ND-NPL-Ledger"
]
}
```
</details>
"""
enum MetadataLicenseType {
  CCO
  CC_BY
  CC_BY_ND
  CC_BY_NC
  TBNL_CD_PL_LEGAL
  TBNL_C_DT_PL_LEGAL
  TBNL_C_ND_PL_LEGAL
  TBNL_CD_NPL_LEGAL
  TBNL_C_DT_NPL_LEGAL
  TBNL_C_DTSA_PL_LEGAL
  TBNL_C_DTSA_NPL_LEGAL
  TBNL_C_ND_NPL_LEGAL
  TBNL_CD_PL_LEDGER
  TBNL_C_DT_PL_LEDGER
  TBNL_C_ND_PL_LEDGER
  TBNL_CD_NPL_LEDGER
  TBNL_C_DT_NPL_LEDGER
  TBNL_C_DTSA_PL_LEDGER
  TBNL_C_DTSA_NPL_LEDGER
  TBNL_C_ND_NPL_LEDGER
  TBNL_NC_D_PL_LEGAL
  TBNL_NC_DT_PL_LEGAL
  TBNL_NC_ND_PL_LEGAL
  TBNL_NC_D_NPL_LEGAL
  TBNL_NC_DT_NPL_LEGAL
  TBNL_NC_DTSA_PL_LEGAL
  TBNL_NC_DTSA_NPL_LEGAL
  TBNL_NC_ND_NPL_LEGAL
  TBNL_NC_D_PL_LEDGER
  TBNL_NC_DT_PL_LEDGER
  TBNL_NC_ND_PL_LEDGER
  TBNL_NC_D_NPL_LEDGER
  TBNL_NC_DT_NPL_LEDGER
  TBNL_NC_DTSA_PL_LEDGER
  TBNL_NC_DTSA_NPL_LEDGER
  TBNL_NC_ND_NPL_LEDGER
}

"""
MintMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/mint/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"id",
"locale",
"mainContentFocus",
"mintLink"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "MINT"
},
"mintLink": {
"description": "The mint item it can be a URL of the known provider like opensea https://opensea.io/assets/ethereum/0xfaa2471e93bd1cee3b0ab381c242ada8e1d1a759/299 or https://zora.co/collect/0x9d90669665607f08005cae4a7098143f554c59ef/39626. The Lens API has an allow list of providers and if the domain does not match it will mark it as failed metadata",
"$ref": "#/$defs/EncryptableUri"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type MintMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: MintMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
MintMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"id",
"locale",
"mainContentFocus",
"mintLink"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "MINT"
},
"mintLink": {
"description": "The mint item it can be a URL of the known provider like opensea https://opensea.io/assets/ethereum/0xfaa2471e93bd1cee3b0ab381c242ada8e1d1a759/299 or https://zora.co/collect/0x9d90669665607f08005cae4a7098143f554c59ef/39626. The Lens API has an allow list of providers and if the domain does not match it will mark it as failed metadata",
"$ref": "#/$defs/EncryptableUri"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
}
```
</details>
"""
type MintMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """
  The mint item it can be a URL of the known provider like opensea https://opensea.io/assets/ethereum/0xfaa2471e93bd1cee3b0ab381c242ada8e1d1a759/299 or https://zora.co/collect/0x9d90669665607f08005cae4a7098143f554c59ef/39626. The Lens API has an allow list of providers and if the domain does not match it will mark it as failed metadata
  """
  mintLink: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

input MlaccountRecommendationsRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  shuffle: Boolean
}

input MlexplorePostsFilter {
  since: Int
}

input MlexplorePostsRequest {
  limit: Int
  cursor: Cursor
  filter: MlexplorePostsFilter
}

input MlpostsForYouRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  shuffle: Boolean
}

type ModFollowerResult {
  createdAt: DateTime!
  follower: Account!
  following: Account!
}

type ModReport {
  createdAt: DateTime!
  reporter: Account!
  reportedAccount: Account!
  reportedPost: Post
  reason: String!
  subreason: String!
  additionalInfo: String
}

input ModReportsRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress
  postId: PostId
}

type Mutation {
  reportAccount(request: ReportAccountRequest!): Void!
  hideManagedAccount(request: HideManagedAccountRequest!): Void!
  unhideManagedAccount(request: UnhideManagedAccountRequest!): Void!

  """
  Set the metadata for the authenticated account.
  
  You MUST be authenticated to use this mutation.
  """
  setAccountMetadata(request: SetAccountMetadataRequest!): SetAccountMetadataResult!
  block(request: BlockRequest!): BlockResult!
  unblock(request: UnblockRequest!): UnblockResult!
  recommendAccount(request: RecommendAccount!): Void!
  undoRecommendedAccount(request: UndoRecommendedAccount!): Void!
  mute(request: MuteRequest!): Void!
  unmute(request: UnmuteRequest!): Void!

  """Authenticate the user with the signed authentication challenge."""
  authenticate(request: SignedAuthChallenge!): AuthenticationResult!

  """
  Generate a new authentication challenge for the given account and app.
  
  The HTTP Origin header MUST be present and match the app's domain.
  """
  challenge(request: ChallengeRequest!): AuthenticationChallenge!

  """
  Revoke an authentication.
  
  You MUST be authenticated to use this mutation.
  """
  revokeAuthentication(request: RevokeAuthenticationRequest!): Void!

  """You MUST be authenticated to use this mutation."""
  switchAccount(request: SwitchAccountRequest!): SwitchAccountResult!
  refresh(request: RefreshRequest!): RefreshResult!

  """
  Issue new authentication tokens from a valid Lens API v2 refresh token.
  
  Use this to seamlessly transition your users from Lens API v2 to Lens API v3 without
  requiring them to re-authenticate.
  
  The HTTP Origin header MUST be present and match the app's domain.
  """
  rolloverRefresh(request: RolloverRefreshRequest!): RefreshResult!

  """
  Create a new post.
  
  You MUST be authenticated to use this mutation.
  """
  post(request: CreatePostRequest!): PostResult!

  """
  Repost a post.
  
  You MUST be authenticated to use this mutation.
  """
  repost(request: CreateRepostRequest!): PostResult!

  """
  Delete a post.
  
  You MUST be authenticated to use this mutation.
  """
  deletePost(request: DeletePostRequest!): DeletePostResult!

  """
  Edit a post.
  
  You MUST be authenticated to use this mutation.
  """
  editPost(request: EditPostRequest!): PostResult!

  """
  Bookmark a post.
  
  You MUST be authenticated to use this mutation.
  """
  bookmarkPost(request: BookmarkPostRequest!): Void!

  """
  Undo bookmark.
  
  You MUST be authenticated to use this mutation.
  """
  undoBookmarkPost(request: BookmarkPostRequest!): Void!
  hideReply(request: HideReplyRequest!): Void!
  unhideReply(request: UnhideReplyRequest!): Void!

  """
  React to a post.
  
  You MUST be authenticated to use this mutation.
  """
  addReaction(request: AddReactionRequest!): AddReactionResult!

  """
  Undo reaction to a post.
  
  You MUST be authenticated to use this mutation.
  """
  undoReaction(request: UndoReactionRequest!): UndoReactionResult!
  reportPost(request: ReportPostRequest!): Void!

  """
  Follow an Account on the global Graph or a specific Graph.
  
  You MUST be authenticated to use this mutation.
  """
  follow(request: CreateFollowRequest!): FollowResult!

  """
  Unfollow an Account on the global Graph or a specific Graph.
  
  You MUST be authenticated to use this mutation.
  """
  unfollow(request: CreateUnfollowRequest!): UnfollowResult!
  setAccountFollowRule(request: CreateAccountFollowRuleRequest!): AccountFollowRuleResult!
  assignUsernameToAccount(request: AssignUsernameToAccountRequest!): AssignUsernameToAccountResult!
  unassignUsernameFromAccount: UnassignUsernameFromAccountResult!
  mlDismissRecommendedAccounts(request: DismissRecommendedAccountsRequest!): Void!
  mlAddPostNotInterested(request: PostNotInterestedRequest!): Void!
  mlUndoPostNotInterested(request: PostNotInterestedRequest!): Void!
  signFrameAction(request: FrameLensManagerEIP712Request!): FrameLensManagerSignatureResult!
}

input MuteRequest {
  account: EvmAddress!
}

union NestedPost = Post | PostReference

type NetworkAddress {
  address: EvmAddress!
  chainId: Int!
}

"""
NftOwnershipConditionContractType

<details><summary>JSON schema</summary>

```json
{
"type": "string",
"enum": [
"ERC721",
"ERC1155"
]
}
```
</details>
"""
enum NftContractType {
  ERC_721
  ERC_1155
}

"""
NftOwnershipCondition

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"contract",
"contractType",
"type"
],
"properties": {
"contract": {
"$ref": "#/$defs/NetworkAddress"
},
"contractType": {
"type": "string",
"enum": [
"ERC721",
"ERC1155"
]
},
"tokenIds": {
"description": "A list of token IDs you want to check ownership of. The list is optional for ERC721, you MUST provide a list of token IDs for ERC1155.",
"type": "array",
"items": {
"type": "string",
"minLength": 1
},
"minItems": 1
},
"type": {
"type": "string",
"const": "NFT_OWNERSHIP"
}
},
"additionalProperties": false
}
```
</details>
"""
type NftOwnershipCondition {
  contract: NetworkAddress!
  contractType: NftContractType!

  """
  A list of token IDs you want to check ownership of. The list is optional for ERC721, you
  MUST provide a list of token IDs for ERC1155.
  """
  tokenIds: [NonEmptyString!]!
  type: String!
}

scalar NonEmptyString

"""The existence of the transaction is not known. Try again later."""
type NotFoundTransaction {
  reason: String!
}

type NumberAttribute {
  """The attribute's unique identifier."""
  key: NonEmptyString!

  """
  A valid JS number serialized as string. It's consumer responsibility to parse it.
  """
  value: NonEmptyString!
}

type OptimisticAccountFollowRule {
  txHash: TxHash!
}

type OptimisticAssignUsernameToAccount {
  txHash: TxHash!
}

type OptimisticBlock {
  txHash: TxHash!
}

type OptimisticUnassignUsernameFromAccount {
  txHash: TxHash!
}

type OptimisticUnblock {
  txHash: TxHash!
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedAccountManagersResult {
  items: [AccountManager!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsBlockedResult {
  items: [AccountBlocked!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsManagedResult {
  items: [AccountManaged!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsResult {
  items: [Account!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedActions {
  items: [ActionInfo!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedActiveAuthenticationsResult {
  items: [ActiveAuthentication!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppsResult {
  items: [App!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedCurrenciesResult {
  items: [Erc20!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedDisputedReports {
  items: [DisputedReport!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFollowRules {
  items: [FollowRule!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedGraphsResult {
  items: [Graph!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedModFollowersResult {
  items: [ModFollowerResult!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedModReports {
  items: [ModReport!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostReactionsResult {
  items: [AccountPostReaction!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostTagsResult {
  items: [Tag!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostsForYouResult {
  items: [PostForYou!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostsResult {
  items: [Post!]!
  pageInfo: PaginatedResultInfo!
}

input PaginatedQuery {
  pageSize: PageSize
  cursor: Cursor
}

type PaginatedResultInfo {
  prev: Cursor
  next: Cursor
}

type PaginatedTimelineResult {
  items: [TimelineItem!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUsernamesResult {
  items: [AccountUsername!]!
  pageInfo: PaginatedResultInfo!
}

type PaymasterParams {
  """The address of the paymaster."""
  paymaster: EvmAddress!

  """The bytestream input for the paymaster."""
  paymasterInput: BlockchainData!
}

"""
The existence of the transaction is known, but its status is not yet known.

The transaction could be:
- waiting to be included in a block
- waiting for a block to be mined
- waiting to be indexed by the Lens Indexer
- waiting for any associated metadata to be snapshotted and indexed
"""
type PendingTransactionStatus {
  blockTimestamp: DateTime!
}

"""
PhysicalAddress

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"country",
"locality"
],
"properties": {
"country": {
"description": "The country name component.",
"$ref": "#/$defs/EncryptableString"
},
"formatted": {
"description": "The full mailing address formatted for display.",
"$ref": "#/$defs/EncryptableString"
},
"locality": {
"description": "The city or locality.",
"$ref": "#/$defs/EncryptableString"
},
"postalCode": {
"description": "The zip or postal code.",
"$ref": "#/$defs/EncryptableString"
},
"region": {
"description": "The state or region.",
"$ref": "#/$defs/EncryptableString"
},
"streetAddress": {
"description": "The street address including house number, street name, P.O. Box, apartment or unit number and extended multi-line address information.",
"$ref": "#/$defs/EncryptableString"
}
},
"additionalProperties": false
}
```
</details>
"""
type PhysicalAddress {
  """The country name component."""
  country: Encryptable!

  """The full mailing address formatted for display."""
  formatted: Encryptable

  """The city or locality."""
  locality: Encryptable!

  """The zip or postal code."""
  postalCode: Encryptable

  """The state or region."""
  region: Encryptable

  """
  The street address including house number, street name, P.O. Box, apartment or unit number
  and extended multi-line address information.
  """
  streetAddress: Encryptable
}

type Post {
  id: PostId!
  author: Account!
  feed: Feed!
  timestamp: DateTime!
  app: App
  metadata: PostMetadata!
  root: NestedPost
  quoteOf: NestedPost
  commentOn: NestedPost
  actions: [PostAction!]!
  operations: LoggedInPostOperations
}

input PostAccountPair {
  postId: PostId!
  account: EvmAddress!
}

union PostAction = SimpleCollectActionSettings | UnknownActionSettings

enum PostActionCategoryType {
  COLLECT
}

input PostActionInput {
  collectAction: CollectActionInput!
  unknownAction: UnknownActionInput!
}

enum PostActionType {
  SIMPLE_COLLECT_ACTION
  UNKNOWN_ACTION
}

input PostActionsRequest {
  limit: Int
  cursor: Cursor
  includeUnknown: Boolean
  includeOnlyCollectActions: Boolean
  onlyVerified: Boolean
}

input PostBookmarksFilter {
  metadata: PostMetadataFilter
}

input PostBookmarksRequest {
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  filter: PostBookmarksFilter
  pageSize: PageSize
  cursor: Cursor
}

enum PostContentWarningType {
  NSFW
  SENSITIVE
  SPOILER
}

type PostForYou {
  post: Post!
  source: ForYouSource!
}

scalar PostId

enum PostMainContentFocus {
  TEXT
  IMAGE
  VIDEO
  AUDIO
  FILE
}

union PostMetadata = ArticleMetadata | AudioMetadata | CheckingInMetadata | EmbedMetadata | EventMetadata | ImageMetadata | LinkMetadata | LivestreamMetadata | MintMetadata | SpaceMetadata | StoryMetadata | TextOnlyMetadata | ThreeDMetadata | TransactionMetadata | VideoMetadata

input PostMetadataContentWarningFilter {
  oneOf: [PostContentWarningType!]!
}

input PostMetadataFilter {
  """The main focus of the post."""
  mainContentFocus: [PostMainContentFocus!]

  """The tags to filter by."""
  tags: PostMetadataTagsFilter

  """The content warning to filter by."""
  contentWarning: PostMetadataContentWarningFilter
}

input PostMetadataTagsFilter {
  oneOf: [String!]
  all: [String!]
}

input PostNotInterestedRequest {
  postId: PostId!
}

type PostReaction {
  reaction: PostReactionType!
  reactedAt: DateTime!
}

enum PostReactionOrderBy {
  DEFAULT
  ACCOUNT_SCORE
}

type PostReactionStatus {
  postId: PostId!
  account: EvmAddress!
  result: Boolean!
}

input PostReactionStatusRequest {
  pairs: [PostAccountPair!]!
  filter: PostReactionsFilter
}

enum PostReactionType {
  UPVOTE
  DOWNVOTE
}

input PostReactionsFilter {
  """The types of reactions to filter by."""
  anyOf: [PostReactionType!]
}

input PostReactionsRequest {
  """The ID of the post to get reactions for."""
  postId: PostId!

  """An optional filter to narrow down the result."""
  filter: PostReactionsFilter

  """The order in which to return the results."""
  orderBy: PostReactionOrderBy
  pageSize: PageSize
  cursor: Cursor
}

type PostReference {
  id: PostId!
}

enum PostReferenceType {
  COMMENT_ON
  REPOST_OF
  QUOTE_OF
}

input PostReferencesRequest {
  referencePostId: PostId!
  referenceTypes: [PostReferenceType!]!
  pageSize: PageSize
  cursor: Cursor
}

enum PostReportReason {
  ANIMAL_ABUSE
  HARASSMENT
  VIOLENCE
  SELF_HARM
  DIRECT_THREAT
  HATE_SPEECH
  NUDITY
  OFFENSIVE
  SCAM
  UNAUTHORIZED_SALE
  IMPERSONATION
  MISLEADING
  MISUSE_HASHTAGS
  UNRELATED
  REPETITIVE
  FAKE_ENGAGEMENT
  MANIPULATION_ALGO
  SOMETHING_ELSE
}

input PostRequest {
  postId: PostId!
}

type PostResponse {
  hash: TxHash!
}

union PostResult = PostResponse | SponsoredTransactionRequest | TransactionRequest | TransactionWillFail

enum PostTagsOrderBy {
  MOST_POPULAR
  ALPHABETICAL
}

input PostTagsRequest {
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  orderBy: PostTagsOrderBy! = MOST_POPULAR
  pageSize: PageSize
  cursor: Cursor
}

enum PostType {
  ROOT
  COMMENT
  REPOST
  QUOTE
}

input PostsFilterRequest {
  authors: [EvmAddress!]
  postTypes: [PostType!]
  metadata: PostMetadataFilter
  apps: [EvmAddress!]
}

input PostsRequest {
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  filter: PostsFilterRequest
  pageSize: PageSize
  cursor: Cursor
}

"""
ProfileOwnershipCondition

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"profileId",
"type"
],
"properties": {
"profileId": {
"$ref": "#/$defs/ProfileId"
},
"type": {
"type": "string",
"const": "PROFILE_OWNERSHIP"
}
},
"additionalProperties": false
}
```
</details>
"""
type ProfileOwnershipCondition {
  profileId: EvmAddress!
  type: String!
}

type Query {
  health: Boolean!
  account(request: AccountRequest!): Account
  accounts(request: AccountsRequest!): [Account!]!
  accountStats(request: AccountStatsRequest!): AccountStats!
  accountGraphsStats(request: AccountGraphsStatsRequest!): AccountGraphsFollowStats!
  accountFeedsStats(request: AccountFeedsStatsRequest!): AccountFeedsStats!
  whoReferencedPost(request: WhoReferencedPostRequest!): PaginatedAccountsResult!
  whoActedOnPost(request: WhoActedOnPostRequest!): PaginatedAccountsResult!
  accountsBlocked(request: AccountsBlockedRequest!): PaginatedAccountsBlockedResult!
  accountsManaged(request: AccountsManagedRequest!): PaginatedAccountsManagedResult!
  accountManagers(request: AccountManagersRequest!): PaginatedAccountManagersResult!
  accountUsernames(request: AccountUsernameRequest!): PaginatedUsernamesResult!
  accountSponsorLimit(request: AccountSponsorRequest!): AccountSponsorResult!
  searchAccounts(request: AccountSearchRequest!): PaginatedAccountsResult!
  lastLoggedInAccount(request: LastLoggedInAccountRequest!): Account
  app(request: AppRequest!): App
  apps(request: AppsRequest!): PaginatedAppsResult!
  accountAuthentications(request: AccountAuthenticationsRequest!): PaginatedActiveAuthenticationsResult!

  """
  Get the current authentication for the user's request.
  
  You MUST be authenticated to use this query.
  """
  currentAuthentication: ActiveAuthentication!
  feed(request: FeedRequest!): Feed
  post(request: PostRequest!): AnyPost
  posts(request: PostsRequest!): PaginatedPostsResult!
  postReferences(request: PostReferencesRequest!): PaginatedPostsResult!
  postTags(request: PostTagsRequest!): PaginatedPostTagsResult!
  postBookmarks(request: PostBookmarksRequest!): PaginatedPostsResult!

  """Get the reactions added to a post."""
  postReactions(request: PostReactionsRequest!): PaginatedPostReactionsResult!
  postReactionStatus(request: PostReactionStatusRequest!): [PostReactionStatus!]!
  searchPosts(request: SearchPostsRequest!): PaginatedPostsResult!
  postActions(request: PostActionsRequest!): PaginatedActions!
  following(request: FollowingRequest!): PaginatedAccountsResult!
  followers(request: FollowersRequest!): PaginatedAccountsResult!
  followersYouKnow(request: FollowersYouKnowRequest!): PaginatedAccountsResult!
  followStatus(request: FollowStatusRequest!): [FollowStatusResult!]!
  graph(request: GraphRequest!): Graph
  graphs(request: GraphsRequest!): PaginatedGraphsResult!
  followRules(request: FollowRulesRequest!): PaginatedFollowRules!
  currencies(request: CurrencyRequest!): PaginatedCurrenciesResult!
  timeline(request: TimelineRequest!): PaginatedTimelineResult!
  timelineHighlights(request: TimelineHighlightsRequest!): PaginatedPostsResult!
  mlAccountRecommendations(request: MlaccountRecommendationsRequest!): PaginatedAccountsResult!
  mlPostsForYou(request: MlpostsForYouRequest!): PaginatedPostsForYouResult!
  mlPostsExplore(request: MlexplorePostsRequest!): PaginatedPostsResult

  """Get the status of a transaction by its hash."""
  transactionStatus(request: TransactionStatusRequest!): TransactionStatusResult!
  debugMetadata(request: DebugPostMetadataRequest!): DebugPostMetadataResult!
  debugTransactionStatusFailed(request: DebugTransactionStatusRequest!): DebugTransactionStatusResult
  createFrameTypedData(request: FrameEIP712Request!): CreateFrameEIP712TypedData!
  verifyFrameSignature(request: FrameVerifySignature!): FrameVerifySignatureResult!
  modFollowersHistory(request: PaginatedQuery!): PaginatedModFollowersResult!
  modLatestReports(request: ModReportsRequest!): PaginatedModReports!
  modDisputedReports(request: PaginatedQuery!): PaginatedDisputedReports!
  _service: _Service!
}

input RecipientDataInput {
  recipient: EvmAddress!
  split: Float!
}

type RecipientDataOutput {
  recipient: EvmAddress!
  split: Float!
}

input RecommendAccount {
  account: EvmAddress!
}

input ReferencingPostInput {
  """The post to reference."""
  post: PostId!
}

input RefreshRequest {
  refreshToken: RefreshToken!
}

union RefreshResult = AuthenticationTokens | ForbiddenError

scalar RefreshToken

input ReportAccountRequest {
  account: EvmAddress!
  referencePost: [PostId!]
  reason: AccountReportReason!
  additionalComments: String
}

input ReportPostRequest {
  postId: PostId!
  reason: PostReportReason!
  additionalComments: String
}

type Repost {
  id: PostId!
  author: Account!
  timestamp: DateTime!
  app: App
  repostOf: Post!
}

input RevokeAuthenticationRequest {
  authenticationId: UUID!
}

input RolloverRefreshRequest {
  """The app that new tokens will be issued for."""
  app: EvmAddress!

  """A valid Lens API v2 refresh token for a Profile session."""
  refreshToken: LegacyRefreshToken!
}

input SearchPostsFilter {
  """The post types to filter by."""
  postTypes: [PostType!]

  """The optional metadata filter."""
  metadata: PostMetadataFilter
}

input SearchPostsRequest {
  """
  The query text to search for in the post content or metadata tags.
  The passed strings supports web search syntax similar to the search engines:
  - individual words match independently.
  - double-quoted phrases match as a single unit.
  - the word or (case-insensitive) specifies an or condition between two words or phrases
  - a "-" prefix specifies to not match the following word or phrase.
  """
  query: String!

  """The feeds to search in."""
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]

  """The optional post types to filter by."""
  filter: SearchPostsFilter
  pageSize: PageSize
  cursor: Cursor
}

input SetAccountMetadataRequest {
  metadataUri: URI!
}

type SetAccountMetadataResponse {
  hash: TxHash!
}

union SetAccountMetadataResult = SetAccountMetadataResponse | SponsoredTransactionRequest | TransactionRequest | TransactionWillFail

scalar Signature

input SignedAuthChallenge {
  id: UUID!
  signature: Signature!
}

input SimpleCollectActionInput {
  amount: AmountInput
  referralFee: Float
  recipient: EvmAddress
  collectLimit: String
  followerOnly: Boolean!
  endsAt: DateTime
  recipients: [RecipientDataInput!]
}

type SimpleCollectActionSettings {
  type: PostActionType!
  contract: NetworkAddress!
  amount: Amount!
  collectNft: EvmAddress
  collectLimit: String
  followerOnly: Boolean!
  recipient: EvmAddress!
  referralFee: Float!
  endsAt: DateTime
  recipients: [RecipientDataOutput!]!
}

"""
SpaceMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/space/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"id",
"link",
"locale",
"mainContentFocus",
"startsAt",
"title"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"link": {
"description": "The space join link.",
"$ref": "#/$defs/EncryptableUri"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "SPACE"
},
"startsAt": {
"description": "The space start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`).",
"$ref": "#/$defs/EncryptableDateTime"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The space title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type SpaceMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: SpaceMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
SpaceMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"id",
"link",
"locale",
"mainContentFocus",
"startsAt",
"title"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"link": {
"description": "The space join link.",
"$ref": "#/$defs/EncryptableUri"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "SPACE"
},
"startsAt": {
"description": "The space start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`).",
"$ref": "#/$defs/EncryptableDateTime"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The space title.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
```
</details>
"""
type SpaceMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!

  """The space join link."""
  link: Encryptable!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """The space start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The space title."""
  title: NonEmptyString!
}

enum SponsorLimitType {
  HOUR
  DAY
  WEEK
  MONTH
}

type SponsoredTransactionRequest {
  """
  The encoded EIP-712 transaction request.
  
  Use a parser that supports ZKsync EIP-712 transaction to decode this data into a
  transaction request object for your library (e.g., zksync/ethers, viem/zksync).
  """
  encoded: EncodedTransaction!

  """
  The raw transaction request object.
  
  Use this object if your library does not have a parser for the encoded transaction data.
  """
  raw: Eip712TransactionRequest!
}

"""
StoryMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/story/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"asset",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"asset": {
"description": "The story asset.",
"$ref": "#/$defs/AnyMedia"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "STORY"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type StoryMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: StoryMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
StoryMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"asset",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"asset": {
"description": "The story asset.",
"$ref": "#/$defs/AnyMedia"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "STORY"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
}
```
</details>
"""
type StoryMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The story asset."""
  asset: AnyMedia!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

type StringAttribute {
  """The attribute's unique identifier."""
  key: NonEmptyString!

  """Any string value."""
  value: NonEmptyString!
}

input SwitchAccountRequest {
  account: EvmAddress!
}

union SwitchAccountResult = AuthenticationTokens | ForbiddenError

scalar Tag

"""
TextOnlyMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/text-only/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"content",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "TEXT_ONLY"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type TextOnlyMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: TextOnlyMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
TextOnlyMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"content",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "TEXT_ONLY"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
}
```
</details>
"""
type TextOnlyMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  content: Encryptable!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

"""
ThreeDMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/3d/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"assets",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"assets": {
"description": "The 3D items for the publication",
"type": "array",
"items": {
"type": "object",
"required": [
"format",
"playerUrl",
"uri"
],
"properties": {
"format": {
"description": "The 3D format of the asset.",
"type": "string",
"enum": [
"gLTF/GLB",
"FBX",
"VRM",
"OBJ"
]
},
"license": {
"description": "The license regulating the use of the 3D asset.",
"$ref": "#/$defs/MetadataLicenseType"
},
"playerUrl": {
"description": "The URL of the recommended web based 3D player to use to view the 3D asset.",
"$ref": "#/$defs/Uri"
},
"uri": {
"description": "The URI of the 3D asset zip file.",
"$ref": "#/$defs/Uri"
},
"zipPath": {
"description": "Path in extracted zip. Relative. 3D start point, MUST be 3D file type.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"minItems": 1
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "3D"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type ThreeDMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: ThreeDMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
ThreeDMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"assets",
"id",
"locale",
"mainContentFocus"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"assets": {
"description": "The 3D items for the publication",
"type": "array",
"items": {
"type": "object",
"required": [
"format",
"playerUrl",
"uri"
],
"properties": {
"format": {
"description": "The 3D format of the asset.",
"type": "string",
"enum": [
"gLTF/GLB",
"FBX",
"VRM",
"OBJ"
]
},
"license": {
"description": "The license regulating the use of the 3D asset.",
"$ref": "#/$defs/MetadataLicenseType"
},
"playerUrl": {
"description": "The URL of the recommended web based 3D player to use to view the 3D asset.",
"$ref": "#/$defs/Uri"
},
"uri": {
"description": "The URI of the 3D asset zip file.",
"$ref": "#/$defs/Uri"
},
"zipPath": {
"description": "Path in extracted zip. Relative. 3D start point, MUST be 3D file type.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
},
"minItems": 1
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "3D"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
}
},
"additionalProperties": false
}
```
</details>
"""
type ThreeDMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The 3D items for the publication"""
  assets: [ThreeDMetadataLensAssetsItem!]!

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

"""
ThreeDMetadataLensAssetsItem

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"format",
"playerUrl",
"uri"
],
"properties": {
"format": {
"description": "The 3D format of the asset.",
"type": "string",
"enum": [
"gLTF/GLB",
"FBX",
"VRM",
"OBJ"
]
},
"license": {
"description": "The license regulating the use of the 3D asset.",
"$ref": "#/$defs/MetadataLicenseType"
},
"playerUrl": {
"description": "The URL of the recommended web based 3D player to use to view the 3D asset.",
"$ref": "#/$defs/Uri"
},
"uri": {
"description": "The URI of the 3D asset zip file.",
"$ref": "#/$defs/Uri"
},
"zipPath": {
"description": "Path in extracted zip. Relative. 3D start point, MUST be 3D file type.",
"$ref": "#/$defs/NonEmptyString"
}
},
"additionalProperties": false
}
```
</details>
"""
type ThreeDMetadataLensAssetsItem {
  """The 3D format of the asset."""
  format: ThreeDMetadataLensAssetsItemFormat!

  """The license regulating the use of the 3D asset."""
  license: MetadataLicenseType

  """
  The URL of the recommended web based 3D player to use to view the 3D asset.
  """
  playerUrl: URI!

  """The URI of the 3D asset zip file."""
  uri: URI!

  """Path in extracted zip. Relative. 3D start point, MUST be 3D file type."""
  zipPath: NonEmptyString
}

"""
The 3D format of the asset.

<details><summary>JSON schema</summary>

```json
{
"description": "The 3D format of the asset.",
"type": "string",
"enum": [
"gLTF/GLB",
"FBX",
"VRM",
"OBJ"
]
}
```
</details>
"""
enum ThreeDMetadataLensAssetsItemFormat {
  G_LTF_GLB
  FBX
  VRM
  OBJ
}

enum TimelineEventItemType {
  POST
  COMMENT
  MIRROR
  QUOTE
}

input TimelineFilter {
  eventType: [TimelineEventItemType!]
  metadata: PostMetadataFilter
}

input TimelineHighlightsFilter {
  eventType: [TimelineEventItemType!]
  metadata: PostMetadataFilter
}

input TimelineHighlightsRequest {
  limit: Int
  cursor: Cursor
  account: EvmAddress!
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  filter: TimelineHighlightsFilter
}

type TimelineItem {
  id: String!
  primary: Post!
  mirrors: [Post!]!
  comments: [Post!]!
}

input TimelineRequest {
  cursor: Cursor
  account: EvmAddress!
  forFeeds: [EvmAddress!]! = ["0xa8E1e68E3195d8e150A95CF2D0F0AfaE154f8fa5"]
  filter: TimelineFilter
}

"""
AccessCondition

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"criteria",
"type"
],
"properties": {
"criteria": {
"type": "array",
"items": {
"anyOf": [
{
"type": "object",
"required": [
"criteria",
"type"
],
"properties": {
"criteria": {
"type": "array",
"items": {
"anyOf": [
{
"$ref": "#/$defs/NftOwnershipCondition"
},
{
"$ref": "#/$defs/Erc20OwnershipCondition"
},
{
"$ref": "#/$defs/EoaOwnershipCondition"
},
{
"$ref": "#/$defs/ProfileOwnershipCondition"
},
{
"$ref": "#/$defs/FollowCondition"
},
{
"$ref": "#/$defs/CollectCondition"
},
{
"$ref": "#/$defs/AdvancedContractCondition"
}
]
},
"maxItems": 5
},
"type": {
"type": "string",
"const": "AND"
}
},
"additionalProperties": false
},
{
"$ref": "#/$defs/CollectCondition"
},
{
"$ref": "#/$defs/AdvancedContractCondition"
},
{
"$ref": "#/$defs/EoaOwnershipCondition"
},
{
"$ref": "#/$defs/Erc20OwnershipCondition"
},
{
"$ref": "#/$defs/FollowCondition"
},
{
"$ref": "#/$defs/NftOwnershipCondition"
},
{
"type": "object",
"required": [
"criteria",
"type"
],
"properties": {
"criteria": {
"type": "array",
"items": {
"anyOf": [
{
"$ref": "#/$defs/NftOwnershipCondition"
},
{
"$ref": "#/$defs/Erc20OwnershipCondition"
},
{
"$ref": "#/$defs/EoaOwnershipCondition"
},
{
"$ref": "#/$defs/ProfileOwnershipCondition"
},
{
"$ref": "#/$defs/FollowCondition"
},
{
"$ref": "#/$defs/CollectCondition"
},
{
"$ref": "#/$defs/AdvancedContractCondition"
}
]
},
"maxItems": 5
},
"type": {
"type": "string",
"const": "OR"
}
},
"additionalProperties": false
},
{
"$ref": "#/$defs/ProfileOwnershipCondition"
}
]
},
"maxItems": 5
},
"type": {
"type": "string",
"const": "OR"
}
},
"additionalProperties": false
}
```
</details>
"""
type TopLevelAccessCondition {
  criteria: [AnyAccessCondition!]!
  type: String!
}

"""
TransactionMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/transaction/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"chainId",
"id",
"locale",
"mainContentFocus",
"txHash",
"type"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"chainId": {
"description": "The Chain Id.",
"$ref": "#/$defs/ChainId"
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "TRANSACTION"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"txHash": {
"description": "The transaction hash.",
"$ref": "#/$defs/EncryptableString"
},
"type": {
"description": "The type of transaction.",
"type": "string",
"enum": [
"ERC721",
"ERC20",
"OTHER"
]
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type TransactionMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: TransactionMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
TransactionMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"chainId",
"id",
"locale",
"mainContentFocus",
"txHash",
"type"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"chainId": {
"description": "The Chain Id.",
"$ref": "#/$defs/ChainId"
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"const": "TRANSACTION"
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"txHash": {
"description": "The transaction hash.",
"$ref": "#/$defs/EncryptableString"
},
"type": {
"description": "The type of transaction.",
"type": "string",
"enum": [
"ERC721",
"ERC20",
"OTHER"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type TransactionMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """The Chain Id."""
  chainId: ChainId!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: String!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The transaction hash."""
  txHash: Encryptable!

  """The type of transaction."""
  type: TransactionMetadataLensType!
}

"""
The type of transaction.

<details><summary>JSON schema</summary>

```json
{
"description": "The type of transaction.",
"type": "string",
"enum": [
"ERC721",
"ERC20",
"OTHER"
]
}
```
</details>
"""
enum TransactionMetadataLensType {
  ERC_721
  ERC_20
  OTHER
}

type TransactionRequest {
  """
  The encoded EIP-1559 transaction request.
  
  Use a parser to decode this data into a transaction request object
  for your library (e.g., ethers, viem).
  """
  encoded: EncodedTransaction!

  """
  The raw transaction request object.
  
  Use this object if your library does not have a parser for the encoded transaction data.
  """
  raw: Eip1559TransactionRequest!
}

input TransactionStatusRequest {
  txHash: TxHash!
}

union TransactionStatusResult = PendingTransactionStatus | FinishedTransactionStatus | FailedTransactionStatus | NotFoundTransaction

type TransactionWillFail {
  reason: String!
}

enum TriStateValue {
  YES
  NO
  UNKNOWN
}

scalar TxHash

scalar URI

scalar URL

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID @specifiedBy(url: "http://tools.ietf.org/html/rfc4122")

type UnassignUsernameFromAccountError {
  error: UnlinkUsernameFromAccountErrorType!
}

union UnassignUsernameFromAccountResult = OptimisticUnassignUsernameFromAccount | SponsoredTransactionRequest | TransactionRequest | UnassignUsernameFromAccountError

type UnblockError {
  error: UnblockErrorType!
}

enum UnblockErrorType {
  UNKNOWN
  NOT_BLOCKED
  UNAUTHORIZED
}

input UnblockRequest {
  account: EvmAddress!
}

union UnblockResult = OptimisticUnblock | SponsoredTransactionRequest | TransactionRequest | UnblockError

type UndoReactionFailure {
  reason: String!
}

input UndoReactionRequest {
  """The reaction to add."""
  reaction: PostReactionType!

  """The post to react to."""
  postId: PostId!
}

type UndoReactionResponse {
  success: Boolean!
}

union UndoReactionResult = UndoReactionResponse | UndoReactionFailure

input UndoRecommendedAccount {
  account: EvmAddress!
}

type UnfollowResponse {
  hash: TxHash!
}

union UnfollowResult = UnfollowResponse | SponsoredTransactionRequest | TransactionRequest | TransactionWillFail

input UnhideManagedAccountRequest {
  account: EvmAddress!
}

input UnhideReplyRequest {
  postId: PostId!
}

type UnknownAction {
  name: String!
  contract: NetworkAddress!
}

input UnknownActionInput {
  address: EvmAddress!
  data: String!
}

type UnknownActionSettings {
  type: PostActionType!
  initializeCalldata: BlockchainData
  initializeResultData: BlockchainData
  verified: Boolean!
  contract: NetworkAddress!
  collectNft: EvmAddress
}

input UnknownFeedRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

input UnknownFollowRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

input UnknownGraphRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

enum UnlinkUsernameFromAccountErrorType {
  UNKNOWN
  USERNAME_NOT_LINKED
  UNAUTHORIZED
}

input UnmuteRequest {
  account: EvmAddress!
}

scalar UsernameValue

"""
VideoMetadata

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"$schema",
"lens"
],
"properties": {
"$schema": {
"type": "string",
"const": "https://json-schemas.lens.dev/publications/video/3.0.0.json"
},
"animation_url": {
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"anyOf": [
{
"description": "A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4, M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA. Animation_url also supports HTML pages, allowing you to build rich experiences and interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths within the HTML page are now supported. However, access to browser extensions is not supported.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"attributes": {
"description": "These are the attributes for the item, which will show up on the OpenSea and others NFT trading websites on the item.",
"type": "array",
"items": {
"$ref": "#/$defs/MarketplaceMetadataAttribute"
}
},
"description": {
"description": "A human-readable description of the item. It could be plain text or markdown.",
"anyOf": [
{
"description": "A human-readable description of the item. It could be plain text or markdown.",
"$ref": "#/$defs/NonEmptyString"
},
{
"type": "null"
}
]
},
"external_url": {
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"anyOf": [
{
"description": "This is the URL that will appear below the asset's image on OpenSea and others etc. and will allow users to leave OpenSea and view the item on the site.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"image": {
"description": "Marketplaces will store any NFT image here.",
"anyOf": [
{
"description": "Marketplaces will store any NFT image here.",
"$ref": "#/$defs/Uri"
},
{
"type": "null"
}
]
},
"lens": {
"type": "object",
"required": [
"id",
"locale",
"mainContentFocus",
"video"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"enum": [
"SHORT_VIDEO",
"VIDEO"
]
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The optional video title.",
"$ref": "#/$defs/NonEmptyString"
},
"video": {
"$ref": "#/$defs/MediaVideo"
}
},
"additionalProperties": false
},
"name": {
"description": "Name of the NFT item.",
"type": "string"
},
"signature": {
"description": "A cryptographic signature of the Lens metadata.",
"$ref": "#/$defs/Signature"
}
},
"additionalProperties": true
}
```
</details>
"""
type VideoMetadata {
  """
  A URL to a multi-media attachment for the item. The file extensions GLTF, GLB, WEBM, MP4,
  M4V, OGV, and OGG are supported, along with the audio-only extensions MP3, WAV, and OGA.
  Animation_url also supports HTML pages, allowing you to build rich experiences and
  interactive NFTs using JavaScript canvas, WebGL, and more. Scripts and relative paths
  within the HTML page are now supported. However, access to browser extensions is not
  supported.
  """
  animationUrl: URI

  """
  These are the attributes for the item, which will show up on the OpenSea and others NFT
  trading websites on the item.
  """
  attributes: [MarketplaceMetadataAttribute!]!

  """
  A human-readable description of the item. It could be plain text or markdown.
  """
  description: NonEmptyString

  """
  This is the URL that will appear below the asset's image on OpenSea and others etc. and
  will allow users to leave OpenSea and view the item on the site.
  """
  externalUrl: URI

  """Marketplaces will store any NFT image here."""
  image: URI
  lens: VideoMetadataLens!

  """Name of the NFT item."""
  name: String
  schema: String!

  """A cryptographic signature of the Lens metadata."""
  signature: Signature
}

"""
VideoMetadataLens

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"id",
"locale",
"mainContentFocus",
"video"
],
"properties": {
"appId": {
"description": "The App Id that this publication belongs to.",
"$ref": "#/$defs/AppId"
},
"attachments": {
"description": "The other attachments you want to include with it.",
"type": "array",
"items": {
"$ref": "#/$defs/AnyMedia"
},
"minItems": 1
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard. Over time, common attributes will be added to the standard and their usage as arbitrary attributes will be discouraged.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"maxItems": 20,
"minItems": 1
},
"content": {
"description": "Optional markdown content.",
"$ref": "#/$defs/EncryptableMarkdown"
},
"contentWarning": {
"description": "Specify a content warning.",
"$ref": "#/$defs/ContentWarning"
},
"encryptedWith": {
"$ref": "#/$defs/PublicationEncryptionStrategy"
},
"hideFromFeed": {
"description": "Determine if the publication should not be shown in any feed.",
"type": "boolean"
},
"id": {
"$ref": "#/$defs/MetadataId"
},
"locale": {
"$ref": "#/$defs/Locale"
},
"mainContentFocus": {
"description": "The main focus of the publication.",
"type": "string",
"enum": [
"SHORT_VIDEO",
"VIDEO"
]
},
"tags": {
"description": "An arbitrary list of tags.",
"type": "array",
"items": {
"$ref": "#/$defs/Tag"
},
"maxItems": 20,
"uniqueItems": true
},
"title": {
"description": "The optional video title.",
"$ref": "#/$defs/NonEmptyString"
},
"video": {
"$ref": "#/$defs/MediaVideo"
}
},
"additionalProperties": false
}
```
</details>
"""
type VideoMetadataLens {
  """The App Id that this publication belongs to."""
  appId: AppId

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Optional markdown content."""
  content: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """Determine if the publication should not be shown in any feed."""
  hideFromFeed: Boolean
  id: MetadataId!
  locale: Locale!

  """The main focus of the publication."""
  mainContentFocus: VideoMetadataLensMainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional video title."""
  title: NonEmptyString
  video: MediaVideo!
}

"""
The main focus of the publication.

<details><summary>JSON schema</summary>

```json
{
"description": "The main focus of the publication.",
"type": "string",
"enum": [
"SHORT_VIDEO",
"VIDEO"
]
}
```
</details>
"""
enum VideoMetadataLensMainContentFocus {
  SHORT_VIDEO
  VIDEO
}

scalar Void

input WhoActedOnPostFilter {
  anyOf: [ActionFilter!]!
}

enum WhoActedOnPostOrderBy {
  LAST_ACTIONED
  FIRST_ACTIONED
  ACCOUNT_SCORE
}

input WhoActedOnPostRequest {
  postId: PostId!
  filter: WhoActedOnPostFilter
  orderBy: WhoActedOnPostOrderBy
  limit: Int
  cursor: Cursor
}

enum WhoReferencedPostOrderBy {
  LAST_ACTIONED
  FIRST_ACTIONED
  ACCOUNT_SCORE
}

input WhoReferencedPostRequest {
  postId: PostId!
  referenceTypes: [PostReferenceType!]
  orderBy: WhoReferencedPostOrderBy
  limit: Int
  cursor: Cursor
}

"""The signature was not signed by the expected signer."""
type WrongSignerError {
  reason: String!
}

type _Service {
  sdl: String
}