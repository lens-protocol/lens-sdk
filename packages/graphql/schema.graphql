"""
The comparison operator to use. In case of boolean functions you can only use EQUAL or NOT_EQUAL
"""
enum AccessConditionComparison {
  EQUAL
  NOT_EQUAL
  GREATER_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN
  LESS_THAN_OR_EQUAL
}

"""AccessConditionType"""
union AccessConditionType = NftOwnershipCondition | Erc20OwnershipCondition | EoaOwnershipCondition | ProfileOwnershipCondition | FollowCondition | CollectCondition | AdvancedContractCondition

scalar AccessToken

type Account {
  address: EvmAddress!

  """
  The owner of the account - note if the Account is not a lens account this will return the
  address of the account itself.
  """
  owner: EvmAddress!

  """The score of the account."""
  score: Int!

  """The metadata of the account."""
  metadata: AccountMetadata

  """The username linked to the account."""
  username(request: AccountUsernameRequest): Username

  """The operations for the account."""
  operations: LoggedInAccountOperations

  """Get the rules for the account."""
  rules(request: RuleInput): FollowRulesConfig!
}

union AccountAvailable = AccountManaged | AccountOwned

type AccountBlocked {
  account: Account!
  blockedAt: DateTime!
}

type AccountFeedsStats {
  """The total number of posts."""
  posts: Int!

  """The total number of comments."""
  comments: Int!

  """The total number of reposts."""
  reposts: Int!

  """The total number of quotes."""
  quotes: Int!

  """The total number of times the account has reacted."""
  reacted: Int!

  """The total number of reactions."""
  reactions: Int!

  """The total number of collects."""
  collects: Int!
}

input AccountFeedsStatsRequest {
  """The account to get stats for."""
  account: EvmAddress!

  """The feeds to get stats for."""
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]
}

type AccountGraphsFollowStats {
  """The total number of followers."""
  followers: Int!

  """The total number of following."""
  following: Int!
}

input AccountGraphsStatsRequest {
  """The account to get stats for."""
  account: EvmAddress!

  """The graphs to get stats for."""
  forGraphs: [EvmAddress!]! = ["0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"]
}

type AccountManaged {
  """The account you are managing."""
  account: Account!

  """The permissions you have on the account."""
  permissions: AccountManagerPermissions!

  """The date the account management was added."""
  addedAt: DateTime!
}

type AccountManager {
  """The address of the account manager."""
  manager: EvmAddress!

  """Whether the account manager is a Lens manager."""
  isLensManager: Boolean!

  """The permissions the account manager has."""
  permissions: AccountManagerPermissions!

  """The date the account manager was added."""
  addedAt: DateTime!
}

input AccountManagerChallengeRequest {
  """
  The App you intend to authenticate with.
  
  It MUST be a valid App address.
  Note: On the testnet, it will default to `0x90C8C68D0ABFB40D4FCD72316A65E42161520BC3`, the
  playground app. This is to make it easier if you forget to set it. This may change in the
  future.
  """
  app: EvmAddress! = "0xe5439696f4057aF073c0FB2dc6e5e755392922e1"

  """The address of the Lens Account."""
  account: EvmAddress!

  """The address of the Account Manager."""
  manager: EvmAddress!
}

type AccountManagerPermissions {
  """Whether the account can execute transactions."""
  canExecuteTransactions: Boolean!

  """Whether the account can transfer tokens."""
  canTransferTokens: Boolean!

  """Whether the account can transfer native tokens."""
  canTransferNative: Boolean!

  """Whether the account can set the metadata URI."""
  canSetMetadataUri: Boolean!
}

input AccountManagerPermissionsInput {
  """Whether the account can execute transactions."""
  canExecuteTransactions: Boolean!

  """Whether the account can transfer tokens."""
  canTransferTokens: Boolean!

  """Whether the account can transfer native tokens."""
  canTransferNative: Boolean!

  """Whether the account can set the metadata URI."""
  canSetMetadataUri: Boolean!
}

input AccountManagersRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type AccountMention {
  """The account that was mentioned."""
  account: EvmAddress!

  """The namespace that was used in a mention."""
  namespace: EvmAddress!

  """
  The replacement information.
  Use to replace mentions in the post content.
  """
  replace: AccountMentionReplace!
}

type AccountMentionReplace {
  from: String!
  to: String!
}

type AccountMetadata {
  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """The Account bio as markdown."""
  bio: String

  """The Account cover picture."""
  coverPicture: URI

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """The Account display name."""
  name: String

  """The Account picture."""
  picture: URI
}

type AccountOwned {
  """The account you own."""
  account: Account!

  """The date the account was created."""
  addedAt: DateTime!
}

input AccountOwnerChallengeRequest {
  """
  The App you intend to authenticate with.
  
  It MUST be a valid App address.
  Note: On the testnet, it will default to `0x90C8C68D0ABFB40D4FCD72316A65E42161520BC3`, the
  playground app. This is to make it easier if you forget to set it. This may change in the
  future.
  """
  app: EvmAddress! = "0xe5439696f4057aF073c0FB2dc6e5e755392922e1"

  """The address of the Lens Account."""
  account: EvmAddress!

  """The address of the Account Owner."""
  owner: EvmAddress!
}

type AccountPostReaction {
  account: Account!
  reactions: [PostReaction!]!
}

enum AccountReportReason {
  IMPERSONATION
  REPETITIVE_SPAM
  OTHER
}

input AccountRequest {
  """The account address."""
  address: EvmAddress

  """The username."""
  username: UsernameInput

  """The legacy profile ID."""
  legacyProfileId: LegacyProfileId

  """The transaction hash you created the account with."""
  txHash: TxHash
}

enum AccountSearchOrderBy {
  DEFAULT
  ACCOUNT_SCORE
}

input AccountSearchRequest {
  """The local name to search for."""
  localName: String!

  """Optional. The username prefix to search for."""
  namespace: [String!]

  """The order by."""
  orderBy: AccountSearchOrderBy! = DEFAULT

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type AccountStats {
  """The stats for the feeds."""
  feedStats: AccountFeedsStats!

  """The stats for the graphs."""
  graphFollowStats: AccountGraphsFollowStats!
}

input AccountStatsRequest {
  """The account to get stats for."""
  account: EvmAddress!

  """The feeds to get stats for."""
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]

  """The graphs to get stats for."""
  forGraphs: [EvmAddress!]! = ["0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"]
}

input AccountUsernameRequest {
  """The namespace to get account assigned username"""
  namespace: EvmAddress! = "0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"
}

input AccountsAvailableRequest {
  """The account to get managed by."""
  managedBy: EvmAddress!

  """Whether to include owned accounts. Defaults to true."""
  includeOwned: Boolean! = true

  """The visibility of hidden accounts."""
  hiddenFilter: ManagedAccountsVisibility! = ALL

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input AccountsBlockedRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input AccountsRequest {
  """The addresses to get."""
  addresses: [EvmAddress!]

  """The usernames to get."""
  usernames: [UsernameInput!]

  """The legacy profile IDs to get."""
  legacyProfileIds: [LegacyProfileId!]
}

input ActionFilter {
  address: EvmAddress
  actionType: PostActionType
  category: PostActionCategoryType
}

union ActionInfo = KnownAction | UnknownAction

type ActionInputInfo {
  name: String!
  type: String!
}

input AddAccountManagerRequest {
  """The address to add as a manager."""
  address: EvmAddress!

  """The permissions to give the account manager."""
  permissions: AccountManagerPermissionsInput!
}

union AddAccountManagerResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input AddAdminsRequest {
  """
  The graph/app/sponsor/feed/username/group address which manages these admins
  """
  address: EvmAddress!

  """The addresses to add as admins"""
  admins: [EvmAddress!]!
}

union AddAdminsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input AddAppAuthorizationEndpointRequest {
  """The app."""
  app: EvmAddress!

  """The app authorization endpoint."""
  endpoint: URL!
}

input AddAppFeedsRequest {
  """The app to update"""
  app: EvmAddress!

  """The app feeds (max 10 per request)"""
  feeds: [EvmAddress!]!
}

union AddAppFeedsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input AddAppGroupsRequest {
  """The app to update"""
  app: EvmAddress!

  """The app groups (max 10 per request)"""
  groups: [EvmAddress!]!
}

union AddAppGroupsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input AddAppSignersRequest {
  """The app to update"""
  app: EvmAddress!

  """The app signers (max 10 per request)"""
  signers: [EvmAddress!]!
}

union AddAppSignersResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type AddReactionFailure {
  reason: String!
}

input AddReactionRequest {
  """The reaction to add."""
  reaction: PostReactionType!

  """The post to react to."""
  post: PostId!
}

type AddReactionResponse {
  success: Boolean!
}

union AddReactionResult = AddReactionResponse | AddReactionFailure

type Admin {
  address: EvmAddress!
  addedAt: DateTime!
}

input AdminsForRequest {
  """The graph/app/sponsor/feed/username/group address"""
  address: EvmAddress!
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type AdvancedContractCondition {
  """
  The contract ABI. Has to be in human readable single string format containing the signature of the function you want to call. See https://docs.ethers.org/v5/api/utils/abi/formats/#abi-formats--human-readable-abi for more info
  """
  abi: String!

  """
  The comparison operator to use. In case of boolean functions you can only use EQUAL or
  NOT_EQUAL
  """
  comparison: AccessConditionComparison!
  contract: NetworkAddress!

  """The name of the function you want to call"""
  functionName: String!

  """
  The parameters to pass to the function. Must be exactly matching the function arguments.
  You *must* pass in the `:userAddress` parameter to represent the decrypter address. Any
  array or tuple arguments, must be stringified JSON arrays.
  """
  params: [String!]!
  type: String!

  """The comparison value. Accepts 'true', 'false' or a number"""
  value: AdvancedContractConditionValue!
}

scalar AdvancedContractConditionValue

type Amount {
  asset: Asset!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!
}

input AmountInput {
  """
  The token address. To represent the native token, use the
  0x000000000000000000000000000000000000800a.
  """
  currency: EvmAddress!

  """
  Token value in its main unit (e.g., 1.5 DAI), not in the smallest fraction (e.g.,
  wei).
  """
  value: BigDecimal!
}

"""AccessConditionCriteriaItem"""
union AnyAccessCondition = BooleanAndCondition | BooleanOrCondition | CollectCondition | AdvancedContractCondition | EoaOwnershipCondition | Erc20OwnershipCondition | FollowCondition | NftOwnershipCondition | ProfileOwnershipCondition

"""
AnyMedia

<details><summary>JSON schema</summary>

```json
{
"anyOf": [
{
"$ref": "#/$defs/MediaAudio"
},
{
"$ref": "#/$defs/MediaImage"
},
{
"$ref": "#/$defs/MediaVideo"
}
]
}
```
</details>
"""
union AnyMedia = MediaAudio | MediaImage | MediaVideo

union AnyPost = Post | Repost

type App {
  address: EvmAddress!
  graphAddress: EvmAddress
  sponsorshipAddress: EvmAddress
  defaultFeedAddress: EvmAddress
  namespaceAddress: EvmAddress
  treasuryAddress: EvmAddress
  verificationEnabled: Boolean!
  createdAt: DateTime!
  metadata: AppMetadata
  owner: EvmAddress!
}

type AppFeed {
  feed: EvmAddress!
  timestamp: DateTime!
}

input AppFeedsRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The app address"""
  app: EvmAddress!
}

input AppGroupsRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The app address"""
  app: EvmAddress!
}

type AppMetadata {
  """
  An optional short and detailed description of the app, explaining its features and purpose.
  """
  description: String

  """The Developer of the app."""
  developer: String!

  """The Logo icon for the app."""
  logo: URI

  """The name of the app."""
  name: String!

  """The tagline of the app."""
  tagline: String

  """The platforms supported by the app."""
  platforms: [AppMetadataLensPlatformsItem!]!

  """The privacy policy for the app."""
  privacyPolicy: URI

  """The terms of service for the app."""
  termsOfService: URI

  """The url of the app."""
  url: URI!
}

enum AppMetadataLensPlatformsItem {
  WEB
  IOS
  ANDROID
}

input AppRequest {
  """The app"""
  app: EvmAddress

  """The transaction hash you created the app with."""
  txHash: TxHash
}

input AppServerApiKeyRequest {
  """The app address."""
  app: EvmAddress!
}

type AppSigner {
  signer: EvmAddress!
  timestamp: DateTime!
}

input AppSignersRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The app address"""
  app: EvmAddress!
}

type AppUser {
  account: Account!
  lastActiveOn: DateTime!
  firstLoginOn: DateTime!
}

input AppUsersRequest {
  """The App to filter by."""
  app: EvmAddress!

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type ApprovalGroupRule {
  rule: EvmAddress!
}

enum AppsOrderBy {
  ALPHABETICAL
  LATEST_FIRST
  OLDEST_FIRST
}

input AppsRequest {
  pageSize: PageSize! = FIFTY
  cursor: Cursor
  orderBy: AppsOrderBy! = LATEST_FIRST
}

type ArticleMetadata {
  """Any attachment you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  content: Encryptable!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional article title."""
  title: String
}

union Asset = Erc20

type AssignUsernameResponse {
  hash: TxHash!
}

input AssignUsernameToAccountRequest {
  username: UsernameInput!
}

union AssignUsernameToAccountResult = AssignUsernameResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type AudioMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  audio: MediaAudio!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional audio title."""
  title: String
  content: Encryptable!
}

type AuthenticatedSession {
  authenticationId: UUID!
  app: EvmAddress!
  browser: String
  device: String
  os: String
  origin: URL
  signer: EvmAddress!
  createdAt: DateTime!
  updatedAt: DateTime!
  expiresAt: DateTime!
}

input AuthenticatedSessionsRequest {
  """
  You can optionally filter the authentications by the app that created them.
  """
  app: EvmAddress
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type AuthenticationChallenge {
  id: UUID!
  text: String!
}

union AuthenticationResult = AuthenticationTokens | WrongSignerError | ExpiredChallengeError | ForbiddenError

type AuthenticationTokens {
  """
  The Access Token to use as a Bearer token in authenticated Lens API requests.
  """
  accessToken: AccessToken!

  """
  The Refresh Token to use to obtain a new tokens triplet without re-authenticating.
  """
  refreshToken: RefreshToken!
  idToken: IdToken!
}

scalar BigDecimal

scalar BigInt

type BlockError {
  error: BlockErrorType!
}

enum BlockErrorType {
  UNKNOWN
  ALREADY_BLOCKED
  UNAUTHORIZED
}

input BlockRequest {
  """The account to block."""
  account: EvmAddress!
}

type BlockResponse {
  hash: TxHash!
}

union BlockResult = BlockResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | BlockError

scalar BlockchainData

input BookmarkPostRequest {
  post: PostId!
}

type BooleanAndCondition {
  criteria: [AccessConditionType!]!
  type: String!
}

type BooleanOrCondition {
  criteria: [AccessConditionType!]!
  type: String!
}

type BooleanValue {
  optimistic: Boolean!
  onChain: Boolean!
}

input BuilderChallengeRequest {
  """The builder's address. Most typically the EOA of their wallet."""
  address: EvmAddress!
}

input CanFollowRequest {
  graph: EvmAddress!
}

input CanUnfollowRequest {
  graph: EvmAddress!
}

scalar ChainId

"""
The request to generate a new authentication challenge.

The optional fields are used to specify the role you are authenticating as.
You can only specify one role at a time.
"""
input ChallengeRequest {
  """Use this to authenticate as a Builder."""
  builder: BuilderChallengeRequest

  """Use this to authenticate as an Account Manager."""
  accountManager: AccountManagerChallengeRequest

  """Use this to authenticate as an Account Owner."""
  accountOwner: AccountOwnerChallengeRequest

  """Use this to authenticate as an Onboarding User."""
  onboardingUser: OnboardingUserChallengeRequest
}

type CharsetUsernameNamespaceRule {
  rule: EvmAddress!
  allowNumeric: Boolean!
  allowLatinLowercase: Boolean!
  allowLatinUppercase: Boolean!
  customAllowedCharset: [String!]
  customDisallowedCharset: [String!]
  cannotStartWith: String
}

type CheckingInMetadata {
  """The optional address of the location."""
  address: PhysicalAddress

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """Where you're checking in from (free form text)."""
  location: Encryptable!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """The optional geographic position of the location."""
  position: Encryptable

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

input CollectActionInput {
  simpleCollectAction: SimpleCollectActionInput
}

"""CollectCondition"""
type CollectCondition {
  publicationId: LegacyPublicationId!
  thisPublication: Boolean!
  type: String!
}

type CommentNotification {
  id: GeneratedNotificationId!
  comment: Post!
}

enum ContentWarning {
  NSFW
  SENSITIVE
  SPOILER
}

type CreateAccountResponse {
  hash: TxHash!
}

input CreateAccountWithUsernameRequest {
  """The account metadata uri"""
  metadataUri: URI!

  """The username you wish to mint with the account"""
  username: UsernameInput!

  """Any account managers you wish to add to the account"""
  accountManager: [EvmAddress!]
}

union CreateAccountWithUsernameResult = CreateAccountResponse | InvalidUsername | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input CreateAppRequest {
  """The app metadata uri"""
  metadataUri: URI

  """Any admins who need to manage this app also"""
  admins: [EvmAddress!]

  """The app graph defaults to use the global graph"""
  graph: EvmAddress! = "0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"

  """The app feeds defaults to use the global feed"""
  feeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]

  """The default feed defaults to use the global feed"""
  defaultFeed: EvmAddress! = "0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"

  """The app username leave empty to use the lens username"""
  namespace: EvmAddress! = "0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"

  """The app groups leave empty if none"""
  groups: [EvmAddress!]

  """
  If the app has verification enabled meaning
  you can only do stuff with the app if its signed by one of the signers
  """
  verification: Boolean!

  """The app signers leave empty if none"""
  signers: [EvmAddress!]

  """The app paymaster leave empty if none"""
  paymaster: EvmAddress

  """The app treasury leave empty if none"""
  treasury: EvmAddress
}

type CreateAppResponse {
  hash: TxHash!
}

union CreateAppResult = CreateAppResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateFeedRequest {
  """The feed metadata uri"""
  metadataUri: URI

  """Any admins who need to manage this feed"""
  admins: [EvmAddress!]
}

type CreateFeedResponse {
  hash: TxHash!
}

union CreateFeedResult = CreateFeedResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateFollowRequest {
  """The account to follow."""
  account: EvmAddress!

  """
  The graph to follow the account on. If not provided, the global graph is used.
  """
  graph: EvmAddress! = "0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"

  """
  The data required by any follow rules associated with the account being followed.
  """
  followRule: FollowRulesInput

  """
  The data required by the graph rules associated with the specified graph.
  """
  graphRule: GraphRulesInput
}

input CreateGraphRequest {
  """The graph metadata uri"""
  metadataUri: URI

  """Any admins who need to manage this graph"""
  admins: [EvmAddress!]
}

type CreateGraphResponse {
  hash: TxHash!
}

union CreateGraphResult = CreateGraphResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateGroupRequest {
  """The group metadata uri"""
  metadataUri: URI

  """Any admins who need to manage this group"""
  admins: [EvmAddress!]
}

type CreateGroupResponse {
  hash: TxHash!
}

union CreateGroupResult = CreateGroupResponse | SelfFundedTransactionRequest | TransactionWillFail

type CreateNamespaceResponse {
  hash: TxHash!
}

input CreatePostRequest {
  """The feed to post to. If not provided, the global feed is used."""
  feed: EvmAddress! = "0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"

  """The URI of the post metadata."""
  contentUri: URI!

  """The post to quote, if any."""
  quoteOf: ReferencingPostInput

  """The post to comment on, if any."""
  commentOn: ReferencingPostInput

  """The actions to attach to the post."""
  actions: [PostActionInput!]
}

input CreateRepostRequest {
  """The feed to repost to. If not provided, the global feed is used."""
  feed: EvmAddress! = "0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"

  """The post to reference."""
  post: PostId!
}

input CreateUnfollowRequest {
  """The account to unfollow."""
  account: EvmAddress!

  """
  The graph where the account is followed and should be unfollowed.
  If not provided, the global graph is used.
  """
  graph: EvmAddress! = "0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"

  """
  The data required by the graph rules associated with the specified graph.
  """
  graphRule: GraphRulesInput
}

input CreateUsernameNamespaceRequest {
  """The feed metadata uri"""
  metadataUri: URI

  """Any admins who need to manage this feed"""
  admins: [EvmAddress!]

  """
  The namespace for example for lens this would be lens, and it means that the usernames will
  be like lens/username
  """
  namespace: String!

  """
  The symbol for the namespace as usernames minted under the namespace are NFTs
  """
  symbol: String!
}

union CreateUsernameNamespaceResult = CreateNamespaceResponse | SelfFundedTransactionRequest | TransactionWillFail

input CreateUsernameRequest {
  username: UsernameInput!

  """If you want to auto assign the username to the account default is true"""
  autoAssign: Boolean! = true
}

type CreateUsernameResponse {
  hash: TxHash!
}

union CreateUsernameResult = CreateUsernameResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar Cursor

scalar DateTime

input DebugPostMetadataRequest {
  rawUri: URI
  json: String
  source: EntityType!
}

type DebugPostMetadataResult {
  valid: Boolean!
  reason: String
}

input DebugTransactionStatusRequest {
  txHash: TxHash!
}

type DebugTransactionStatusResult {
  blockExplorer: URI
  reason: String!
}

input DeletePostRequest {
  """The post to delete."""
  post: PostId!

  """If needed, the feed rule data required to accomplish the deletion."""
  feedRules: FeedRulesInput
}

type DeletePostResponse {
  hash: TxHash!
}

union DeletePostResult = DeletePostResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input EditPostRequest {
  post: PostId!
  contentUri: URI!
}

type Eip1559TransactionRequest {
  """The transaction type: 2 for EIP-1559 transactions."""
  type: Int!

  """The target of the transaction."""
  to: EvmAddress!

  """The sender of the transaction."""
  from: EvmAddress!

  """The nonce of the transaction, used to prevent replay attacks."""
  nonce: Int!

  """The maximum amount of gas to allow this transaction to consume."""
  gasLimit: Int!

  """The maximum priority fee to pay per gas."""
  maxPriorityFeePerGas: BigInt!

  """
  The maximum total fee to pay per gas. The actual
  value used is protocol enforced to be the block's base fee.
  """
  maxFeePerGas: BigInt!

  """The transaction data."""
  data: BlockchainData!

  """The transaction value (in wei)."""
  value: BigInt!

  """The chain ID for the network this transaction is valid on."""
  chainId: Int!
}

"""Contains EIP-712 transaction metadata."""
type Eip712Meta {
  """
  The maximum amount of gas the user is willing to pay for a single byte of pubdata.
  """
  gasPerPubdata: BigInt!

  """
  An array of bytes containing the bytecode of the contract being deployed and any related
  contracts it can deploy.
  """
  factoryDeps: [BlockchainData!]!

  """
  Custom signature used for cases where the signer's account is not an EOA.
  """
  customSignature: BlockchainData

  """Parameters for configuring the custom paymaster for the transaction."""
  paymasterParams: PaymasterParams
}

type Eip712TransactionRequest {
  """The transaction type: 113 for EIP-712 transactions."""
  type: Int!

  """The target of the transaction."""
  to: EvmAddress!

  """The sender of the transaction."""
  from: EvmAddress!

  """The nonce of the transaction, used to prevent replay attacks."""
  nonce: Int!

  """The maximum amount of gas to allow this transaction to consume."""
  gasLimit: Int!

  """The maximum priority fee to pay per gas."""
  maxPriorityFeePerGas: BigInt!

  """
  The maximum total fee to pay per gas. The actual
  value used is protocol enforced to be the block's base fee.
  """
  maxFeePerGas: BigInt!

  """The transaction data."""
  data: BlockchainData!

  """The transaction value (in wei)."""
  value: BigInt!

  """The chain ID for the network this transaction is valid on."""
  chainId: Int!

  """The custom data for EIP-712 transaction metadata."""
  customData: Eip712Meta!
}

type EmbedMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning

  """The embed URL."""
  embed: Encryptable!
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

union EnableSignlessResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar Encryptable

union EncryptionStrategy = LitProtocolEncryptionStrategy

enum EntityType {
  ACCOUNT
  GRAPH
  FEED
  USERNAME_NAMESPACE
  GROUP
  POST
  APP
  SPONSORSHIP
}

"""EoaOwnershipCondition"""
type EoaOwnershipCondition {
  address: EvmAddress!
  type: String!
}

type Erc20 {
  name: String!
  symbol: String!
  decimals: Int!
  contract: NetworkAddress!
}

"""Erc20OwnershipCondition"""
type Erc20OwnershipCondition {
  amount: Amount!
  condition: AccessConditionComparison!
  type: String!
}

type EventMetadata {
  """The address of the event."""
  address: PhysicalAddress

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """The event end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  endsAt: Encryptable!
  id: MetadataId!

  """The links you want to include with it."""
  links: [Encryptable!]!
  locale: Locale!

  """The location of the event."""
  location: EventMetadataLensLocation!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """The geographic position of the event."""
  position: Encryptable
  schedulingAdjustments: EventMetadataLensSchedulingAdjustments

  """The event start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The title of the event."""
  title: String
  content: Encryptable!
}

type EventMetadataLensLocation {
  physical: Encryptable
  virtual: URI
}

type EventMetadataLensSchedulingAdjustments {
  """
  Indicates a reference timezone for the event start and end times. If physical event, you
  could use the timezone of the event location. If virtual event, the timezone of the event
  organizer.
  """
  timezoneId: EventMetadataLensSchedulingAdjustmentsTimezoneId!
  timezoneOffset: Float!
}

enum EventMetadataLensSchedulingAdjustmentsTimezoneId {
  AFRICA_ABIDJAN
  AFRICA_ACCRA
  AFRICA_ADDIS_ABABA
  AFRICA_ALGIERS
  AFRICA_ASMERA
  AFRICA_BAMAKO
  AFRICA_BANGUI
  AFRICA_BANJUL
  AFRICA_BISSAU
  AFRICA_BLANTYRE
  AFRICA_BRAZZAVILLE
  AFRICA_BUJUMBURA
  AFRICA_CAIRO
  AFRICA_CASABLANCA
  AFRICA_CEUTA
  AFRICA_CONAKRY
  AFRICA_DAKAR
  AFRICA_DAR_ES_SALAAM
  AFRICA_DJIBOUTI
  AFRICA_DOUALA
  AFRICA_EL_AAIUN
  AFRICA_FREETOWN
  AFRICA_GABORONE
  AFRICA_HARARE
  AFRICA_JOHANNESBURG
  AFRICA_JUBA
  AFRICA_KAMPALA
  AFRICA_KHARTOUM
  AFRICA_KIGALI
  AFRICA_KINSHASA
  AFRICA_LAGOS
  AFRICA_LIBREVILLE
  AFRICA_LOME
  AFRICA_LUANDA
  AFRICA_LUBUMBASHI
  AFRICA_LUSAKA
  AFRICA_MALABO
  AFRICA_MAPUTO
  AFRICA_MASERU
  AFRICA_MBABANE
  AFRICA_MOGADISHU
  AFRICA_MONROVIA
  AFRICA_NAIROBI
  AFRICA_NDJAMENA
  AFRICA_NIAMEY
  AFRICA_NOUAKCHOTT
  AFRICA_OUAGADOUGOU
  AFRICA_PORTO_NOVO
  AFRICA_SAO_TOME
  AFRICA_TRIPOLI
  AFRICA_TUNIS
  AFRICA_WINDHOEK
  AMERICA_ADAK
  AMERICA_ANCHORAGE
  AMERICA_ANGUILLA
  AMERICA_ANTIGUA
  AMERICA_ARAGUAINA
  AMERICA_ARGENTINA_LA_RIOJA
  AMERICA_ARGENTINA_RIO_GALLEGOS
  AMERICA_ARGENTINA_SALTA
  AMERICA_ARGENTINA_SAN_JUAN
  AMERICA_ARGENTINA_SAN_LUIS
  AMERICA_ARGENTINA_TUCUMAN
  AMERICA_ARGENTINA_USHUAIA
  AMERICA_ARUBA
  AMERICA_ASUNCION
  AMERICA_BAHIA
  AMERICA_BAHIA_BANDERAS
  AMERICA_BARBADOS
  AMERICA_BELEM
  AMERICA_BELIZE
  AMERICA_BLANC_SABLON
  AMERICA_BOA_VISTA
  AMERICA_BOGOTA
  AMERICA_BOISE
  AMERICA_BUENOS_AIRES
  AMERICA_CAMBRIDGE_BAY
  AMERICA_CAMPO_GRANDE
  AMERICA_CANCUN
  AMERICA_CARACAS
  AMERICA_CATAMARCA
  AMERICA_CAYENNE
  AMERICA_CAYMAN
  AMERICA_CHICAGO
  AMERICA_CHIHUAHUA
  AMERICA_CIUDAD_JUAREZ
  AMERICA_CORAL_HARBOUR
  AMERICA_CORDOBA
  AMERICA_COSTA_RICA
  AMERICA_CRESTON
  AMERICA_CUIABA
  AMERICA_CURACAO
  AMERICA_DANMARKSHAVN
  AMERICA_DAWSON
  AMERICA_DAWSON_CREEK
  AMERICA_DENVER
  AMERICA_DETROIT
  AMERICA_DOMINICA
  AMERICA_EDMONTON
  AMERICA_EIRUNEPE
  AMERICA_EL_SALVADOR
  AMERICA_FORT_NELSON
  AMERICA_FORTALEZA
  AMERICA_GLACE_BAY
  AMERICA_GODTHAB
  AMERICA_GOOSE_BAY
  AMERICA_GRAND_TURK
  AMERICA_GRENADA
  AMERICA_GUADELOUPE
  AMERICA_GUATEMALA
  AMERICA_GUAYAQUIL
  AMERICA_GUYANA
  AMERICA_HALIFAX
  AMERICA_HAVANA
  AMERICA_HERMOSILLO
  AMERICA_INDIANA_KNOX
  AMERICA_INDIANA_MARENGO
  AMERICA_INDIANA_PETERSBURG
  AMERICA_INDIANA_TELL_CITY
  AMERICA_INDIANA_VEVAY
  AMERICA_INDIANA_VINCENNES
  AMERICA_INDIANA_WINAMAC
  AMERICA_INDIANAPOLIS
  AMERICA_INUVIK
  AMERICA_IQALUIT
  AMERICA_JAMAICA
  AMERICA_JUJUY
  AMERICA_JUNEAU
  AMERICA_KENTUCKY_MONTICELLO
  AMERICA_KRALENDIJK
  AMERICA_LA_PAZ
  AMERICA_LIMA
  AMERICA_LOS_ANGELES
  AMERICA_LOUISVILLE
  AMERICA_LOWER_PRINCES
  AMERICA_MACEIO
  AMERICA_MANAGUA
  AMERICA_MANAUS
  AMERICA_MARIGOT
  AMERICA_MARTINIQUE
  AMERICA_MATAMOROS
  AMERICA_MAZATLAN
  AMERICA_MENDOZA
  AMERICA_MENOMINEE
  AMERICA_MERIDA
  AMERICA_METLAKATLA
  AMERICA_MEXICO_CITY
  AMERICA_MIQUELON
  AMERICA_MONCTON
  AMERICA_MONTERREY
  AMERICA_MONTEVIDEO
  AMERICA_MONTSERRAT
  AMERICA_NASSAU
  AMERICA_NEW_YORK
  AMERICA_NIPIGON
  AMERICA_NOME
  AMERICA_NORONHA
  AMERICA_NORTH_DAKOTA_BEULAH
  AMERICA_NORTH_DAKOTA_CENTER
  AMERICA_NORTH_DAKOTA_NEW_SALEM
  AMERICA_OJINAGA
  AMERICA_PANAMA
  AMERICA_PANGNIRTUNG
  AMERICA_PARAMARIBO
  AMERICA_PHOENIX
  AMERICA_PORT_AU_PRINCE
  AMERICA_PORT_OF_SPAIN
  AMERICA_PORTO_VELHO
  AMERICA_PUERTO_RICO
  AMERICA_PUNTA_ARENAS
  AMERICA_RAINY_RIVER
  AMERICA_RANKIN_INLET
  AMERICA_RECIFE
  AMERICA_REGINA
  AMERICA_RESOLUTE
  AMERICA_RIO_BRANCO
  AMERICA_SANTA_ISABEL
  AMERICA_SANTAREM
  AMERICA_SANTIAGO
  AMERICA_SANTO_DOMINGO
  AMERICA_SAO_PAULO
  AMERICA_SCORESBYSUND
  AMERICA_SITKA
  AMERICA_ST_BARTHELEMY
  AMERICA_ST_JOHNS
  AMERICA_ST_KITTS
  AMERICA_ST_LUCIA
  AMERICA_ST_THOMAS
  AMERICA_ST_VINCENT
  AMERICA_SWIFT_CURRENT
  AMERICA_TEGUCIGALPA
  AMERICA_THULE
  AMERICA_THUNDER_BAY
  AMERICA_TIJUANA
  AMERICA_TORONTO
  AMERICA_TORTOLA
  AMERICA_VANCOUVER
  AMERICA_WHITEHORSE
  AMERICA_WINNIPEG
  AMERICA_YAKUTAT
  AMERICA_YELLOWKNIFE
  ANTARCTICA_CASEY
  ANTARCTICA_DAVIS
  ANTARCTICA_DUMONT_D_URVILLE
  ANTARCTICA_MACQUARIE
  ANTARCTICA_MAWSON
  ANTARCTICA_MC_MURDO
  ANTARCTICA_PALMER
  ANTARCTICA_ROTHERA
  ANTARCTICA_SYOWA
  ANTARCTICA_TROLL
  ANTARCTICA_VOSTOK
  ARCTIC_LONGYEARBYEN
  ASIA_ADEN
  ASIA_ALMATY
  ASIA_AMMAN
  ASIA_ANADYR
  ASIA_AQTAU
  ASIA_AQTOBE
  ASIA_ASHGABAT
  ASIA_ATYRAU
  ASIA_BAGHDAD
  ASIA_BAHRAIN
  ASIA_BAKU
  ASIA_BANGKOK
  ASIA_BARNAUL
  ASIA_BEIRUT
  ASIA_BISHKEK
  ASIA_BRUNEI
  ASIA_CALCUTTA
  ASIA_CHITA
  ASIA_CHOIBALSAN
  ASIA_COLOMBO
  ASIA_DAMASCUS
  ASIA_DHAKA
  ASIA_DILI
  ASIA_DUBAI
  ASIA_DUSHANBE
  ASIA_FAMAGUSTA
  ASIA_GAZA
  ASIA_HEBRON
  ASIA_HONG_KONG
  ASIA_HOVD
  ASIA_IRKUTSK
  ASIA_JAKARTA
  ASIA_JAYAPURA
  ASIA_JERUSALEM
  ASIA_KABUL
  ASIA_KAMCHATKA
  ASIA_KARACHI
  ASIA_KATMANDU
  ASIA_KHANDYGA
  ASIA_KRASNOYARSK
  ASIA_KUALA_LUMPUR
  ASIA_KUCHING
  ASIA_KUWAIT
  ASIA_MACAU
  ASIA_MAGADAN
  ASIA_MAKASSAR
  ASIA_MANILA
  ASIA_MUSCAT
  ASIA_NICOSIA
  ASIA_NOVOKUZNETSK
  ASIA_NOVOSIBIRSK
  ASIA_OMSK
  ASIA_ORAL
  ASIA_PHNOM_PENH
  ASIA_PONTIANAK
  ASIA_PYONGYANG
  ASIA_QATAR
  ASIA_QOSTANAY
  ASIA_QYZYLORDA
  ASIA_RANGOON
  ASIA_RIYADH
  ASIA_SAIGON
  ASIA_SAKHALIN
  ASIA_SAMARKAND
  ASIA_SEOUL
  ASIA_SHANGHAI
  ASIA_SINGAPORE
  ASIA_SREDNEKOLYMSK
  ASIA_TAIPEI
  ASIA_TASHKENT
  ASIA_TBILISI
  ASIA_TEHRAN
  ASIA_THIMPHU
  ASIA_TOKYO
  ASIA_TOMSK
  ASIA_ULAANBAATAR
  ASIA_URUMQI
  ASIA_UST_NERA
  ASIA_VIENTIANE
  ASIA_VLADIVOSTOK
  ASIA_YAKUTSK
  ASIA_YEKATERINBURG
  ASIA_YEREVAN
  ATLANTIC_AZORES
  ATLANTIC_BERMUDA
  ATLANTIC_CANARY
  ATLANTIC_CAPE_VERDE
  ATLANTIC_FAEROE
  ATLANTIC_MADEIRA
  ATLANTIC_REYKJAVIK
  ATLANTIC_SOUTH_GEORGIA
  ATLANTIC_ST_HELENA
  ATLANTIC_STANLEY
  AUSTRALIA_ADELAIDE
  AUSTRALIA_BRISBANE
  AUSTRALIA_BROKEN_HILL
  AUSTRALIA_CURRIE
  AUSTRALIA_DARWIN
  AUSTRALIA_EUCLA
  AUSTRALIA_HOBART
  AUSTRALIA_LINDEMAN
  AUSTRALIA_LORD_HOWE
  AUSTRALIA_MELBOURNE
  AUSTRALIA_PERTH
  AUSTRALIA_SYDNEY
  EUROPE_AMSTERDAM
  EUROPE_ANDORRA
  EUROPE_ASTRAKHAN
  EUROPE_ATHENS
  EUROPE_BELGRADE
  EUROPE_BERLIN
  EUROPE_BRATISLAVA
  EUROPE_BRUSSELS
  EUROPE_BUCHAREST
  EUROPE_BUDAPEST
  EUROPE_BUSINGEN
  EUROPE_CHISINAU
  EUROPE_COPENHAGEN
  EUROPE_DUBLIN
  EUROPE_GIBRALTAR
  EUROPE_GUERNSEY
  EUROPE_HELSINKI
  EUROPE_ISLE_OF_MAN
  EUROPE_ISTANBUL
  EUROPE_JERSEY
  EUROPE_KALININGRAD
  EUROPE_KIEV
  EUROPE_KIROV
  EUROPE_LISBON
  EUROPE_LJUBLJANA
  EUROPE_LONDON
  EUROPE_LUXEMBOURG
  EUROPE_MADRID
  EUROPE_MALTA
  EUROPE_MARIEHAMN
  EUROPE_MINSK
  EUROPE_MONACO
  EUROPE_MOSCOW
  EUROPE_OSLO
  EUROPE_PARIS
  EUROPE_PODGORICA
  EUROPE_PRAGUE
  EUROPE_RIGA
  EUROPE_ROME
  EUROPE_SAMARA
  EUROPE_SAN_MARINO
  EUROPE_SARAJEVO
  EUROPE_SARATOV
  EUROPE_SIMFEROPOL
  EUROPE_SKOPJE
  EUROPE_SOFIA
  EUROPE_STOCKHOLM
  EUROPE_TALLINN
  EUROPE_TIRANE
  EUROPE_ULYANOVSK
  EUROPE_UZHGOROD
  EUROPE_VADUZ
  EUROPE_VATICAN
  EUROPE_VIENNA
  EUROPE_VILNIUS
  EUROPE_VOLGOGRAD
  EUROPE_WARSAW
  EUROPE_ZAGREB
  EUROPE_ZAPOROZHYE
  EUROPE_ZURICH
  INDIAN_ANTANANARIVO
  INDIAN_CHAGOS
  INDIAN_CHRISTMAS
  INDIAN_COCOS
  INDIAN_COMORO
  INDIAN_KERGUELEN
  INDIAN_MAHE
  INDIAN_MALDIVES
  INDIAN_MAURITIUS
  INDIAN_MAYOTTE
  INDIAN_REUNION
  PACIFIC_APIA
  PACIFIC_AUCKLAND
  PACIFIC_BOUGAINVILLE
  PACIFIC_CHATHAM
  PACIFIC_EASTER
  PACIFIC_EFATE
  PACIFIC_ENDERBURY
  PACIFIC_FAKAOFO
  PACIFIC_FIJI
  PACIFIC_FUNAFUTI
  PACIFIC_GALAPAGOS
  PACIFIC_GAMBIER
  PACIFIC_GUADALCANAL
  PACIFIC_GUAM
  PACIFIC_HONOLULU
  PACIFIC_JOHNSTON
  PACIFIC_KIRITIMATI
  PACIFIC_KOSRAE
  PACIFIC_KWAJALEIN
  PACIFIC_MAJURO
  PACIFIC_MARQUESAS
  PACIFIC_MIDWAY
  PACIFIC_NAURU
  PACIFIC_NIUE
  PACIFIC_NORFOLK
  PACIFIC_NOUMEA
  PACIFIC_PAGO_PAGO
  PACIFIC_PALAU
  PACIFIC_PITCAIRN
  PACIFIC_PONAPE
  PACIFIC_PORT_MORESBY
  PACIFIC_RAROTONGA
  PACIFIC_SAIPAN
  PACIFIC_TAHITI
  PACIFIC_TARAWA
  PACIFIC_TONGATAPU
  PACIFIC_TRUK
  PACIFIC_WAKE
  PACIFIC_WALLIS
}

scalar EvmAddress

"""The challenge has expired or was not found."""
type ExpiredChallengeError {
  reason: String!
}

"""
The transaction has failed to be mined or indexed.

The reason for the failure is provided.
"""
type FailedTransactionStatus {
  reason: String!
  blockTimestamp: DateTime!
}

input FeeFollowRuleInput {
  amount: AmountInput!
}

type Feed {
  address: EvmAddress!
  createdAt: DateTime!
  metadata: FeedMetadata
  owner: EvmAddress!
  rules(request: RuleInput): FeedRulesConfig!
}

type FeedMetadata {
  """Optional markdown formatted description of the Feed."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """The name of the Feed."""
  name: String!

  """The human-friendly title for the Feed."""
  title: String!
}

input FeedRequest {
  """The feed"""
  feed: EvmAddress

  """The transaction hash you created the feed with."""
  txHash: TxHash
}

union FeedRule = TokenGatedFeedRule | GroupGatedFeedRule | RestrictedSignersFeedRule | SimplePaymentFeedRule | UserBlockingRule | UnknownFeedRule

type FeedRulesConfig {
  required: [FeedRule!]!
  anyOf: [FeedRule!]!
}

input FeedRulesInput {
  unknownFeedRule: UnknownFeedRuleInput
}

"""
The transaction has been mined and indexed correctly.

If the transaction involves any metadata, the metadata has been snapshotted and indexed.
"""
type FinishedTransactionStatus {
  blockTimestamp: DateTime!
}

"""FollowCondition"""
type FollowCondition {
  follow: LegacyProfileId!
  type: String!
}

type FollowNotification {
  id: GeneratedNotificationId!
  followers: [NotificationAccountFollow!]!
}

input FollowPair {
  """The graph you are checking defaults to global graph."""
  graph: EvmAddress! = "0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"

  """The follower."""
  follower: EvmAddress!

  """The account being followed."""
  account: EvmAddress!
}

type FollowResponse {
  hash: TxHash!
}

union FollowResult = FollowResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

union FollowRule = TokenGatedFollowRule | SimplePaymentFollowRule | UnknownFollowRule

type FollowRulesConfig {
  required: [FollowRule!]!
  anyOf: [FollowRule!]!
}

input FollowRulesInput {
  feeFollowRule: FeeFollowRuleInput
  unknownFollowRule: UnknownFollowRuleInput
}

input FollowStatusRequest {
  pairs: [FollowPair!]!
}

type FollowStatusResult {
  graph: EvmAddress!
  follower: EvmAddress!
  account: EvmAddress!
  isFollowing: BooleanValue!
}

type Follower {
  """The account which is following"""
  follower: Account!

  """The timestamp when the follower was followed"""
  followedOn: DateTime!
}

type FollowerOnlyPostRule {
  rule: EvmAddress!
  graph: EvmAddress!
  repliesRestricted: Boolean!
  repostsRestricted: Boolean!
  quotesRestricted: Boolean!
}

enum FollowersOrderBy {
  DESC
  ASC
  ACCOUNT_SCORE
}

input FollowersRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account to get followers for."""
  account: EvmAddress!

  """
  The graphs to get followers for
  The result will come back if they follow on ANY of the supplied graphs
  """
  forGraphs: [EvmAddress!]! = ["0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"]

  """The order by."""
  orderBy: FollowersOrderBy! = DESC
}

enum FollowersYouKnowOrderBy {
  DESC
  ASC
}

input FollowersYouKnowRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account to check followers you know."""
  target: EvmAddress!

  """The account you are looking from."""
  observer: EvmAddress!

  """
  The graphs to get followers you know for
  The result will come back if they follow on ANY of the supplied graphs
  """
  forGraphs: [EvmAddress!]! = ["0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"]

  """The order by."""
  orderBy: FollowersYouKnowOrderBy! = DESC
}

type Following {
  """The account which is following"""
  following: Account!

  """The timestamp when the following happened"""
  followedOn: DateTime!
}

enum FollowingOrderBy {
  DESC
  ASC
  ACCOUNT_SCORE
}

input FollowingRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account to get following for."""
  account: EvmAddress!

  """
  The graphs to get following for.
  The result will come back if they are following on ANY of the supplied graphs
  """
  forGraphs: [EvmAddress!]! = ["0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"]

  """The order by."""
  orderBy: FollowingOrderBy! = DESC
}

type ForbiddenError {
  reason: String!
}

scalar GeneratedNotificationId

type Graph {
  address: EvmAddress!
  createdAt: DateTime!
  metadata: GraphMetadata
  owner: EvmAddress!
  rules(request: RuleInput): GraphRulesConfig!
}

type GraphMetadata {
  """Optional markdown formatted description of the graph."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """The name of the graph."""
  name: String!

  """The human-friendly title for the graph."""
  title: String!
}

input GraphRequest {
  """The graph"""
  graph: EvmAddress

  """The transaction hash you created the graph with."""
  txHash: TxHash
}

union GraphRule = TokenGatedGraphRule | RestrictedSignerGraphRule | UserBlockingRule | UnknownGraphRule

type GraphRulesConfig {
  required: [GraphRule!]!
  anyOf: [GraphRule!]!
}

input GraphRulesInput {
  unknownGraphRule: UnknownGraphRuleInput
}

type Group {
  address: EvmAddress!
  timestamp: DateTime!
  metadata: GroupMetadata

  """
  Check if the authenticated account is a member of the group.
  Will return null if the account is not logged in.
  """
  isMember: Boolean
  owner: EvmAddress!
  rules(request: RuleInput): GroupRulesConfig!
}

type GroupGatedFeedRule {
  rule: EvmAddress!
  group: Group!
}

enum GroupMembersOrderBy {
  LAST_JOINED
  FIRST_JOINED
  ACCOUNT_SCORE
}

input GroupMembersRequest {
  """The group"""
  group: EvmAddress!

  """The order by."""
  orderBy: GroupMembersOrderBy! = LAST_JOINED

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type GroupMetadata {
  """Optional markdown formatted description of the Community."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!

  """Optional uri of the Community's icon."""
  icon: URI

  """The name of the Community."""
  name: String!

  """The slug for the Community."""
  slug: String!

  """The Group cover picture."""
  coverPicture: URI
}

input GroupRequest {
  """The group"""
  group: EvmAddress

  """The transaction hash you created the group with."""
  txHash: TxHash
}

union GroupRule = TokenGatedGroupRule | SimplePaymentGroupRule | ApprovalGroupRule | UnknownGroupRule

type GroupRulesConfig {
  required: [GroupRule!]!
  anyOf: [GroupRule!]!
}

input GroupStatsRequest {
  """The group address to check its total members."""
  group: EvmAddress!
}

type GroupStatsResponse {
  totalMembers: Int!
}

input GroupsFilter {
  """The name of the group"""
  name: String
}

enum GroupsOrderBy {
  LATEST_JOINED
  NAME
}

input GroupsRequest {
  """Get the groups this account is a member of"""
  member: EvmAddress!

  """The filter"""
  filter: GroupsFilter

  """The order by."""
  orderBy: GroupsOrderBy! = LATEST_JOINED

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input HasReactedRequest {
  type: PostReactionType
}

input HideManagedAccountRequest {
  """The account to hide."""
  account: EvmAddress!
}

input HideReplyRequest {
  post: PostId!
}

scalar IdToken

type ImageMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  image: MediaImage!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional image title."""
  title: String
  content: Encryptable!
}

type InvalidUsername {
  reason: String!
}

input IsFollowedByMeRequest {
  graph: EvmAddress!
}

input IsFollowingMeRequest {
  graph: EvmAddress!
}

input JoinGroupRequest {
  """The group you want to join"""
  group: EvmAddress!
}

type JoinGroupResponse {
  hash: TxHash!
}

union JoinGroupResult = JoinGroupResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type KnownAction {
  name: String!
  contract: NetworkAddress!
  setupInput: [ActionInputInfo!]!
  actionInput: [ActionInputInfo!]!
  returnSetupInput: [ActionInputInfo!]!
}

input LastLoggedInAccountRequest {
  """The address to get the last logged in account for."""
  address: EvmAddress!

  """The app to get the last logged in account for."""
  app: EvmAddress
}

input LeaveGroupRequest {
  """The group you want to leave"""
  group: EvmAddress!
}

type LeaveGroupResponse {
  hash: TxHash!
}

union LeaveGroupResult = LeaveGroupResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar LegacyProfileId

scalar LegacyPublicationId

scalar LegacyRefreshToken

type LengthUsernameNamespaceRule {
  rule: EvmAddress!
  minLength: Int!
  maxLength: Int!
}

type LinkMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """The sharing link url."""
  sharingLink: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

type LitProtocolEncryptionStrategy {
  accessCondition: TopLevelAccessCondition!
  encryptedPaths: [String!]!
  encryptionKey: String!
}

type LivestreamMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """
  The data cannot be changed so you can put in an API endpoint to know if it is still live or
  not for clients to be able to check.
  """
  checkLiveApi: Encryptable

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy

  """The optional stream end time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)"""
  endsAt: Encryptable
  id: MetadataId!

  """
  Some livestream platforms have the live url as a separate url. If not your case make sure
  `liveUrl` and `playbackUrl` are the same.
  """
  liveUrl: Encryptable!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """
  Some livestream platforms have the playback url as a separate url. If not your case make
  sure `liveUrl` and `playbackUrl` are the same.
  """
  playbackUrl: Encryptable!

  """The stream start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The livestream title."""
  title: String
  content: Encryptable!
}

scalar Locale

type LoggedInAccountOperations {
  id: ID!

  """
  Check if the target account is followed by the authenticated account.
  
  If a graph is not specified:
  - It first checks for a Graph address specified within the query scope.
  - If no Graph address is found, it defaults to using the Global Graph.
  """
  isFollowedByMe(request: IsFollowedByMeRequest): Boolean!

  """
  Check if the authenticated account is following the target account.
  
  If a graph is not specified:
  - It first checks for a Graph address specified within the query scope.
  - If no Graph address is found, it defaults to using the Global Graph.
  """
  isFollowingMe(request: IsFollowingMeRequest): Boolean!

  """
  Check if the authenticated account can follow the target account.
  
  If a graph is not specified:
  - It first checks for a Graph address specified within the query scope.
  - If no Graph address is found, it defaults to using the Global Graph.
  """
  canFollow(request: CanFollowRequest): TriStateValue!

  """
  Check if the authenticated account can unfollow the target account.
  
  If a graph is not specified:
  - It first checks for a Graph address specified within the query scope.
  - If no Graph address is found, it defaults to using the Global Graph.
  """
  canUnfollow(request: CanUnfollowRequest): Boolean!
  isMutedByMe: Boolean!
  isBlockedByMe: Boolean!
  hasBlockedMe: Boolean!
  canBlock: Boolean!
  canUnblock: Boolean!
  hasReported: Boolean!
}

type LoggedInPostOperations {
  id: ID!
  isNotInterested: Boolean!
  hasBookmarked: Boolean!
  hasReported: Boolean!
  hasReacted(request: HasReactedRequest): Boolean!
  canComment: TriStateValue!
  canQuote: TriStateValue!
  canRepost: TriStateValue!
  hasCommented: BooleanValue!
  hasQuoted: BooleanValue!
  hasReposted: BooleanValue!
}

enum MainContentFocus {
  ARTICLE
  AUDIO
  CHECKING_IN
  EMBED
  EVENT
  IMAGE
  LINK
  LIVESTREAM
  MINT
  SHORT_VIDEO
  SPACE
  STORY
  TEXT_ONLY
  THREE_D
  TRANSACTION
  VIDEO
}

enum ManagedAccountsVisibility {
  NONE_HIDDEN
  HIDDEN_ONLY
  ALL
}

input ManagedAppsRequest {
  """The address for a user to see what apps they manage."""
  address: EvmAddress!

  """Whether to include the apps which is owned by the address."""
  includeOwners: Boolean! = true

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input ManagedFeedsRequest {
  """The address for a user to see what feeds they manage."""
  address: EvmAddress!

  """Whether to include the feeds which is owned by the address."""
  includeOwners: Boolean! = true

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input ManagedGraphsRequest {
  """The address for a user to see what graphs they manage."""
  address: EvmAddress!

  """Whether to include the graphs which is owned by the address."""
  includeOwners: Boolean! = true

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input ManagedGroupsRequest {
  """The address for a user to see what groups they manage."""
  address: EvmAddress!

  """Whether to include the groups which is owned by the address."""
  includeOwners: Boolean! = true

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input ManagedNamespacesRequest {
  """The address for a user to see what namespaces they manage."""
  address: EvmAddress!

  """Whether to include the namespaces which is owned by the address."""
  includeOwners: Boolean! = true

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

type MeResult {
  """The logged in account."""
  loggedInAs: AccountAvailable!

  """Whether the account is signless."""
  isSignless: Boolean!

  """Whether the account is sponsored."""
  isSponsored: Boolean!

  """The app the account is logged in to."""
  appLoggedIn: EvmAddress!

  """The sponsorship allowance for the account."""
  limit: SponsorshipAllowance!
}

"""
MediaAudio

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"artist": {
"description": "The name of the artist.",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"cover": {
"$ref": "#/$defs/EncryptableUri"
},
"credits": {
"description": "The credits for the audio.",
"$ref": "#/$defs/EncryptableString"
},
"duration": {
"description": "How long the the audio is in seconds.",
"type": "integer",
"exclusiveMinimum": 0.0
},
"genre": {
"description": "The genre of the audio",
"$ref": "#/$defs/EncryptableString"
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"kind": {
"description": "The type of audio.",
"type": "string",
"enum": [
"MUSIC",
"PODCAST",
"AUDIOBOOK",
"VOICE_NOTE",
"SOUND",
"OTHER"
]
},
"license": {
"description": "The license for the audio.",
"$ref": "#/$defs/MetadataLicenseType"
},
"lyrics": {
"$ref": "#/$defs/EncryptableUri"
},
"recordLabel": {
"description": "The record label for the audio.",
"$ref": "#/$defs/EncryptableString"
},
"type": {
"description": "The mime type of the audio file.",
"type": "string",
"enum": [
"audio/wav",
"audio/vnd.wave",
"audio/mpeg",
"audio/ogg",
"audio/mp4",
"audio/aac",
"audio/webm",
"audio/flac"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaAudio {
  """The name of the artist."""
  artist: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  cover: Encryptable

  """The credits for the audio."""
  credits: Encryptable

  """How long the the audio is in seconds."""
  duration: Int

  """The genre of the audio"""
  genre: Encryptable
  item: Encryptable!

  """The type of audio."""
  kind: MediaAudioKind

  """The license for the audio."""
  license: MetadataLicenseType
  lyrics: Encryptable

  """The record label for the audio."""
  recordLabel: Encryptable

  """The mime type of the audio file."""
  type: MediaAudioType!
}

"""
The type of audio.

<details><summary>JSON schema</summary>

```json
{
"description": "The type of audio.",
"type": "string",
"enum": [
"MUSIC",
"PODCAST",
"AUDIOBOOK",
"VOICE_NOTE",
"SOUND",
"OTHER"
]
}
```
</details>
"""
enum MediaAudioKind {
  MUSIC
  PODCAST
  AUDIOBOOK
  VOICE_NOTE
  SOUND
  OTHER
}

"""
The mime type of the audio file.

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the audio file.",
"type": "string",
"enum": [
"audio/wav",
"audio/vnd.wave",
"audio/mpeg",
"audio/ogg",
"audio/mp4",
"audio/aac",
"audio/webm",
"audio/flac"
]
}
```
</details>
"""
enum MediaAudioType {
  AUDIO_WAV
  AUDIO_VND_WAVE
  AUDIO_MPEG
  AUDIO_OGG
  AUDIO_MP_4
  AUDIO_AAC
  AUDIO_WEBM
  AUDIO_FLAC
}

"""
MediaImage

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"altTag": {
"description": "The alt tag for accessibility",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"license": {
"description": "The license for the image",
"$ref": "#/$defs/MetadataLicenseType"
},
"type": {
"description": "The mime type of the image",
"type": "string",
"enum": [
"image/bmp",
"image/gif",
"image/heic",
"image/jpeg",
"image/png",
"image/svg+xml",
"image/tiff",
"image/webp",
"image/x-ms-bmp"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaImage {
  """The alt tag for accessibility"""
  altTag: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  item: Encryptable!

  """The license for the image"""
  license: MetadataLicenseType

  """The mime type of the image"""
  type: MediaImageType!
}

"""
The mime type of the image

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the image",
"type": "string",
"enum": [
"image/bmp",
"image/gif",
"image/heic",
"image/jpeg",
"image/png",
"image/svg+xml",
"image/tiff",
"image/webp",
"image/x-ms-bmp"
]
}
```
</details>
"""
enum MediaImageType {
  BMP
  GIF
  HEIC
  JPEG
  PNG
  SVG_XML
  TIFF
  WEBP
  X_MS_BMP
}

"""
MediaVideo

<details><summary>JSON schema</summary>

```json
{
"type": "object",
"required": [
"item",
"type"
],
"properties": {
"altTag": {
"description": "The alt tag for accessibility",
"$ref": "#/$defs/EncryptableString"
},
"attributes": {
"description": "A bag of attributes that can be used to store any kind of metadata that is not currently supported by the standard.",
"type": "array",
"items": {
"$ref": "#/$defs/MetadataAttribute"
},
"minItems": 1
},
"cover": {
"$ref": "#/$defs/EncryptableUri"
},
"duration": {
"description": "How long the the video is in seconds",
"type": "integer",
"exclusiveMinimum": 0.0
},
"item": {
"$ref": "#/$defs/EncryptableUri"
},
"license": {
"description": "The license for the video",
"$ref": "#/$defs/MetadataLicenseType"
},
"type": {
"description": "The mime type of the video",
"type": "string",
"enum": [
"model/gltf+json",
"model/gltf-binary",
"video/x-m4v",
"video/mov",
"video/mp4",
"video/mpeg",
"video/ogg",
"video/ogv",
"video/quicktime",
"video/webm"
]
}
},
"additionalProperties": false
}
```
</details>
"""
type MediaVideo {
  """The alt tag for accessibility"""
  altTag: Encryptable

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard.
  """
  attributes: [MetadataAttribute!]!
  cover: Encryptable

  """How long the the video is in seconds"""
  duration: Int
  item: Encryptable!

  """The license for the video"""
  license: MetadataLicenseType

  """The mime type of the video"""
  type: MediaVideoType!
}

"""
The mime type of the video

<details><summary>JSON schema</summary>

```json
{
"description": "The mime type of the video",
"type": "string",
"enum": [
"model/gltf+json",
"model/gltf-binary",
"video/x-m4v",
"video/mov",
"video/mp4",
"video/mpeg",
"video/ogg",
"video/ogv",
"video/quicktime",
"video/webm"
]
}
```
</details>
"""
enum MediaVideoType {
  MODEL_GLTF_JSON
  MODEL_GLTF_BINARY
  VIDEO_XM_4V
  VIDEO_MOV
  VIDEO_MP_4
  VIDEO_MPEG
  VIDEO_OGG
  VIDEO_OGV
  VIDEO_QUICKTIME
  VIDEO_WEBM
}

type MentionNotification {
  id: GeneratedNotificationId!
  post: Post!
}

type MetadataAttribute {
  type: MetadataAttributeType!
  key: String!
  value: String!
}

enum MetadataAttributeType {
  BOOLEAN
  DATE
  NUMBER
  STRING
  JSON
}

scalar MetadataId

enum MetadataLicenseType {
  CCO
  CC_BY
  CC_BY_ND
  CC_BY_NC
  TBNL_CD_PL_LEGAL
  TBNL_C_DT_PL_LEGAL
  TBNL_C_ND_PL_LEGAL
  TBNL_CD_NPL_LEGAL
  TBNL_C_DT_NPL_LEGAL
  TBNL_C_DTSA_PL_LEGAL
  TBNL_C_DTSA_NPL_LEGAL
  TBNL_C_ND_NPL_LEGAL
  TBNL_CD_PL_LEDGER
  TBNL_C_DT_PL_LEDGER
  TBNL_C_ND_PL_LEDGER
  TBNL_CD_NPL_LEDGER
  TBNL_C_DT_NPL_LEDGER
  TBNL_C_DTSA_PL_LEDGER
  TBNL_C_DTSA_NPL_LEDGER
  TBNL_C_ND_NPL_LEDGER
  TBNL_NC_D_PL_LEGAL
  TBNL_NC_DT_PL_LEGAL
  TBNL_NC_ND_PL_LEGAL
  TBNL_NC_D_NPL_LEGAL
  TBNL_NC_DT_NPL_LEGAL
  TBNL_NC_DTSA_PL_LEGAL
  TBNL_NC_DTSA_NPL_LEGAL
  TBNL_NC_ND_NPL_LEGAL
  TBNL_NC_D_PL_LEDGER
  TBNL_NC_DT_PL_LEDGER
  TBNL_NC_ND_PL_LEDGER
  TBNL_NC_D_NPL_LEDGER
  TBNL_NC_DT_NPL_LEDGER
  TBNL_NC_DTSA_PL_LEDGER
  TBNL_NC_DTSA_NPL_LEDGER
  TBNL_NC_ND_NPL_LEDGER
}

type MintMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """
  The mint item it can be a URL of the known provider like opensea https://opensea.io/assets/ethereum/0xfaa2471e93bd1cee3b0ab381c242ada8e1d1a759/299 or https://zora.co/collect/0x9d90669665607f08005cae4a7098143f554c59ef/39626. The Lens API has an allow list of providers and if the domain does not match it will mark it as failed metadata
  """
  mintLink: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

type Mutation {
  """
  Create a new app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createApp(request: CreateAppRequest!): CreateAppResult!

  """
  Add an app authorization endpoint.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  addAppAuthorizationEndpoint(request: AddAppAuthorizationEndpointRequest!): Void!

  """
  Add feeds to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  addAppFeeds(request: AddAppFeedsRequest!): AddAppFeedsResult!

  """
  Add groups to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  addAppGroups(request: AddAppGroupsRequest!): AddAppGroupsResult!

  """
  Add signers to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  addAppSigners(request: AddAppSignersRequest!): AddAppSignersResult!

  """
  Remove feeds to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  removeAppFeeds(request: RemoveAppFeedsRequest!): RemoveAppFeedsResult!

  """
  Remove groups to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  removeAppGroups(request: RemoveAppGroupsRequest!): RemoveAppGroupsResult!

  """
  Remove signers to an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  removeAppSigners(request: RemoveAppSignersRequest!): RemoveAppSignersResult!

  """
  Set graph for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppGraph(request: SetAppGraphRequest!): SetAppGraphResult!

  """
  Set default feed for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setDefaultAppFeed(request: SetDefaultAppFeedRequest!): SetDefaultAppFeedResult!

  """
  Set metadata for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppMetadata(request: SetAppMetadataRequest!): SetAppMetadataResult!

  """
  Set if the app verification is enabled
  App needs to have authorization endpoint enabled
  App needs to return `verification_endpoint` from the authorization endpoint
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppVerification(request: SetAppVerificationRequest!): SetAppVerificationResult!

  """
  Set sponsorship for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppSponsorship(request: SetAppSponsorshipRequest!): SetAppSponsorshipResult!

  """
  Set treasury for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppTreasury(request: SetAppTreasuryRequest!): SetAppTreasuryResult!

  """
  Set username namespace for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  setAppUsernameNamespace(request: SetAppUsernameNamespaceRequest!): SetAppUsernameNamespaceResult!

  """
  Refresh the server side api key for an app
  
  You MUST be authenticated as a builder to use this mutation.
  """
  appRefreshServerApiKey(request: RefreshAppServerApiKeyRequest!): ServerAPIKey!

  """
  Report an account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  reportAccount(request: ReportAccountRequest!): Void!

  """
  Hides an account from the manager list of managed accounts.
  
  You MUST be authenticated as Account Manager to use this mutation.
  """
  hideManagedAccount(request: HideManagedAccountRequest!): Void!

  """
  Undo the hiding of an account from the manager list of managed accounts.
  
  You MUST be authenticated as Account Manager to use this mutation.
  """
  unhideManagedAccount(request: UnhideManagedAccountRequest!): Void!

  """
  Set the metadata for the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  setAccountMetadata(request: SetAccountMetadataRequest!): SetAccountMetadataResult!

  """
  Block an account with the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  block(request: BlockRequest!): BlockResult!

  """
  Unblock an account with the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  unblock(request: UnblockRequest!): UnblockResult!

  """
  Recommend an account from the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  recommendAccount(request: RecommendAccount!): Void!

  """
  Undo recommended account from the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  undoRecommendedAccount(request: UndoRecommendedAccount!): Void!

  """
  Mute an account for the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  mute(request: MuteRequest!): Void!

  """
  Unmute an account for the authenticated account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  unmute(request: MuteRequest!): Void!

  """
  Create an account with a given username.
  
  You MUST be authenticated as Onboarding User to use this mutation.
  """
  createAccountWithUsername(request: CreateAccountWithUsernameRequest!): CreateAccountWithUsernameResult!

  """
  Add an account manager to the authenticated account.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  addAccountManager(request: AddAccountManagerRequest!): AddAccountManagerResult!

  """
  Remove an account manager to the authenticated account.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  removeAccountManager(request: RemoveAccountManagerRequest!): RemoveAccountManagerResult!

  """
  Enables Signless experience for the authenticated account.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  enableSignless: EnableSignlessResult!

  """
  Remove Signless experience for the authenticated account.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  removeSignless: RemoveSignlessResult!

  """
  Update the Account Manager Permissions for a given Account Manager.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  updateAccountManager(request: UpdateAccountManagerRequest!): UpdateAccountManagerResult!

  """Authenticate the user with the signed authentication challenge."""
  authenticate(request: SignedAuthChallenge!): AuthenticationResult!

  """
  Generates a new authentication challenge for the specified address and app.
  
  Users must sign the challenge to authenticate.
  
  The issued challenge can be for authentication credentials for different roles:
  - AccountOwner: The `address` is a Lens Account, and the `signed_by` is the Account Owner.
  - AccountManager: The `address` is a Lens Account, and the `signed_by` is an Account Manager
  for it.
  - OnboardingUser: The `address` is an EOA that needs to create their Lens Account.
  - Builder: The `address` is the EOA of a Builder that needs to use configuration and
  management features.
  
  The HTTP Origin header MUST be present and match the app's domain.
  """
  challenge(request: ChallengeRequest!): AuthenticationChallenge!

  """
  Revoke an authentication.
  
  You MUST be authenticated to use this mutation.
  """
  revokeAuthentication(request: RevokeAuthenticationRequest!): Void!

  """
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  switchAccount(request: SwitchAccountRequest!): SwitchAccountResult!

  """Refreshes the authentication tokens."""
  refresh(request: RefreshRequest!): RefreshResult!

  """
  Issue new authentication tokens from a valid Lens API v2 refresh token.
  
  Use this to seamlessly transition your users from Lens API v2 to Lens API v3 without
  requiring them to re-authenticate.
  
  The HTTP Origin header MUST be present and match the app's domain.
  """
  legacyRolloverRefresh(request: RolloverRefreshRequest!): RefreshResult!

  """
  Create a new post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  post(request: CreatePostRequest!): PostResult!

  """
  Repost a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  repost(request: CreateRepostRequest!): PostResult!

  """
  Delete a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  deletePost(request: DeletePostRequest!): DeletePostResult!

  """
  Edit a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  editPost(request: EditPostRequest!): PostResult!

  """
  Bookmark a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  bookmarkPost(request: BookmarkPostRequest!): Void!

  """
  Undo bookmark.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  undoBookmarkPost(request: BookmarkPostRequest!): Void!
  hideReply(request: HideReplyRequest!): Void!
  unhideReply(request: UnhideReplyRequest!): Void!

  """
  React to a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  addReaction(request: AddReactionRequest!): AddReactionResult!

  """
  Undo reaction to a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  undoReaction(request: UndoReactionRequest!): UndoReactionResult!

  """
  Report a post.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  reportPost(request: ReportPostRequest!): Void!

  """
  Follow an Account on the global Graph or a specific Graph.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  follow(request: CreateFollowRequest!): FollowResult!

  """
  Unfollow an Account on the global Graph or a specific Graph.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  unfollow(request: CreateUnfollowRequest!): UnfollowResult!

  """
  Create a new graph
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createGraph(request: CreateGraphRequest!): CreateGraphResult!

  """
  Create a new username namespace aka deploying a new username contract
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createUsernameNamespace(request: CreateUsernameNamespaceRequest!): CreateUsernameNamespaceResult!

  """
  Create a username.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  createUsername(request: CreateUsernameRequest!): CreateUsernameResult!

  """
  Assign a username to an account.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  assignUsernameToAccount(request: AssignUsernameToAccountRequest!): AssignUsernameToAccountResult!

  """
  Unassign a username from the logged-in user's Account.
  
  Defaults to the Lens namespace if no request is provided.
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  unassignUsernameFromAccount(request: UnassignUsernameFromAccountRequest!): UnassignUsernameToAccountResult!

  """
  Add admins to a graph/app/sponsor/feed/username/group.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  addAdmins(request: AddAdminsRequest!): AddAdminsResult!

  """
  Remove admins from a graph/app/sponsor/feed/username/group.
  
  You MUST be authenticated as Account Owner to use this mutation.
  """
  removeAdmins(request: RemoveAdminsRequest!): RemoveAdminsResult!

  """
  Create a new feed
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createFeed(request: CreateFeedRequest!): CreateFeedResult!

  """
  Create a new group
  
  You MUST be authenticated as a builder to use this mutation.
  """
  createGroup(request: CreateGroupRequest!): CreateGroupResult!

  """
  Join a group
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  joinGroup(request: JoinGroupRequest!): JoinGroupResult!

  """
  Leave a group
  
  You MUST be authenticated as Account Owner or Account Manager to use this mutation.
  """
  leaveGroup(request: LeaveGroupRequest!): LeaveGroupResult!
}

input MuteRequest {
  """The account to mute."""
  account: EvmAddress!
}

union NestedPost = Post | PostReference

type NetworkAddress {
  address: EvmAddress!
  chainId: Int!
}

enum NftContractType {
  ERC_721
  ERC_1155
}

type NftOwnershipCondition {
  contract: NetworkAddress!
  contractType: NftContractType!

  """
  A list of token IDs you want to check ownership of. The list is optional for ERC721, you
  MUST provide a list of token IDs for ERC1155.
  """
  tokenIds: [String!]!
  type: String!
}

"""The existence of the transaction is not yet indexed. Keep trying."""
type NotIndexedYetStatus {
  reason: String!

  """True if the transaction has been mined."""
  txHasMined: Boolean!
}

union Notification = ReactionNotification | CommentNotification | RepostNotification | QuoteNotification | FollowNotification | MentionNotification

type NotificationAccountFollow {
  followedAt: DateTime!
  account: Account!
}

type NotificationAccountPostReaction {
  account: Account!
  reactions: [PostReaction!]!
}

type NotificationAccountRepost {
  repostId: PostId!
  repostedAt: DateTime!
  account: Account!
}

input NotificationFilter {
  """The apps to filter by."""
  apps: [EvmAddress!]

  """The notification types to filter by."""
  notificationTypes: [NotificationType!]

  """Include notification from accounts with low score"""
  includeLowScore: Boolean! = false

  """Aggregate notifications by time"""
  timeBasedAggregation: Boolean! = true
}

enum NotificationOrderBy {
  DEFAULT
  ACCOUNT_SCORE
}

input NotificationRequest {
  """The graphs to get notifications for."""
  forGraphs: [EvmAddress!]! = ["0x9e7085a6cc3A02F6026817997cE44B26Ba4Df557"]

  """The feeds to get notifications for."""
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]

  """An optional filter to narrow down the notifications result."""
  filter: NotificationFilter

  """An optional order to sort the notifications result."""
  orderBy: NotificationOrderBy! = DEFAULT
  cursor: Cursor
}

enum NotificationType {
  REPOSTED
  QUOTED
  COMMENTED
  FOLLOWED
  MENTIONED
  REACTED
}

input OnboardingUserChallengeRequest {
  """
  The App you intend to authenticate with.
  
  It MUST be a valid App address.
  Note: On the testnet, it will default to `0x90C8C68D0ABFB40D4FCD72316A65E42161520BC3`, the
  playground app. This is to make it easier if you forget to set it. This may change in the
  future.
  """
  app: EvmAddress! = "0xe5439696f4057aF073c0FB2dc6e5e755392922e1"

  """The address of the EOA that needs to create their Lens Account."""
  wallet: EvmAddress!
}

enum PageSize {
  TEN
  FIFTY
}

type PaginatedAccountManagersResult {
  """The account managers."""
  items: [AccountManager!]!

  """The pagination information for the given request."""
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsAvailableResult {
  """The accounts available to use for the given address"""
  items: [AccountAvailable!]!

  """The pagination information for the given request."""
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsBlockedResult {
  items: [AccountBlocked!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAccountsResult {
  items: [Account!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedActions {
  items: [ActionInfo!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedActiveAuthenticationsResult {
  items: [AuthenticatedSession!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAdminsResult {
  items: [Admin!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAnyPostsResult {
  items: [AnyPost!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppFeedsResult {
  """The feeds"""
  items: [AppFeed!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppSignersResult {
  """The signers"""
  items: [AppSigner!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppUsersResult {
  items: [AppUser!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedAppsResult {
  items: [App!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFeedsResult {
  items: [Feed!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFollowersResult {
  items: [Follower!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedFollowingResult {
  items: [Following!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedGraphsResult {
  items: [Graph!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedGroupsResult {
  """The groups"""
  items: [Group!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedNotificationResult {
  items: [Notification!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostEditsResult {
  items: [PostEdit!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostReactionsResult {
  items: [AccountPostReaction!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostTagsResult {
  items: [Tag!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedPostsResult {
  items: [Post!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedResultInfo {
  """The cursor to the previous page of results, if any."""
  prev: Cursor

  """The cursor to the next page of results, if any."""
  next: Cursor
}

type PaginatedTimelineResult {
  items: [TimelineItem!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUsernameNamespacesResult {
  items: [UsernameNamespace!]!
  pageInfo: PaginatedResultInfo!
}

type PaginatedUsernamesResult {
  items: [Username!]!
  pageInfo: PaginatedResultInfo!
}

type PaymasterParams {
  """The address of the paymaster."""
  paymaster: EvmAddress!

  """The bytestream input for the paymaster."""
  paymasterInput: BlockchainData!
}

"""
The existence of the transaction is known, but its status is not yet known.

The transaction could be:
- waiting to be included in a block
- waiting for a block to be mined
- waiting to be indexed by the Lens Indexer
- waiting for any associated metadata to be snapshotted and indexed
"""
type PendingTransactionStatus {
  blockTimestamp: DateTime!
}

"""PhysicalAddress"""
type PhysicalAddress {
  """The country name component."""
  country: Encryptable!

  """The full mailing address formatted for display."""
  formatted: Encryptable

  """The city or locality."""
  locality: Encryptable!

  """The zip or postal code."""
  postalCode: Encryptable

  """The state or region."""
  region: Encryptable

  """
  The street address including house number, street name, P.O. Box, apartment or unit number
  and extended multi-line address information.
  """
  streetAddress: Encryptable
}

type Post {
  id: PostId!
  author: Account!
  isEdited: Boolean!
  isDeleted: Boolean!
  timestamp: DateTime!
  app: App
  metadata: PostMetadata!
  root: NestedPost
  quoteOf: NestedPost
  commentOn: NestedPost
  actions: [PostAction!]!
  operations: LoggedInPostOperations
  stats: PostStats!
  mentions: [AccountMention!]!
  feed: Feed!
  rules(request: RuleInput): PostRulesConfig!
}

input PostAccountPair {
  post: PostId!
  account: EvmAddress!
}

union PostAction = SimpleCollectActionSettings | UnknownActionSettings

enum PostActionCategoryType {
  COLLECT
}

input PostActionInput {
  collectAction: CollectActionInput!
  unknownAction: UnknownActionInput!
}

enum PostActionType {
  SIMPLE_COLLECT_ACTION
  UNKNOWN_ACTION
}

input PostActionsRequest {
  limit: Int
  cursor: Cursor
  includeUnknown: Boolean
  includeOnlyCollectActions: Boolean
  onlyVerified: Boolean
}

input PostBookmarksFilter {
  metadata: PostMetadataFilter
}

input PostBookmarksRequest {
  """The feeds to get bookmarks for."""
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]
  filter: PostBookmarksFilter
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type PostEdit {
  metadata: PostMetadata!
  timestamp: DateTime!
}

input PostEditsRequest {
  post: PostId!
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

scalar PostId

union PostMetadata = ArticleMetadata | AudioMetadata | CheckingInMetadata | EmbedMetadata | EventMetadata | ImageMetadata | LinkMetadata | LivestreamMetadata | MintMetadata | SpaceMetadata | StoryMetadata | TextOnlyMetadata | ThreeDMetadata | TransactionMetadata | VideoMetadata

input PostMetadataContentWarningFilter {
  oneOf: [ContentWarning!]!
}

input PostMetadataFilter {
  """The main focus of the post."""
  mainContentFocus: [MainContentFocus!]

  """The tags to filter by."""
  tags: PostMetadataTagsFilter

  """The content warning to filter by."""
  contentWarning: PostMetadataContentWarningFilter
}

input PostMetadataTagsFilter {
  oneOf: [String!]
  all: [String!]
}

type PostReaction {
  reaction: PostReactionType!
  reactedAt: DateTime!
}

enum PostReactionOrderBy {
  DEFAULT
  ACCOUNT_SCORE
}

type PostReactionStatus {
  postId: PostId!
  account: EvmAddress!
  result: Boolean!
}

input PostReactionStatusRequest {
  pairs: [PostAccountPair!]!
  filter: PostReactionsFilter
}

enum PostReactionType {
  UPVOTE
  DOWNVOTE
}

input PostReactionsFilter {
  """The types of reactions to filter by."""
  anyOf: [PostReactionType!]
}

input PostReactionsRequest {
  """The ID of the post to get reactions for."""
  post: PostId!

  """An optional filter to narrow down the result."""
  filter: PostReactionsFilter

  """The order in which to return the results."""
  orderBy: PostReactionOrderBy
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type PostReference {
  id: PostId!
}

enum PostReferenceType {
  COMMENT_ON
  REPOST_OF
  QUOTE_OF
}

input PostReferencesRequest {
  """The post to get references for."""
  referencedPost: PostId!

  """The types of references to get."""
  referenceTypes: [PostReferenceType!]!

  """
  The visibility filter to apply by default it will honour the visibility of the post.
  """
  visibilityFilter: PostVisibilityFilter! = VISIBLE

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

enum PostReportReason {
  ANIMAL_ABUSE
  HARASSMENT
  VIOLENCE
  SELF_HARM
  DIRECT_THREAT
  HATE_SPEECH
  NUDITY
  OFFENSIVE
  SCAM
  UNAUTHORIZED_SALE
  IMPERSONATION
  MISLEADING
  MISUSE_HASHTAGS
  UNRELATED
  REPETITIVE
  FAKE_ENGAGEMENT
  MANIPULATION_ALGO
  SOMETHING_ELSE
}

"""You must provide either a txHash or a postId, not both."""
input PostRequest {
  """The post ID."""
  post: PostId

  """The transaction hash you sent the post with."""
  txHash: TxHash
}

type PostResponse {
  hash: TxHash!
}

union PostResult = PostResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

union PostRule = FollowerOnlyPostRule | UnknownPostRule

type PostRulesConfig {
  required: [PostRule!]!
  anyOf: [PostRule!]!
}

type PostStats {
  """The total number of bookmarks."""
  bookmarks: Int!

  """The total number of comments."""
  comments: Int!

  """The total number of reposts."""
  reposts: Int!

  """The total number of quotes."""
  quotes: Int!

  """The total number of collects."""
  collects: Int!

  """Get the number of reactions for the post."""
  reactions(request: StatsReactionRequest! = {type: UPVOTE}): Int!
}

enum PostTagsOrderBy {
  MOST_POPULAR
  ALPHABETICAL
}

input PostTagsRequest {
  """The feeds to get tags for."""
  forFeeds: [EvmAddress!]!
  orderBy: PostTagsOrderBy! = MOST_POPULAR
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

enum PostType {
  ROOT
  COMMENT
  REPOST
  QUOTE
}

enum PostVisibilityFilter {
  """All posts even if they have been hidden"""
  ALL

  """Only the posts that are hidden"""
  HIDDEN

  """Only the posts that are visible"""
  VISIBLE
}

input PostsFilterRequest {
  authors: [EvmAddress!]
  postTypes: [PostType!]
  metadata: PostMetadataFilter
  apps: [EvmAddress!]
}

input PostsRequest {
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]
  filter: PostsFilterRequest
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

"""ProfileOwnershipCondition"""
type ProfileOwnershipCondition {
  profileId: LegacyProfileId!
  type: String!
}

type Query {
  health: Boolean!

  """Get an account by address, username, or legacy profile ID."""
  account(request: AccountRequest!): Account

  """
  Account information for the authenticated account.
  
  You MUST be authenticated to use this query.
  """
  me: MeResult!

  """Get accounts by address, username, or legacy profile ID."""
  accounts(request: AccountsRequest!): [Account!]!

  """Get the stats for an account."""
  accountStats(request: AccountStatsRequest!): AccountStats!

  """Get the account stats for the graphs."""
  accountGraphsStats(request: AccountGraphsStatsRequest!): AccountGraphsFollowStats!

  """Get the account stats for the feeds."""
  accountFeedsStats(request: AccountFeedsStatsRequest!): AccountFeedsStats!

  """
  Accounts blocked for the authenticated account.
  
  You MUST be authenticated to use this query.
  """
  accountsBlocked(request: AccountsBlockedRequest!): PaginatedAccountsBlockedResult!

  """Get the accounts which are available to use for the given address"""
  accountsAvailable(request: AccountsAvailableRequest!): PaginatedAccountsAvailableResult!

  """
  Account manager for the authenticated account.
  
  You MUST be authenticated to use this query.
  """
  accountManagers(request: AccountManagersRequest!): PaginatedAccountManagersResult!

  """Search for accounts by usernames."""
  searchAccounts(request: AccountSearchRequest!): PaginatedAccountsResult!

  """
  Get the last logged in account for the given address and app if specified.
  """
  lastLoggedInAccount(request: LastLoggedInAccountRequest!): Account

  """Get an app"""
  app(request: AppRequest!): App

  """Get the apps"""
  apps(request: AppsRequest!): PaginatedAppsResult!

  """Get the groups for an app"""
  appGroups(request: AppGroupsRequest!): PaginatedGroupsResult!

  """Get the signers for an app"""
  appSigners(request: AppSignersRequest!): PaginatedAppSignersResult!

  """Get the feeds for an app"""
  appFeeds(request: AppFeedsRequest!): PaginatedAppFeedsResult!

  """Get accounts for an app."""
  appUsers(request: AppUsersRequest!): PaginatedAppUsersResult!

  """Get the apps managed by the given address."""
  managedApps(request: ManagedAppsRequest!): PaginatedAppsResult!

  """
  Get the server side API key for the app you must be the owner of the app to see it.
  
  You MUST be authenticated as a builder to use this mutation.
  """
  appServerApiKey(request: AppServerApiKeyRequest!): ServerAPIKey!

  """
  List all active authenticated sessions for the current account.
  
  You MUST be authenticated to use this query.
  """
  authenticatedSessions(request: AuthenticatedSessionsRequest!): PaginatedActiveAuthenticationsResult!

  """
  Get the current authenticated session for the current account.
  
  You MUST be authenticated to use this query.
  """
  currentSession: AuthenticatedSession!
  feed(request: FeedRequest!): Feed

  """Get the feeds managed by the given address."""
  managedFeeds(request: ManagedFeedsRequest!): PaginatedFeedsResult!
  post(request: PostRequest!): AnyPost
  posts(request: PostsRequest!): PaginatedAnyPostsResult!
  postReferences(request: PostReferencesRequest!): PaginatedAnyPostsResult!
  postTags(request: PostTagsRequest!): PaginatedPostTagsResult!
  postBookmarks(request: PostBookmarksRequest!): PaginatedAnyPostsResult!

  """Get the reactions added to a post."""
  postReactions(request: PostReactionsRequest!): PaginatedPostReactionsResult!
  postReactionStatus(request: PostReactionStatusRequest!): [PostReactionStatus!]!
  searchPosts(request: SearchPostsRequest!): PaginatedAnyPostsResult!
  postActions(request: PostActionsRequest!): PaginatedActions!

  """Get accounts who referenced a post"""
  whoReferencedPost(request: WhoReferencedPostRequest!): PaginatedAccountsResult!
  whoActedOnPost(request: WhoActedOnPostRequest!): PaginatedAccountsResult!
  postEdits(request: PostEditsRequest!): PaginatedPostEditsResult!
  following(request: FollowingRequest!): PaginatedFollowingResult!
  followers(request: FollowersRequest!): PaginatedFollowersResult!
  followersYouKnow(request: FollowersYouKnowRequest!): PaginatedFollowersResult!
  followStatus(request: FollowStatusRequest!): [FollowStatusResult!]!
  graph(request: GraphRequest!): Graph

  """Get the graphs managed by the given address."""
  managedGraphs(request: ManagedGraphsRequest!): PaginatedGraphsResult!
  group(request: GroupRequest!): Group

  """Get the groups this account is a member of"""
  groups(request: GroupsRequest!): PaginatedGroupsResult!

  """Search for groups"""
  searchGroups(request: SearchGroupsRequest!): PaginatedGroupsResult!

  """Get the members of the group"""
  groupMembers(request: GroupMembersRequest!): PaginatedAccountsResult!

  """Get the groups managed by the given address."""
  managedGroups(request: ManagedGroupsRequest!): PaginatedGroupsResult!

  """Get the groups managed by the given address."""
  groupStats(request: GroupStatsRequest!): GroupStatsResponse!

  """Get admins for a graph/app/sponsor/feed/username/group address"""
  adminsFor(request: AdminsForRequest!): PaginatedAdminsResult!

  """
  Get account timeline.
  
  You MUST be authenticated to use this query.
  """
  timeline(request: TimelineRequest!): PaginatedTimelineResult!

  """Get most engaged posts for the given account timeline."""
  timelineHighlights(request: TimelineHighlightsRequest!): PaginatedPostsResult!

  """
  Get account notifications.
  
  You MUST be authenticated to use this query.
  """
  notifications(request: NotificationRequest!): PaginatedNotificationResult!

  """Get the status of a transaction by its hash."""
  transactionStatus(request: TransactionStatusRequest!): TransactionStatusResult!
  debugMetadata(request: DebugPostMetadataRequest!): DebugPostMetadataResult!
  debugTransactionStatusFailed(request: DebugTransactionStatusRequest!): DebugTransactionStatusResult
  usernameNamespace(request: UsernameNamespaceRequest!): UsernameNamespace
  username(request: UsernameRequest!): Username

  """Get the usernames for the account/owner."""
  usernames(request: UsernamesRequest!): PaginatedUsernamesResult!

  """Get the namespaces managed by the given address."""
  managedNamespaces(request: ManagedNamespacesRequest!): PaginatedUsernameNamespacesResult!
  _service: _Service!
}

type QuoteNotification {
  id: GeneratedNotificationId!
  quote: Post!
}

type ReactionNotification {
  id: GeneratedNotificationId!
  reactions: [NotificationAccountPostReaction!]!
  post: Post!
}

input RecipientDataInput {
  recipient: EvmAddress!
  split: Float!
}

type RecipientDataOutput {
  recipient: EvmAddress!
  split: Float!
}

input RecommendAccount {
  """The account to recommend."""
  account: EvmAddress!
}

input ReferencingPostInput {
  """The post to reference."""
  post: PostId!
}

input RefreshAppServerApiKeyRequest {
  """The app to refresh the server side api key for"""
  app: EvmAddress!
}

input RefreshRequest {
  refreshToken: RefreshToken!
}

union RefreshResult = AuthenticationTokens | ForbiddenError

scalar RefreshToken

input RemoveAccountManagerRequest {
  """The address to remove as a manager."""
  manager: EvmAddress!
}

union RemoveAccountManagerResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input RemoveAdminsRequest {
  """
  The graph/app/sponsor/feed/username/group address which manages these admins
  """
  address: EvmAddress!

  """The addresses to remove as admins"""
  admins: [EvmAddress!]!
}

union RemoveAdminsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input RemoveAppFeedsRequest {
  """The app to update"""
  app: EvmAddress!

  """The app feeds (max 10 per request)"""
  feeds: [EvmAddress!]!
}

union RemoveAppFeedsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input RemoveAppGroupsRequest {
  """The app to update"""
  app: EvmAddress!

  """The app groups (max 10 per request)"""
  groups: [EvmAddress!]!
}

union RemoveAppGroupsResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input RemoveAppSignersRequest {
  """The app to update"""
  app: EvmAddress!

  """The app signers (max 10 per request)"""
  signers: [EvmAddress!]!
}

union RemoveAppSignersResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

union RemoveSignlessResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input ReportAccountRequest {
  """The account to report."""
  account: EvmAddress!

  """The reason for the report."""
  reason: AccountReportReason!

  """An optional comment to add to the report."""
  additionalComment: String

  """An optional list of posts to reference in the report."""
  referencePosts: [PostId!]
}

input ReportPostRequest {
  post: PostId!
  reason: PostReportReason!
  additionalComment: String
}

type Repost {
  id: PostId!
  author: Account!
  isDeleted: Boolean!
  timestamp: DateTime!
  app: App
  repostOf: Post!
}

type RepostNotification {
  id: GeneratedNotificationId!
  reposts: [NotificationAccountRepost!]!
  post: Post!
}

type RestrictedSigner {
  label: String!
  signer: EvmAddress!
}

type RestrictedSignerGraphRule {
  rule: EvmAddress!
  signers: [RestrictedSigner!]!
}

type RestrictedSignersFeedRule {
  rule: EvmAddress!
  signers: [RestrictedSigner!]!
}

input RevokeAuthenticationRequest {
  authenticationId: UUID!
}

input RolloverRefreshRequest {
  """The app that new tokens will be issued for."""
  app: EvmAddress!

  """A valid Lens API v2 refresh token for a Profile session."""
  refreshToken: LegacyRefreshToken!
}

input RuleInput {
  rules: [EvmAddress!]!
}

input SearchGroupsRequest {
  """The search query"""
  query: String!

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

input SearchPostsFilter {
  """The post types to filter by."""
  postTypes: [PostType!]

  """The optional metadata filter."""
  metadata: PostMetadataFilter
}

input SearchPostsRequest {
  """
  The query text to search for in the post content or metadata tags.
  The passed strings supports web search syntax similar to the search engines:
  - individual words match independently.
  - double-quoted phrases match as a single unit.
  - the word or (case-insensitive) specifies an “or” condition between two words or phrases
  - a "-" prefix specifies to not match the following word or phrase.
  """
  query: String!

  """The feeds to search in."""
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]

  """The optional post types to filter by."""
  filter: SearchPostsFilter
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

enum SelfFundedFallbackReason {
  NOT_SPONSORED
  CANNOT_SPONSOR
}

type SelfFundedTransactionRequest {
  """
  The raw transaction request object.
  
  Use this object if your library does not have a parser for the encoded transaction data.
  """
  raw: Eip1559TransactionRequest!
  reason: String!
  selfFundedReason: SelfFundedFallbackReason
}

scalar ServerAPIKey

input SetAccountMetadataRequest {
  """The metadata URI to set."""
  metadataUri: URI!
}

type SetAccountMetadataResponse {
  hash: TxHash!
}

union SetAccountMetadataResult = SetAccountMetadataResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppGraphRequest {
  """The app to update"""
  app: EvmAddress!

  """The app graph to set"""
  graph: EvmAddress!
}

union SetAppGraphResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppMetadataRequest {
  """The app to update"""
  app: EvmAddress!

  """The app metadata to set"""
  metadataUri: String!
}

union SetAppMetadataResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppSponsorshipRequest {
  """The app to update"""
  app: EvmAddress!

  """The app sponsorship to set"""
  sponsorship: EvmAddress!
}

union SetAppSponsorshipResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppTreasuryRequest {
  """The app to update"""
  app: EvmAddress!

  """The app treasury to set"""
  treasury: EvmAddress!
}

union SetAppTreasuryResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppUsernameNamespaceRequest {
  """The app to update"""
  app: EvmAddress!

  """The app username namespace to set"""
  usernameNamespace: EvmAddress!
}

union SetAppUsernameNamespaceResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetAppVerificationRequest {
  """The app to update"""
  app: EvmAddress!

  """The new verification state"""
  enabled: Boolean!
}

union SetAppVerificationResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input SetDefaultAppFeedRequest {
  """The app to update"""
  app: EvmAddress!

  """The app default feed to set"""
  feed: EvmAddress!
}

union SetDefaultAppFeedResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

scalar Signature

input SignedAuthChallenge {
  id: UUID!
  signature: Signature!
}

input SimpleCollectActionInput {
  amount: AmountInput
  referralFee: Float
  recipient: EvmAddress
  collectLimit: String
  followerOnly: Boolean!
  endsAt: DateTime
  recipients: [RecipientDataInput!]
}

type SimpleCollectActionSettings {
  contract: NetworkAddress!
  amount: Amount!
  collectNft: EvmAddress
  collectLimit: String
  followerOnly: Boolean!
  recipient: EvmAddress!
  referralFee: Float!
  endsAt: DateTime
  recipients: [RecipientDataOutput!]!
}

type SimplePaymentFeedRule {
  rule: EvmAddress!
  amount: Amount!
  recipient: EvmAddress!
}

type SimplePaymentFollowRule {
  rule: EvmAddress!
  amount: Amount!
  recipient: EvmAddress!
}

type SimplePaymentGroupRule {
  rule: EvmAddress!
  amount: Amount!
  recipient: EvmAddress!
}

type SimplePaymentUsernameNamespaceRule {
  rule: EvmAddress!
  amount: Amount!
  recipient: EvmAddress!
}

type SpaceMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!

  """The space join link."""
  link: Encryptable!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """The space start time (ISO 8601 `YYYY-MM-DDTHH:mm:ss.sssZ`)."""
  startsAt: Encryptable!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The space title."""
  title: String!
  content: Encryptable!
}

enum SponsorLimitType {
  HOUR
  DAY
  WEEK
  MONTH
}

enum SponsoredFallbackReason {
  SIGNLESS_DISABLED
  SIGNLESS_FAILED
}

type SponsoredTransactionRequest {
  """
  The raw transaction request object.
  
  Use this object if your library does not have a parser for the encoded transaction data.
  """
  raw: Eip712TransactionRequest!
  reason: String!
  sponsoredReason: SponsoredFallbackReason
}

type SponsorshipAllowance {
  """The sponsorship window type."""
  window: SponsorLimitType!

  """The number of remaining sponsorship allowance."""
  allowanceLeft: Int!

  """The number of sponsorship allowance used."""
  allowanceUsed: Int!

  """The total sponsorship allowance."""
  allowance: Int!
}

input StatsReactionRequest {
  type: PostReactionType!
}

type StoryMetadata {
  """The story asset."""
  asset: AnyMedia!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

input SwitchAccountRequest {
  account: EvmAddress!
}

union SwitchAccountResult = AuthenticationTokens | ForbiddenError

scalar Tag

type TextOnlyMetadata {
  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!
  content: Encryptable!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]
}

type ThreeDAsset {
  """The 3D format of the asset."""
  format: ThreeDAssetFormat!

  """The license regulating the use of the 3D asset."""
  license: MetadataLicenseType

  """
  The URL of the recommended web based 3D player to use to view the 3D asset.
  """
  playerUrl: URI!

  """The URI of the 3D asset zip file."""
  uri: URI!

  """Path in extracted zip. Relative. 3D start point, MUST be 3D file type."""
  zipPath: String
}

enum ThreeDAssetFormat {
  G_LTF_GLB
  FBX
  VRM
  OBJ
}

type ThreeDMetadata {
  """The 3D items for the post"""
  assets: [ThreeDAsset!]!

  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]
  content: Encryptable!
}

enum TimelineEventItemType {
  POST
  COMMENT
  REPOST
  QUOTE
}

input TimelineFilter {
  """The post event types to filter by."""
  eventType: [TimelineEventItemType!]

  """The optional metadata filter."""
  metadata: PostMetadataFilter
}

input TimelineHighlightsFilter {
  metadata: PostMetadataFilter
}

input TimelineHighlightsRequest {
  """The account to get timeline highlights for."""
  account: EvmAddress!

  """The feeds to get timeline for."""
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]

  """An optional filter to apply to the timeline."""
  filter: TimelineHighlightsFilter
  pageSize: PageSize! = FIFTY
  cursor: Cursor
}

type TimelineItem {
  id: UUID!
  primary: Post!
  reposts: [Post!]!
  comments: [Post!]!
}

input TimelineRequest {
  """The account to get timeline for."""
  account: EvmAddress!

  """The feeds to get timeline for."""
  forFeeds: [EvmAddress!]! = ["0x83C8D9e96Da13aaD12E068F48C639C7671D2a5C7"]

  """An optional filter to apply to the timeline."""
  filter: TimelineFilter

  """The cursor."""
  cursor: Cursor
}

type TokenGatedFeedRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

type TokenGatedFollowRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

type TokenGatedGraphRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

type TokenGatedGroupRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

type TokenGatedUsernameNamespaceRule {
  rule: EvmAddress!
  tokenStandard: TokenStandard!
  typeId: BigInt!
  token: EvmAddress!
  amount: Amount!
}

enum TokenStandard {
  ERC_20
  ERC_721
  ERC_1155
}

"""AccessCondition"""
type TopLevelAccessCondition {
  criteria: [AnyAccessCondition!]!
  type: String!
}

type TransactionMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """The Chain Id."""
  chainId: ChainId!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The transaction hash."""
  txHash: Encryptable!

  """The type of transaction."""
  type: TransactionType!
  content: Encryptable!
}

input TransactionStatusRequest {
  txHash: TxHash!
}

union TransactionStatusResult = PendingTransactionStatus | FinishedTransactionStatus | FailedTransactionStatus | NotIndexedYetStatus

enum TransactionType {
  ERC_721
  ERC_20
  OTHER
}

type TransactionWillFail {
  reason: String!
}

enum TriStateValue {
  YES
  NO
  UNKNOWN
}

scalar TxHash

scalar URI

scalar URL

"""
A UUID is a unique 128-bit number, stored as 16 octets. UUIDs are parsed as
Strings within GraphQL. UUIDs are used to assign unique identifiers to
entities without requiring a central allocating authority.

# References

* [Wikipedia: Universally Unique Identifier](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC4122: A Universally Unique IDentifier (UUID) URN Namespace](http://tools.ietf.org/html/rfc4122)
"""
scalar UUID @specifiedBy(url: "http://tools.ietf.org/html/rfc4122")

input UnassignUsernameFromAccountRequest {
  namespace: EvmAddress! = "0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"
}

type UnassignUsernameResponse {
  hash: TxHash!
}

union UnassignUsernameToAccountResult = UnassignUsernameResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type UnblockError {
  error: UnblockErrorType!
}

enum UnblockErrorType {
  UNKNOWN
  NOT_BLOCKED
  UNAUTHORIZED
}

input UnblockRequest {
  """The account to unblock."""
  account: EvmAddress!
}

type UnblockResponse {
  hash: TxHash!
}

union UnblockResult = UnblockResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | UnblockError

type UndoReactionFailure {
  reason: String!
}

input UndoReactionRequest {
  """The reaction to add."""
  reaction: PostReactionType!

  """The post to react to."""
  post: PostId!
}

type UndoReactionResponse {
  success: Boolean!
}

union UndoReactionResult = UndoReactionResponse | UndoReactionFailure

input UndoRecommendedAccount {
  """The account to remove as a recommendation."""
  account: EvmAddress!
}

type UnfollowResponse {
  hash: TxHash!
}

union UnfollowResult = UnfollowResponse | SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

input UnhideManagedAccountRequest {
  """The account to unhide."""
  account: EvmAddress!
}

input UnhideReplyRequest {
  post: PostId!
}

type UnknownAction {
  name: String!
  contract: NetworkAddress!
}

input UnknownActionInput {
  address: EvmAddress!
  data: String!
}

type UnknownActionSettings {
  initializeCalldata: BlockchainData
  initializeResultData: BlockchainData
  verified: Boolean!
  contract: NetworkAddress!
  collectNft: EvmAddress
}

type UnknownFeedRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

input UnknownFeedRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

type UnknownFollowRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

input UnknownFollowRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

type UnknownGraphRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

input UnknownGraphRuleInput {
  """The rule contract address."""
  address: EvmAddress!

  """The encoded rule execution data."""
  data: BlockchainData!
}

type UnknownGroupRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

type UnknownPostRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

type UnknownUsernameNamespaceRule {
  rule: EvmAddress!
  configData: BlockchainData!
}

input UpdateAccountManagerRequest {
  """The address to update as a manager."""
  manager: EvmAddress!

  """The permissions to update for the account manager."""
  permissions: AccountManagerPermissionsInput!
}

union UpdateAccountManagerResult = SponsoredTransactionRequest | SelfFundedTransactionRequest | TransactionWillFail

type UserBlockingRule {
  rule: EvmAddress!
  blockedUsers: [EvmAddress!]!
}

type Username {
  """A unique identifier for the username entry."""
  id: ID!

  """The username value (e.g., lens/bob)."""
  value: UsernameValue!

  """The local name of the username (e.g., bob)."""
  localName: String!

  """The address that the username is linked to, if any."""
  linkedTo: EvmAddress

  """The address that owns the username entry."""
  ownedBy: EvmAddress!

  """The timestamp when the username was created."""
  timestamp: DateTime!
  namespace: UsernameNamespace!
}

input UsernameInput {
  """The local name to create - should not include the namespace"""
  localName: String!

  """The namespace. Defaults to lens namespace"""
  namespace: EvmAddress! = "0x6Cc71E78e25eBF6A2525CadC1fc628B42AE4138f"
}

type UsernameNamespace {
  """The address of the namespace."""
  address: EvmAddress!

  """The namespace for example `lens`"""
  namespace: String!
  createdAt: DateTime!
  metadata: UsernameNamespaceMetadata
  owner: EvmAddress!
  rules(request: RuleInput): UsernameNamespaceRulesConfig!
}

type UsernameNamespaceMetadata {
  """An optional description of the Username collection."""
  description: String

  """
  A unique identifier that in storages like IPFS ensures the uniqueness of the metadata URI.
  Use a UUID if unsure.
  """
  id: String!
}

input UsernameNamespaceRequest {
  """The namespace"""
  namespace: EvmAddress

  """The transaction hash you created the namespace with."""
  txHash: TxHash
}

union UsernameNamespaceRule = TokenGatedUsernameNamespaceRule | SimplePaymentUsernameNamespaceRule | CharsetUsernameNamespaceRule | LengthUsernameNamespaceRule | UnknownUsernameNamespaceRule

type UsernameNamespaceRulesConfig {
  required: [UsernameNamespaceRule!]!
  anyOf: [UsernameNamespaceRule!]!
}

"""You must provide either an id or a username, not both."""
input UsernameRequest {
  """The username ID."""
  id: ID

  """The username namespace and local name."""
  username: UsernameInput
}

scalar UsernameValue

input UsernamesRequest {
  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor

  """The account or address to get owned usernames for."""
  owner: EvmAddress!
}

type VideoMetadata {
  """The other attachments you want to include with it."""
  attachments: [AnyMedia!]!

  """
  A bag of attributes that can be used to store any kind of metadata that is not currently
  supported by the standard. Over time, common attributes will be added to the standard and
  their usage as arbitrary attributes will be discouraged.
  """
  attributes: [MetadataAttribute!]!

  """Specify a content warning."""
  contentWarning: ContentWarning
  encryptedWith: EncryptionStrategy
  id: MetadataId!
  locale: Locale!

  """The main focus of the post."""
  mainContentFocus: MainContentFocus!

  """An arbitrary list of tags."""
  tags: [Tag!]

  """The optional video title."""
  title: String
  video: MediaVideo!
  content: Encryptable!
}

scalar Void

input WhoActedOnPostFilter {
  anyOf: [ActionFilter!]!
}

enum WhoActedOnPostOrderBy {
  LAST_ACTIONED
  FIRST_ACTIONED
  ACCOUNT_SCORE
}

input WhoActedOnPostRequest {
  """The post id to get who acted on."""
  post: PostId!
  filter: WhoActedOnPostFilter
  orderBy: WhoActedOnPostOrderBy

  """The page size."""
  pageSize: Int

  """The cursor."""
  cursor: Cursor
}

enum WhoReferencedPostOrderBy {
  MOST_RECENT
  OLDEST
  ACCOUNT_SCORE
}

input WhoReferencedPostRequest {
  """The post id to get who referenced."""
  post: PostId!

  """The types of references to get."""
  referenceTypes: [PostReferenceType!]!
  orderBy: WhoReferencedPostOrderBy! = MOST_RECENT

  """The page size."""
  pageSize: PageSize! = FIFTY

  """The cursor."""
  cursor: Cursor
}

"""The signature was not signed by the expected signer."""
type WrongSignerError {
  reason: String!
}

type _Service {
  sdl: String
}